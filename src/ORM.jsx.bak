import { useState } from 'react'

const ModernDiagram = ({ components, onComponentClick, title, width = 1400, height = 800, containerWidth = 1800 }) => {
  const [hoveredComponent, setHoveredComponent] = useState(null)

  return (
    <div style={{
      width: '100%',
      maxWidth: `${containerWidth}px`,
      margin: '0 auto',
      backgroundColor: '#f8fafc',
      borderRadius: '16px',
      padding: '2rem',
      boxShadow: '0 10px 30px -5px rgba(0, 0, 0, 0.1)',
      border: '2px solid #e2e8f0'
    }}>
      <h3 style={{
        textAlign: 'center',
        marginBottom: '2rem',
        fontSize: '1.75rem',
        fontWeight: '800',
        color: '#1e293b',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
      }}>
        {title}
      </h3>

      <svg width="100%" height={height} viewBox={`0 0 ${width} ${height}`} style={{ overflow: 'visible' }}>
        <defs>
          <linearGradient id="blueGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#3b82f6" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#1e40af" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="greenGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#10b981" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#059669" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="purpleGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#8b5cf6" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#7c3aed" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="redGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#ef4444" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#dc2626" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="orangeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#f59e0b" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#d97706" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="tealGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#14b8a6" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#0d9488" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="indigoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#6366f1" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#4f46e5" stopOpacity="0.9"/>
          </linearGradient>
          <linearGradient id="pinkGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#ec4899" stopOpacity="0.8"/>
            <stop offset="100%" stopColor="#db2777" stopOpacity="0.9"/>
          </linearGradient>
        </defs>

        {/* Connecting lines */}
        <g stroke="#64748b" strokeWidth="4" strokeOpacity="0.7" fill="none">
          <line x1="200" y1="300" x2="600" y2="200" strokeDasharray="10,5"/>
          <line x1="200" y1="300" x2="600" y2="400" strokeDasharray="10,5"/>
          <line x1="800" y1="200" x2="1200" y2="300" strokeDasharray="10,5"/>
          <line x1="600" y1="400" x2="1000" y2="300" strokeDasharray="10,5"/>
          <line x1="200" y1="500" x2="600" y2="600" strokeDasharray="10,5"/>
          <line x1="800" y1="500" x2="600" y2="600" strokeDasharray="10,5"/>
        </g>

        {/* Component rectangles */}
        {components.map((component) => (
          <g key={component.id}>
            <rect
              x={component.x}
              y={component.y}
              width={component.width}
              height={component.height}
              rx="12"
              ry="12"
              fill={`url(#${component.color}Gradient)`}
              stroke={hoveredComponent === component.id ? '#1e293b' : '#64748b'}
              strokeWidth={hoveredComponent === component.id ? '4' : '2'}
              style={{
                cursor: 'pointer',
                filter: hoveredComponent === component.id ? 'drop-shadow(0 8px 16px rgba(0,0,0,0.2))' : 'drop-shadow(0 4px 8px rgba(0,0,0,0.1))',
                transform: hoveredComponent === component.id ? 'scale(1.02)' : 'scale(1)',
                transformOrigin: `${component.x + component.width/2}px ${component.y + component.height/2}px`,
                transition: 'all 0.2s ease'
              }}
              onMouseEnter={() => setHoveredComponent(component.id)}
              onMouseLeave={() => setHoveredComponent(null)}
              onClick={() => onComponentClick && onComponentClick(component)}
            />

            {/* Icon */}
            <text
              x={component.x + component.width/2}
              y={component.y + 35}
              textAnchor="middle"
              fontSize="48"
              style={{ userSelect: 'none', pointerEvents: 'none' }}
            >
              {component.icon}
            </text>

            {/* Title */}
            <text
              x={component.x + component.width/2}
              y={component.y + 75}
              textAnchor="middle"
              fontSize="18"
              fontWeight="700"
              fill="white"
              style={{ userSelect: 'none', pointerEvents: 'none' }}
            >
              {component.title}
            </text>

            {/* Details */}
            {component.details && component.details.slice(0, 3).map((detail, idx) => (
              <text
                key={idx}
                x={component.x + component.width/2}
                y={component.y + 100 + (idx * 15)}
                textAnchor="middle"
                fontSize="10"
                fontWeight="500"
                fill="rgba(255,255,255,0.9)"
                style={{ userSelect: 'none', pointerEvents: 'none' }}
              >
                {detail.name.length > 18 ? detail.name.substring(0, 15) + '...' : detail.name}
              </text>
            ))}
            {component.details && component.details.length > 3 && (
              <text
                x={component.x + component.width/2}
                y={component.y + 145}
                textAnchor="middle"
                fontSize="10"
                fontWeight="500"
                fill="rgba(255,255,255,0.7)"
                style={{ userSelect: 'none', pointerEvents: 'none' }}
              >
                +{component.details.length - 3} more features...
              </text>
            )}
          </g>
        ))}
      </svg>
    </div>
  )
}

function ORM({ onBack }) {
  const [selectedComponent, setSelectedComponent] = useState(null)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [selectedConcept, setSelectedConcept] = useState(null)

  const components = [
    {
      id: 'hibernate', x: 80, y: 240, width: 350, height: 160,
      icon: '🔄', title: 'Hibernate Framework', color: 'orange',
      details: [
        { name: 'Object-Relational Mapping', explanation: 'Maps Java objects to database tables automatically. Classes become tables, fields become columns, instances become rows. Eliminates manual SQL writing for CRUD operations. Annotations or XML for mapping configuration. Natural object-oriented programming.' },
        { name: 'Session Management', explanation: 'Session represents conversation with database. First-level cache stores entities in session scope. Manages entity lifecycle states: transient, persistent, detached, removed. Automatic dirty checking and synchronization. Transaction boundaries.' },
        { name: 'HQL & Criteria API', explanation: 'HQL (Hibernate Query Language) is object-oriented query language. Query entities instead of tables. Criteria API for programmatic type-safe queries. QueryDSL integration. Named queries for reusability. Compile-time safety.' },
        { name: 'Caching Layers', explanation: 'First-level cache (session scope), second-level cache (session factory scope), query cache. Integration with EhCache, Hazelcast, Infinispan. Dramatically reduces database hits. Configurable per entity. Cache strategies: read-only, read-write, nonstrict-read-write, transactional.' },
        { name: 'Relationship Mapping', explanation: 'Support for @OneToOne, @OneToMany, @ManyToOne, @ManyToMany relationships. Bidirectional and unidirectional associations. Cascade operations. Orphan removal. Join tables and foreign keys managed automatically. Complex object graphs.' },
        { name: 'Interceptors & Events', explanation: 'Lifecycle event listeners for entity state changes. Pre/post insert, update, delete, load callbacks. Custom interceptors for cross-cutting concerns. Audit logging, validation, security. Envers for entity versioning and auditing.' }
      ],
      description: 'Popular Java ORM framework providing transparent persistence with sophisticated caching, query APIs, and relationship management.'
    },
    {
      id: 'jpa', x: 580, y: 140, width: 350, height: 160,
      icon: '☕', title: 'JPA (Java Persistence API)', color: 'orange',
      details: [
        { name: 'Standard Specification', explanation: 'Java EE/Jakarta EE standard for ORM. Provider-agnostic API. Implementations: Hibernate, EclipseLink, OpenJPA. Write once, switch providers easily. Industry standard annotations and patterns. Portable across application servers.' },
        { name: 'Entity Annotations', explanation: '@Entity, @Table, @Id, @GeneratedValue, @Column annotations define mapping. @Embedded for value objects. @Inheritance strategies. @Enumerated for enums. Rich annotation set for all mapping scenarios. Convention over configuration.' },
        { name: 'EntityManager', explanation: 'Core interface for persistence operations. persist(), merge(), remove(), find() methods. Manages persistence context. Query creation. Transaction management. Similar to Hibernate Session but standardized.' },
        { name: 'JPQL', explanation: 'Java Persistence Query Language - object-oriented SQL-like syntax. Query entities and their fields. Supports joins, subqueries, aggregations, projections. Named and native queries. Parameter binding. Pagination support.' },
        { name: 'Transaction Management', explanation: 'Integration with JTA (Java Transaction API). Container-managed or application-managed transactions. @Transactional annotation (with Spring). ACID guarantees. Rollback on exceptions. Isolation levels.' },
        { name: 'Bean Validation', explanation: 'Integration with JSR 380 Bean Validation. @NotNull, @Size, @Min, @Max, @Pattern constraints. Automatic validation before persist/update. Custom validators. Consistent validation across layers. Fail-fast with meaningful errors.' }
      ],
      description: 'Standard Java specification for ORM providing portable, vendor-neutral persistence layer with rich annotations and JPQL.'
    },
    {
      id: 'entity-mapping', x: 580, y: 340, width: 350, height: 160,
      icon: '🗺️', title: 'Entity Mapping', color: 'orange',
      details: [
        { name: 'Table & Column Mapping', explanation: '@Table specifies database table name. @Column for column properties: name, length, nullable, unique. @Temporal for dates. @Lob for large objects. @Transient for non-persistent fields. Explicit control over schema mapping.' },
        { name: 'Primary Keys', explanation: '@Id marks primary key. @GeneratedValue strategies: AUTO, IDENTITY, SEQUENCE, TABLE. @SequenceGenerator and @TableGenerator for custom generation. Composite keys with @EmbeddedId or @IdClass. Natural vs surrogate keys.' },
        { name: 'Embeddable Objects', explanation: '@Embeddable for value objects embedded in entities. Reusable components. @Embedded in entity class. No separate table. Useful for addresses, names, coordinates. Flattened into entity table.' },
        { name: 'Inheritance Mapping', explanation: 'Three strategies: SINGLE_TABLE (default), TABLE_PER_CLASS, JOINED. @Inheritance annotation. @DiscriminatorColumn for single table. Trade-offs between normalization and performance. Polymorphic queries.' },
        { name: 'Collection Mapping', explanation: '@ElementCollection for collections of basic types or embeddables. @OneToMany/@ManyToMany for entity relationships. List, Set, Map support. @OrderBy, @OrderColumn for ordering. Lazy/eager fetch types.' },
        { name: 'Converter & Enumerated', explanation: '@Converter for custom type conversions. Convert Java types to database columns. @Enumerated(STRING/ORDINAL) for enums. AttributeConverter interface. Centralized conversion logic. Type safety.' }
      ],
      description: 'Configuration of how Java entities map to database tables using annotations for fields, relationships, and strategies.'
    },
    {
      id: 'query-optimization', x: 80, y: 440, width: 350, height: 160,
      icon: '⚡', title: 'Query Optimization', color: 'orange',
      details: [
        { name: 'Fetch Strategies', explanation: 'EAGER loads data immediately. LAZY loads on-demand. @Fetch(FetchMode.JOIN/SELECT/SUBSELECT) controls SQL generation. Entity graphs for dynamic fetch plans. Balance between data loading and performance. Avoid unnecessary queries.' },
        { name: 'N+1 Query Problem', explanation: 'One query loads entities, N queries load relationships. Use JOIN FETCH in JPQL. Batch fetching with @BatchSize. Entity graphs. Show SQL to detect. Major performance bottleneck if unaddressed. Monitor query counts.' },
        { name: 'Projections & DTOs', explanation: 'Select only needed columns with constructor expressions in JPQL. ResultTransformer for custom mappings. Blaze-Persistence for advanced projections. Spring Data Projections. Reduce data transfer and memory usage.' },
        { name: 'Query Hints', explanation: 'JPA query hints for optimization. Timeout hints. Cache retrieval/store modes. Flush modes. Lock modes. Fetch size. Read-only hints. Provider-specific optimizations. Fine-tune query execution.' },
        { name: 'Index Awareness', explanation: 'Design queries to use database indexes. @Index annotation on columns. Avoid functions on indexed columns. Leading column in composite indexes. WHERE, JOIN, ORDER BY considerations. Explain plans.' },
        { name: 'Pagination & Streaming', explanation: 'setFirstResult() and setMaxResults() for pagination. Stream API for large result sets. Cursor-based pagination. Avoid offset on large datasets. ScrollableResults. Memory-efficient processing.' }
      ],
      description: 'Techniques for optimizing ORM queries including fetch strategies, solving N+1 problems, and using projections.'
    },
    {
      id: 'caching', x: 580, y: 540, width: 350, height: 160,
      icon: '💾', title: 'Caching Strategies', color: 'orange',
      details: [
        { name: 'First-Level Cache', explanation: 'Session/EntityManager scope cache. Automatic and mandatory. Stores entities within single session. Ensures repeatable reads. Cleared on session close. Prevents duplicate queries for same entity in transaction.' },
        { name: 'Second-Level Cache', explanation: 'SessionFactory/EntityManagerFactory scope. Shared across sessions. Optional, configurable per entity. @Cacheable annotation. Cache providers: EhCache, Hazelcast, Infinispan. Dramatically reduces database load. Invalidation strategies.' },
        { name: 'Query Cache', explanation: 'Caches query result sets by query string and parameters. Must enable second-level cache first. query.setCacheable(true). Invalidated when related entity data changes. Useful for repeated queries with same parameters.' },
        { name: 'Cache Modes', explanation: 'CacheStoreMode: USE, BYPASS, REFRESH. CacheRetrieveMode: USE, BYPASS. Control cache behavior per query. Force database hit when needed. Refresh stale data. Balance consistency and performance.' },
        { name: 'Eviction & Expiration', explanation: 'TTL (time-to-live) for cache entries. LRU/LFU eviction policies. Manual eviction with cache.evict(). Clear entire cache. Memory management. Stale data prevention. Configuration per entity or globally.' },
        { name: 'Distributed Caching', explanation: 'Hazelcast, Infinispan for clustered deployments. Cache replication across nodes. Invalidation messages. Near cache optimization. Scalability in multi-server environments. Consistent caching.' }
      ],
      description: 'Multi-level caching mechanisms to reduce database access including session, application, and query caches.'
    },
    {
      id: 'transaction-management', x: 1080, y: 240, width: 350, height: 160,
      icon: '🔐', title: 'Transaction Management', color: 'orange',
      details: [
        { name: 'ACID Properties', explanation: 'Atomicity: all or nothing. Consistency: valid state transitions. Isolation: concurrent transaction handling. Durability: committed changes persist. ORM ensures ACID through transaction boundaries. Data integrity guarantees.' },
        { name: 'Programmatic Transactions', explanation: 'Manual transaction control with transaction.begin(), commit(), rollback(). Try-finally blocks for cleanup. Exception handling. Fine-grained control. Useful for complex transaction logic. Resource management.' },
        { name: 'Declarative Transactions', explanation: '@Transactional annotation (Spring/Jakarta EE). AOP-based transaction proxies. Automatic rollback on unchecked exceptions. Propagation behaviors: REQUIRED, REQUIRES_NEW, NESTED, etc. Simpler, cleaner code.' },
        { name: 'Isolation Levels', explanation: 'READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE. Control concurrent transaction behavior. Trade-off between consistency and performance. Database-dependent. Prevent dirty reads, phantom reads, lost updates.' },
        { name: 'Optimistic Locking', explanation: '@Version field for optimistic locking. Detects concurrent modifications. OptimisticLockException on conflict. Better concurrency than pessimistic locks. Last-commit-wins or retry strategies. Suitable for low contention.' },
        { name: 'Pessimistic Locking', explanation: 'LockModeType.PESSIMISTIC_READ/WRITE/FORCE_INCREMENT. Database-level locks. Prevents concurrent modifications. Higher consistency, lower concurrency. SELECT FOR UPDATE queries. Use sparingly for critical sections.' }
      ],
      description: 'Managing database transactions with ACID guarantees, isolation levels, and optimistic/pessimistic locking strategies.'
    },
    {
      id: 'lazy-eager', x: 1080, y: 440, width: 350, height: 160,
      icon: '🎯', title: 'Lazy/Eager Loading', color: 'orange',
      details: [
        { name: 'Lazy Loading', explanation: 'Data loaded on first access. Proxy objects for unloaded data. Reduces initial query overhead. LazyInitializationException if session closed. Requires open persistence context. Default for collections and *ToMany relationships.' },
        { name: 'Eager Loading', explanation: 'Data loaded immediately with parent entity. Single query or separate queries. JOIN FETCH in queries. Simpler programming model. Risk of loading too much data. Default for *ToOne relationships. Memory considerations.' },
        { name: 'Fetch Joins', explanation: 'JPQL: SELECT u FROM User u JOIN FETCH u.orders. Single query loads parent and children. Prevents N+1 problem. Can cause cartesian product with multiple collections. Distinct results. Most efficient loading strategy.' },
        { name: 'Entity Graphs', explanation: 'JPA 2.1+ feature for dynamic fetch plans. @NamedEntityGraph annotation or programmatic. Override default fetch types. Mix of LAZY and EAGER per query. More flexible than static annotations. Query-specific optimization.' },
        { name: 'Batch Fetching', explanation: '@BatchSize(size=10) annotation. Loads collections in batches. Reduces number of queries without JOIN FETCH. Multiple IDs in IN clause. Middle ground between lazy and eager. Configuration per relationship.' },
        { name: 'Fetch Strategy Trade-offs', explanation: 'Lazy: fewer initial queries, risk of LazyInitializationException. Eager: simpler code, potentially wasteful. Choose based on use case. Different strategies for different scenarios. Profile actual usage patterns.' }
      ],
      description: 'Loading strategies for entity relationships balancing between immediate data retrieval and on-demand loading.'
    },
    {
      id: 'n-plus-one', x: 1080, y: 640, width: 350, height: 140,
      icon: '⚠️', title: 'N+1 Problem', color: 'orange',
      details: [
        { name: 'Problem Description', explanation: 'One query loads N parent entities, then N additional queries load children for each parent. Extremely common performance issue. 1 + N total queries. Linear growth with data size. Can bring system to crawl. Often invisible until production load.' },
        { name: 'Detection', explanation: 'Enable SQL logging: hibernate.show_sql=true. Look for repeated similar queries. APM tools show query patterns. Performance testing with realistic data volumes. Monitoring query counts. SQL explain plans.' },
        { name: 'JOIN FETCH Solution', explanation: 'Use JOIN FETCH in JPQL/HQL: FROM User u JOIN FETCH u.orders. Single query loads everything. Most efficient solution. Watch for cartesian products with multiple collections. Use SET to deduplicate results.' },
        { name: 'Batch Fetching', explanation: '@BatchSize(size=10) annotation loads in batches. Fewer queries than N+1 but more than JOIN FETCH. Good for collections that are rarely accessed. Reduces N+1 impact without complex queries.' },
        { name: 'Entity Graphs', explanation: 'Define fetch graph dynamically. entityGraph.addAttributeNodes("orders"). Applied per query. Overrides default lazy loading. Clean separation of mapping and fetching strategy. Multiple graphs for different use cases.' }
      ],
      description: 'Common ORM performance anti-pattern where loading parent entities triggers N additional queries for relationships.'
    }
  ]

  const handleComponentClick = (component) => {
    setSelectedComponent(component)
    setIsModalOpen(true)
  }

  const closeModal = () => {
    setIsModalOpen(false)
    setSelectedComponent(null)
    setSelectedConcept(null)
  }

  const handleConceptClick = (concept) => {
    setSelectedConcept(concept)
  }

  return (
    <div style={{
      padding: '2rem',
      maxWidth: '95%',
      margin: '120px auto 0',
      backgroundColor: 'white',
      borderRadius: '16px',
      boxShadow: '0 20px 40px -10px rgba(0, 0, 0, 0.15)',
      border: '3px solid rgba(249, 115, 22, 0.4)'
    }}>
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '2rem'
      }}>
        <button
          onClick={onBack}
          style={{
            padding: '0.75rem 1.5rem',
            fontSize: '1rem',
            fontWeight: '600',
            backgroundColor: '#6b7280',
            color: 'white',
            border: 'none',
            borderRadius: '8px',
            cursor: 'pointer',
            transition: 'all 0.2s ease'
          }}
        >
          ← Back to Menu
        </button>
        <h1 style={{
          fontSize: '2.5rem',
          fontWeight: '800',
          color: '#1f2937',
          margin: 0,
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        }}>
          Object-Relational Mapping
        </h1>
        <div style={{ width: '120px' }}></div>
      </div>

      <div style={{
        backgroundColor: 'rgba(249, 115, 22, 0.05)',
        padding: '2.5rem 10rem',
        borderRadius: '16px',
        border: '3px solid rgba(249, 115, 22, 0.3)',
        marginBottom: '2rem'
      }}>
        <p style={{
          fontSize: '1.3rem',
          color: '#374151',
          fontWeight: '500',
          margin: 0,
          lineHeight: '1.8',
          textAlign: 'center'
        }}>
          Object-Relational Mapping: Hibernate and JPA frameworks enabling transparent persistence,
          entity mapping strategies, query optimization techniques, caching layers, transaction management,
          lazy/eager loading patterns, and solving the N+1 query problem.
        </p>
      </div>

      <ModernDiagram
        components={components}
        onComponentClick={handleComponentClick}
        title="ORM Concepts and Best Practices"
        width={1400}
        height={800}
        containerWidth={1800}
      />

      {/* Modal */}
      {isModalOpen && selectedComponent && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.7)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 1000
        }}>
          <div style={{
            backgroundColor: 'white',
            padding: '2.5rem',
            borderRadius: '16px',
            maxWidth: '1400px',
            width: '95%',
            maxHeight: '85vh',
            overflowY: 'auto',
            boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
            border: '3px solid rgba(249, 115, 22, 0.4)'
          }}>
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '2rem'
            }}>
              <h2 style={{
                fontSize: '2rem',
                fontWeight: '800',
                color: '#1f2937',
                margin: 0,
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
              }}>
                {selectedComponent.icon} {selectedComponent.title}
              </h2>
              <button
                onClick={closeModal}
                style={{
                  padding: '0.5rem 1rem',
                  fontSize: '1.25rem',
                  fontWeight: '600',
                  backgroundColor: '#ef4444',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease'
                }}
              >
                ✕
              </button>
            </div>

            <div style={{
              backgroundColor: 'rgba(249, 115, 22, 0.05)',
              padding: '1.5rem',
              borderRadius: '12px',
              border: '2px solid rgba(249, 115, 22, 0.2)',
              marginBottom: '2rem'
            }}>
              <p style={{
                fontSize: '1.1rem',
                color: '#374151',
                fontWeight: '500',
                margin: 0,
                lineHeight: '1.6'
              }}>
                {selectedComponent.description}
              </p>
            </div>

            <div style={{
              display: 'grid',
              gridTemplateColumns: selectedConcept ? '1fr 1fr' : '1fr',
              gap: '2rem'
            }}>
              <div>
                <h3 style={{
                  fontSize: '1.25rem',
                  fontWeight: '700',
                  color: '#1f2937',
                  marginBottom: '1rem'
                }}>
                  Key Features
                </h3>
                <div style={{
                  display: 'grid',
                  gap: '0.75rem'
                }}>
                  {selectedComponent.details.map((detail, idx) => (
                    <div
                      key={idx}
                      onClick={() => handleConceptClick(detail)}
                      style={{
                        backgroundColor: selectedConcept?.name === detail.name
                          ? 'rgba(249, 115, 22, 0.15)'
                          : 'rgba(249, 115, 22, 0.1)',
                        padding: '0.75rem',
                        borderRadius: '8px',
                        border: selectedConcept?.name === detail.name
                          ? '2px solid rgba(249, 115, 22, 0.4)'
                          : '2px solid rgba(249, 115, 22, 0.2)',
                        fontSize: '0.95rem',
                        fontWeight: '500',
                        color: selectedConcept?.name === detail.name
                          ? '#ea580c'
                          : '#9a3412',
                        cursor: 'pointer',
                        transition: 'all 0.2s ease',
                        transform: 'scale(1)'
                      }}
                      onMouseEnter={(e) => {
                        if (selectedConcept?.name !== detail.name) {
                          e.target.style.backgroundColor = 'rgba(249, 115, 22, 0.15)'
                          e.target.style.transform = 'scale(1.02)'
                          e.target.style.borderColor = 'rgba(249, 115, 22, 0.4)'
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (selectedConcept?.name !== detail.name) {
                          e.target.style.backgroundColor = 'rgba(249, 115, 22, 0.1)'
                          e.target.style.transform = 'scale(1)'
                          e.target.style.borderColor = 'rgba(249, 115, 22, 0.2)'
                        }
                      }}
                    >
                      • {detail.name}
                      {selectedConcept?.name === detail.name && (
                        <span style={{
                          fontSize: '0.8rem',
                          opacity: 0.8,
                          marginLeft: '0.5rem',
                          fontWeight: '600'
                        }}>
                          ← Selected
                        </span>
                      )}
                    </div>
                  ))}
                </div>
              </div>

              {selectedConcept && (
                <div>
                  <h3 style={{
                    fontSize: '1.25rem',
                    fontWeight: '700',
                    color: '#1f2937',
                    marginBottom: '1rem'
                  }}>
                    {selectedConcept.name}
                  </h3>

                  <div style={{
                    backgroundColor: 'rgba(249, 115, 22, 0.05)',
                    padding: '1.5rem',
                    borderRadius: '12px',
                    border: '2px solid rgba(249, 115, 22, 0.2)',
                    marginBottom: '1.5rem'
                  }}>
                    <p style={{
                      fontSize: '1rem',
                      color: '#374151',
                      fontWeight: '500',
                      margin: 0,
                      lineHeight: '1.7',
                      textAlign: 'justify'
                    }}>
                      {selectedConcept.explanation}
                    </p>
                  </div>

                  <div style={{
                    backgroundColor: 'rgba(59, 130, 246, 0.05)',
                    padding: '1.25rem',
                    borderRadius: '12px',
                    border: '2px solid rgba(59, 130, 246, 0.2)'
                  }}>
                    <h4 style={{
                      fontSize: '1rem',
                      fontWeight: '700',
                      color: '#1e40af',
                      margin: '0 0 0.75rem 0'
                    }}>
                      💡 Key Takeaway
                    </h4>
                    <p style={{
                      fontSize: '0.9rem',
                      color: '#1e40af',
                      fontWeight: '500',
                      margin: 0,
                      lineHeight: '1.5',
                      fontStyle: 'italic'
                    }}>
                      {selectedConcept.name} is an essential ORM concept that bridges the object-oriented and relational paradigms, enabling efficient and maintainable data persistence.
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

    </div>
  )
}

export default ORM