import React, { useState, useEffect, useRef } from 'react'
import CompletionCheckbox from '../../components/CompletionCheckbox'
import KeyboardGuide from '../../components/KeyboardGuide'
import DrawingCanvas from '../../components/DrawingCanvas'
import { saveUserCode, getUserCode, isProblemCompleted } from '../../services/progressService'
import { useKeyboardNavigation } from '../../hooks/useKeyboardNavigation'

const GreedyAlgorithms = ({ onBack }) => {
  const [selectedQuestion, setSelectedQuestion] = useState(null)
  const [showDrawing, setShowDrawing] = useState(false)
  const [currentDrawing, setCurrentDrawing] = useState(null)
  const questions = [
    {
      id: 1,
      title: 'Jump Game',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/jump-game/',
      description: 'You are given an integer array nums. You are initially positioned at the array\'s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.',
      explanation: `**Problem Understanding:**
Determine if you can reach the last index by jumping from position to position, where each element indicates the maximum jump length from that position.

**Key Insights:**
1. Greedy approach: Track the farthest position reachable at any point
2. If current position exceeds farthest reachable, we can't proceed
3. Update farthest reachable position as we iterate
4. If farthest reaches or exceeds last index, return true

**Approaches:**

**Approach 1: Greedy - Track Farthest Reachable**
- Time: O(n) - Single pass
- Space: O(1) - Constant space
- Maintain maximum reachable index
- At each position, update max reachable
- Return true if we can reach the end

**Approach 2: Work Backwards**
- Time: O(n) - Single pass
- Space: O(1) - Constant space
- Start from the end and work backwards
- Track the leftmost good position
- Check if we can reach index 0

**Approach 3: Dynamic Programming**
- Time: O(n¬≤) - Check all jumps
- Space: O(n) - DP array
- Less efficient than greedy

**Edge Cases:**
- Single element array (already at end)
- All zeros except first element
- Maximum jump at each position
- Cannot reach end`,
      pseudocode: `ALGORITHM CanJump(nums):
    maxReach = 0

    FOR i = 0 TO length(nums) - 1:
        // If current position is beyond max reachable
        IF i > maxReach:
            RETURN false

        // Update max reachable position
        maxReach = MAX(maxReach, i + nums[i])

        // Early return if we can reach the end
        IF maxReach >= length(nums) - 1:
            RETURN true

    RETURN true

TIME COMPLEXITY: O(n) - Single pass
SPACE COMPLEXITY: O(1) - Constant space`,
      code: {
        java: {
          starterCode: `public boolean canJump(int[] nums) {
    // Write your code here

}`,
          solution: `// Approach 1: Greedy - Track Farthest Reachable - O(n) time, O(1) space
public boolean canJump(int[] nums) {
    int maxReach = 0;

    for (int i = 0; i < nums.length; i++) {
        // If current position is beyond what we can reach
        if (i > maxReach) {
            return false;
        }

        // Update the farthest position we can reach
        maxReach = Math.max(maxReach, i + nums[i]);

        // Early return if we can already reach the end
        if (maxReach >= nums.length - 1) {
            return true;
        }
    }

    return true;
}

// Approach 2: Work Backwards - O(n) time, O(1) space
public boolean canJumpBackwards(int[] nums) {
    int lastGoodIndex = nums.length - 1;

    for (int i = nums.length - 2; i >= 0; i--) {
        // Check if we can reach the last good index from current position
        if (i + nums[i] >= lastGoodIndex) {
            lastGoodIndex = i;
        }
    }

    return lastGoodIndex == 0;
}

// Approach 3: Dynamic Programming - O(n¬≤) time, O(n) space (Not optimal)
public boolean canJumpDP(int[] nums) {
    int n = nums.length;
    boolean[] dp = new boolean[n];
    dp[0] = true;

    for (int i = 0; i < n; i++) {
        if (!dp[i]) continue;

        for (int j = 1; j <= nums[i] && i + j < n; j++) {
            dp[i + j] = true;
        }
    }

    return dp[n - 1];
}`
        },
        python: {
          starterCode: `def canJump(self, nums: List[int]) -> bool:
    # Write your code here
    pass`,
          solution: `# Approach 1: Greedy - Track Farthest Reachable - O(n) time, O(1) space
def canJump(self, nums: List[int]) -> bool:
    max_reach = 0

    for i in range(len(nums)):
        # If current position is beyond what we can reach
        if i > max_reach:
            return False

        # Update the farthest position we can reach
        max_reach = max(max_reach, i + nums[i])

        # Early return if we can already reach the end
        if max_reach >= len(nums) - 1:
            return True

    return True

# Approach 2: Work Backwards - O(n) time, O(1) space
def can_jump_backwards(self, nums: List[int]) -> bool:
    last_good_index = len(nums) - 1

    for i in range(len(nums) - 2, -1, -1):
        # Check if we can reach the last good index from current position
        if i + nums[i] >= last_good_index:
            last_good_index = i

    return last_good_index == 0

# Approach 3: Dynamic Programming - O(n¬≤) time, O(n) space (Not optimal)
def can_jump_dp(self, nums: List[int]) -> bool:
    n = len(nums)
    dp = [False] * n
    dp[0] = True

    for i in range(n):
        if not dp[i]:
            continue

        for j in range(1, nums[i] + 1):
            if i + j < n:
                dp[i + j] = True

    return dp[n - 1]`
        }
      },
      testCases: [
        { nums: [2,3,1,1,4], expected: true },
        { nums: [3,2,1,0,4], expected: false },
        { nums: [0], expected: true },
        { nums: [1,1,1,1], expected: true },
        { nums: [1,0,1,0], expected: false }
      ],
      examples: [
        {
          input: 'nums = [2,3,1,1,4]',
          output: 'true',
          explanation: 'Jump 1 step from index 0 to 1, then 3 steps to the last index.'
        },
        {
          input: 'nums = [3,2,1,0,4]',
          output: 'false',
          explanation: 'You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.'
        }
      ]
    },
    {
      id: 2,
      title: 'Gas Station',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/gas-station/',
      description: 'There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station\'s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.',
      explanation: `**Problem Understanding:**
Find the starting gas station from which you can complete a full circuit around the circular route.

**Key Insights:**
1. If total gas < total cost, impossible to complete circuit
2. If a solution exists, it's guaranteed to be unique
3. Greedy: If we can't reach station j from station i, then we can't reach j from any station between i and j
4. Start from next station after failure point

**Approaches:**

**Approach 1: Greedy Single Pass**
- Time: O(n) - Single pass
- Space: O(1) - Constant space
- Track current tank and total gas/cost
- If tank becomes negative, reset start position
- Check if total gas >= total cost at the end

**Approach 2: Try Each Station**
- Time: O(n¬≤) - Try from each station
- Space: O(1) - Constant space
- Brute force approach
- Not optimal

**Edge Cases:**
- Only one station
- Total gas equals total cost exactly
- Impossible to complete (total gas < total cost)
- Start position is the last station`,
      pseudocode: `ALGORITHM CanCompleteCircuit(gas, cost):
    totalGas = 0
    totalCost = 0
    currentTank = 0
    startStation = 0

    FOR i = 0 TO length(gas) - 1:
        totalGas = totalGas + gas[i]
        totalCost = totalCost + cost[i]
        currentTank = currentTank + gas[i] - cost[i]

        // If we can't reach next station
        IF currentTank < 0:
            startStation = i + 1  // Try starting from next station
            currentTank = 0       // Reset tank

    // If total gas < total cost, impossible
    IF totalGas < totalCost:
        RETURN -1

    RETURN startStation

TIME COMPLEXITY: O(n) - Single pass
SPACE COMPLEXITY: O(1) - Constant space`,
      code: {
        java: {
          starterCode: `public int canCompleteCircuit(int[] gas, int[] cost) {
    // Write your code here

}`,
          solution: `// Approach 1: Greedy Single Pass - O(n) time, O(1) space
public int canCompleteCircuit(int[] gas, int[] cost) {
    int totalGas = 0;
    int totalCost = 0;
    int currentTank = 0;
    int startStation = 0;

    for (int i = 0; i < gas.length; i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        currentTank += gas[i] - cost[i];

        // If we can't reach the next station from current start
        if (currentTank < 0) {
            // Start from the next station
            startStation = i + 1;
            currentTank = 0;
        }
    }

    // If total gas is less than total cost, impossible to complete
    return totalGas < totalCost ? -1 : startStation;
}

// Approach 2: Try Each Station - O(n¬≤) time, O(1) space (Brute Force)
public int canCompleteCircuitBruteForce(int[] gas, int[] cost) {
    int n = gas.length;

    for (int start = 0; start < n; start++) {
        int tank = 0;
        int stationsPassed = 0;

        for (int i = start; stationsPassed < n; i = (i + 1) % n) {
            tank += gas[i] - cost[i];
            if (tank < 0) break;
            stationsPassed++;
        }

        if (stationsPassed == n && tank >= 0) {
            return start;
        }
    }

    return -1;
}

// Approach 3: With Detailed Tracking
public int canCompleteCircuitDetailed(int[] gas, int[] cost) {
    int n = gas.length;
    int totalSurplus = 0;
    int currentSurplus = 0;
    int start = 0;

    for (int i = 0; i < n; i++) {
        int surplus = gas[i] - cost[i];
        totalSurplus += surplus;
        currentSurplus += surplus;

        if (currentSurplus < 0) {
            start = i + 1;
            currentSurplus = 0;
        }
    }

    return totalSurplus >= 0 ? start : -1;
}`
        },
        python: {
          starterCode: `def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
    # Write your code here
    pass`,
          solution: `# Approach 1: Greedy Single Pass - O(n) time, O(1) space
def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
    total_gas = 0
    total_cost = 0
    current_tank = 0
    start_station = 0

    for i in range(len(gas)):
        total_gas += gas[i]
        total_cost += cost[i]
        current_tank += gas[i] - cost[i]

        # If we can't reach the next station from current start
        if current_tank < 0:
            # Start from the next station
            start_station = i + 1
            current_tank = 0

    # If total gas is less than total cost, impossible to complete
    return -1 if total_gas < total_cost else start_station

# Approach 2: Try Each Station - O(n¬≤) time, O(1) space (Brute Force)
def can_complete_circuit_brute_force(self, gas: List[int], cost: List[int]) -> int:
    n = len(gas)

    for start in range(n):
        tank = 0
        stations_passed = 0

        i = start
        while stations_passed < n:
            tank += gas[i] - cost[i]
            if tank < 0:
                break
            stations_passed += 1
            i = (i + 1) % n

        if stations_passed == n and tank >= 0:
            return start

    return -1

# Approach 3: With Detailed Tracking
def can_complete_circuit_detailed(self, gas: List[int], cost: List[int]) -> int:
    total_surplus = 0
    current_surplus = 0
    start = 0

    for i in range(len(gas)):
        surplus = gas[i] - cost[i]
        total_surplus += surplus
        current_surplus += surplus

        if current_surplus < 0:
            start = i + 1
            current_surplus = 0

    return start if total_surplus >= 0 else -1`
        }
      },
      testCases: [
        { gas: [1,2,3,4,5], cost: [3,4,5,1,2], expected: 3 },
        { gas: [2,3,4], cost: [3,4,3], expected: -1 },
        { gas: [5,1,2,3,4], cost: [4,4,1,5,1], expected: 4 },
        { gas: [1,2], cost: [2,1], expected: 1 }
      ],
      examples: [
        {
          input: 'gas = [1,2,3,4,5], cost = [3,4,5,1,2]',
          output: '3',
          explanation: 'Start at station 3 (index 3) and fill up with 4 units. Travel to station 4 (cost 1, tank=3). Fill up with 5 units (tank=8). Travel to station 0 (cost 2, tank=6). Continue until completing the circuit.'
        },
        {
          input: 'gas = [2,3,4], cost = [3,4,3]',
          output: '-1',
          explanation: 'You can\'t start at any station and complete the circuit.'
        }
      ]
    },
    {
      id: 3,
      title: 'Partition Labels',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/partition-labels/',
      description: 'You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.',
      explanation: `**Problem Understanding:**
Partition a string into maximum number of parts where each character appears in at most one part.

**Key Insights:**
1. Track the last occurrence of each character
2. Extend current partition to include last occurrence of all characters seen so far
3. When current index reaches the end of current partition, create a new partition
4. Greedy approach: Maximize number of partitions

**Approaches:**

**Approach 1: Greedy with Last Occurrence**
- Time: O(n) - Two passes (one to find last occurrence, one to partition)
- Space: O(1) - Only 26 letters, constant space
- Store last index of each character
- Extend partition to include all characters' last occurrences
- Create new partition when current index equals partition end

**Approach 2: Interval Merging**
- Time: O(n) - Similar to approach 1
- Space: O(1) - Constant space for 26 letters
- Treat each character's first and last occurrence as an interval
- Merge overlapping intervals

**Edge Cases:**
- All same character
- All different characters
- Single character string
- Characters appearing multiple times`,
      pseudocode: `ALGORITHM PartitionLabels(s):
    // Store last occurrence of each character
    lastOccurrence = MAP()
    FOR i = 0 TO length(s) - 1:
        lastOccurrence[s[i]] = i

    partitions = []
    start = 0
    end = 0

    FOR i = 0 TO length(s) - 1:
        // Extend partition to include last occurrence of current char
        end = MAX(end, lastOccurrence[s[i]])

        // If we've reached the end of current partition
        IF i == end:
            partitions.ADD(end - start + 1)
            start = i + 1

    RETURN partitions

TIME COMPLEXITY: O(n) - Two passes through string
SPACE COMPLEXITY: O(1) - Only 26 letters, constant space`,
      code: {
        java: {
          starterCode: `public List<Integer> partitionLabels(String s) {
    // Write your code here

}`,
          solution: `// Approach 1: Greedy with Last Occurrence - O(n) time, O(1) space
public List<Integer> partitionLabels(String s) {
    // Store last occurrence of each character
    int[] lastOccurrence = new int[26];
    for (int i = 0; i < s.length(); i++) {
        lastOccurrence[s.charAt(i) - 'a'] = i;
    }

    List<Integer> partitions = new ArrayList<>();
    int start = 0;
    int end = 0;

    for (int i = 0; i < s.length(); i++) {
        // Extend partition to include last occurrence of current character
        end = Math.max(end, lastOccurrence[s.charAt(i) - 'a']);

        // If we've reached the end of the current partition
        if (i == end) {
            partitions.add(end - start + 1);
            start = i + 1;
        }
    }

    return partitions;
}

// Approach 2: Using HashMap (More readable) - O(n) time, O(1) space
public List<Integer> partitionLabelsHashMap(String s) {
    Map<Character, Integer> lastIndex = new HashMap<>();

    // Record last occurrence of each character
    for (int i = 0; i < s.length(); i++) {
        lastIndex.put(s.charAt(i), i);
    }

    List<Integer> result = new ArrayList<>();
    int partitionStart = 0;
    int partitionEnd = 0;

    for (int i = 0; i < s.length(); i++) {
        partitionEnd = Math.max(partitionEnd, lastIndex.get(s.charAt(i)));

        if (i == partitionEnd) {
            result.add(partitionEnd - partitionStart + 1);
            partitionStart = i + 1;
        }
    }

    return result;
}

// Approach 3: With Detailed Comments
public List<Integer> partitionLabelsDetailed(String s) {
    int[] last = new int[26];
    int n = s.length();

    // Find the last occurrence of each character
    for (int i = 0; i < n; i++) {
        last[s.charAt(i) - 'a'] = i;
    }

    List<Integer> partitions = new ArrayList<>();
    int anchor = 0;  // Start of current partition
    int maxReach = 0;  // Farthest we need to go for current partition

    for (int i = 0; i < n; i++) {
        maxReach = Math.max(maxReach, last[s.charAt(i) - 'a']);

        // Current position reached the max, create partition
        if (i == maxReach) {
            partitions.add(i - anchor + 1);
            anchor = i + 1;
        }
    }

    return partitions;
}`
        },
        python: {
          starterCode: `def partitionLabels(self, s: str) -> List[int]:
    # Write your code here
    pass`,
          solution: `# Approach 1: Greedy with Last Occurrence - O(n) time, O(1) space
def partitionLabels(self, s: str) -> List[int]:
    # Store last occurrence of each character
    last_occurrence = {char: i for i, char in enumerate(s)}

    partitions = []
    start = 0
    end = 0

    for i, char in enumerate(s):
        # Extend partition to include last occurrence of current character
        end = max(end, last_occurrence[char])

        # If we've reached the end of the current partition
        if i == end:
            partitions.append(end - start + 1)
            start = i + 1

    return partitions

# Approach 2: Using Array for Last Index - O(n) time, O(1) space
def partition_labels_array(self, s: str) -> List[int]:
    last = [0] * 26

    # Record last occurrence of each character
    for i, char in enumerate(s):
        last[ord(char) - ord('a')] = i

    partitions = []
    anchor = 0
    max_reach = 0

    for i, char in enumerate(s):
        max_reach = max(max_reach, last[ord(char) - ord('a')])

        if i == max_reach:
            partitions.append(i - anchor + 1)
            anchor = i + 1

    return partitions

# Approach 3: One-liner style (less readable)
def partition_labels_compact(self, s: str) -> List[int]:
    last = {c: i for i, c in enumerate(s)}
    anchor = end = 0
    result = []

    for i, c in enumerate(s):
        end = max(end, last[c])
        if i == end:
            result.append(i - anchor + 1)
            anchor = i + 1

    return result`
        }
      },
      testCases: [
        { s: "ababcbacadefegdehijhklij", expected: [9,7,8] },
        { s: "eccbbbbdec", expected: [10] },
        { s: "abcdef", expected: [1,1,1,1,1,1] },
        { s: "aaaa", expected: [4] }
      ],
      examples: [
        {
          input: 's = "ababcbacadefegdehijhklij"',
          output: '[9, 7, 8]',
          explanation: 'The partition is "ababcbaca", "defegde", "hijhklij". Each letter appears in at most one part.'
        },
        {
          input: 's = "eccbbbbdec"',
          output: '[10]',
          explanation: 'The entire string must be in one partition since all characters appear throughout.'
        }
      ]
    },
    {
      id: 4,
      title: 'Minimum Number of Arrows to Burst Balloons',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/',
      description: 'There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons.',
      explanation: `**Problem Understanding:**
Find the minimum number of arrows needed to burst all balloons, where each balloon is represented as an interval [start, end].

**Key Insights:**
1. This is an interval scheduling problem
2. Sort balloons by end position
3. Shoot arrow at the end of first balloon in group
4. Greedy: Always shoot arrow at earliest possible end position
5. Count how many groups of overlapping balloons exist

**Approaches:**

**Approach 1: Greedy - Sort by End Position**
- Time: O(n log n) - Sorting
- Space: O(1) - Constant space (excluding sort)
- Sort intervals by end position
- Shoot arrow at end of first balloon
- Skip balloons that overlap with current arrow position
- Increment arrow count when finding non-overlapping balloon

**Approach 2: Interval Merging**
- Time: O(n log n) - Sorting
- Space: O(n) - Store merged intervals
- Merge overlapping intervals
- Count number of merged intervals

**Edge Cases:**
- No balloons
- Single balloon
- All balloons overlap
- No overlapping balloons
- Balloons with same start/end`,
      pseudocode: `ALGORITHM FindMinArrows(points):
    IF points is empty:
        RETURN 0

    // Sort balloons by end position
    SORT points BY end position

    arrows = 1
    currentArrowPos = points[0][1]  // End of first balloon

    FOR i = 1 TO length(points) - 1:
        // If current balloon starts after arrow position
        IF points[i][0] > currentArrowPos:
            arrows = arrows + 1
            currentArrowPos = points[i][1]  // Shoot new arrow at end

    RETURN arrows

TIME COMPLEXITY: O(n log n) - Sorting dominates
SPACE COMPLEXITY: O(1) - Constant space`,
      code: {
        java: {
          starterCode: `public int findMinArrowShots(int[][] points) {
    // Write your code here

}`,
          solution: `// Approach 1: Greedy - Sort by End Position - O(n log n) time, O(1) space
public int findMinArrowShots(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }

    // Sort by end position (use Integer.compare to avoid overflow)
    Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

    int arrows = 1;
    int currentArrowPos = points[0][1];

    for (int i = 1; i < points.length; i++) {
        // If current balloon starts after the arrow position
        if (points[i][0] > currentArrowPos) {
            arrows++;
            currentArrowPos = points[i][1];  // Shoot new arrow at this end
        }
    }

    return arrows;
}

// Approach 2: Track Overlap Range - O(n log n) time, O(1) space
public int findMinArrowShotsOverlap(int[][] points) {
    if (points.length == 0) return 0;

    Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

    int arrows = 1;
    int end = points[0][1];

    for (int i = 1; i < points.length; i++) {
        // No overlap with current arrow
        if (points[i][0] > end) {
            arrows++;
            end = points[i][1];
        }
        // Overlap - arrow can burst this balloon too
        // end remains the same (or could update to min(end, points[i][1]))
    }

    return arrows;
}

// Approach 3: With Detailed Comments
public int findMinArrowShotsDetailed(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }

    // Sort balloons by their end position
    // This greedy choice ensures we shoot as late as possible
    // to potentially cover more balloons
    Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

    int arrowCount = 1;
    int arrowPosition = points[0][1];

    for (int i = 1; i < points.length; i++) {
        // If the current balloon starts after our arrow position,
        // we need a new arrow
        if (points[i][0] > arrowPosition) {
            arrowCount++;
            arrowPosition = points[i][1];
        }
        // Otherwise, the current arrow can burst this balloon too
    }

    return arrowCount;
}`
        },
        python: {
          starterCode: `def findMinArrowShots(self, points: List[List[int]]) -> int:
    # Write your code here
    pass`,
          solution: `# Approach 1: Greedy - Sort by End Position - O(n log n) time, O(1) space
def findMinArrowShots(self, points: List[List[int]]) -> int:
    if not points:
        return 0

    # Sort by end position
    points.sort(key=lambda x: x[1])

    arrows = 1
    current_arrow_pos = points[0][1]

    for i in range(1, len(points)):
        # If current balloon starts after the arrow position
        if points[i][0] > current_arrow_pos:
            arrows += 1
            current_arrow_pos = points[i][1]

    return arrows

# Approach 2: Track Overlap Range - O(n log n) time, O(1) space
def find_min_arrow_shots_overlap(self, points: List[List[int]]) -> int:
    if not points:
        return 0

    points.sort(key=lambda x: x[1])

    arrows = 1
    end = points[0][1]

    for start, balloon_end in points[1:]:
        # No overlap with current arrow
        if start > end:
            arrows += 1
            end = balloon_end

    return arrows

# Approach 3: More Pythonic
def find_min_arrow_shots_pythonic(self, points: List[List[int]]) -> int:
    if not points:
        return 0

    # Sort by end position
    points.sort(key=lambda x: x[1])

    arrows, end = 1, points[0][1]

    for start, balloon_end in points:
        if start > end:
            arrows += 1
            end = balloon_end

    return arrows`
        }
      },
      testCases: [
        { points: [[10,16],[2,8],[1,6],[7,12]], expected: 2 },
        { points: [[1,2],[3,4],[5,6],[7,8]], expected: 4 },
        { points: [[1,2],[2,3],[3,4],[4,5]], expected: 2 },
        { points: [[1,2]], expected: 1 },
        { points: [[-2147483646,-2147483645],[2147483646,2147483647]], expected: 2 }
      ],
      examples: [
        {
          input: 'points = [[10,16],[2,8],[1,6],[7,12]]',
          output: '2',
          explanation: 'The balloons can be burst by 2 arrows: Shoot an arrow at x = 6, bursting [2,8] and [1,6]. Shoot an arrow at x = 11, bursting [10,16] and [7,12].'
        },
        {
          input: 'points = [[1,2],[3,4],[5,6],[7,8]]',
          output: '4',
          explanation: 'One arrow needs to be shot for each balloon for a total of 4 arrows.'
        }
      ]
    }
  ]

  const [code, setCode] = useState({})
  const [output, setOutput] = useState('')
  const [isRunning, setIsRunning] = useState(false)
  const [selectedLanguage, setSelectedLanguage] = useState('java')
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)
  const saveTimeoutRef = useRef(null)

  // Handle question selection
  const handleQuestionSelect = (question) => {
    setSelectedQuestion(question)
    setOutput('')
    // Load existing drawing if any
    const problemId = `GreedyAlgorithms-${question.id}`
    const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
    setCurrentDrawing(savedDrawing)
    // Load saved code or starter code for the selected question
    const problemId2 = `Greedy Algorithms-${question.id}`
    const savedCode = getUserCode(problemId, selectedLanguage)
    if (savedCode) {
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: savedCode
      }))
    } else {
      const starterCode = question.code[selectedLanguage].starterCode
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: starterCode
      }))
    }
    setHasUnsavedChanges(false)
  }

  const openDrawingModal = () => {
    if (selectedQuestion) {
      const problemId = `GreedyAlgorithms-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
      setShowDrawing(true)
    }
  }

  const closeDrawingModal = () => {
    setShowDrawing(false)
    // Reload drawing after saving
    if (selectedQuestion) {
      const problemId = `GreedyAlgorithms-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
    }
  }

  // Load saved code when language changes
  useEffect(() => {
    if (!selectedQuestion) return
    const problemId = `Greedy Algorithms-${selectedQuestion.id}`
    const savedCode = getUserCode(problemId, selectedLanguage)

    if (savedCode) {
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: savedCode
      }))
    } else {
      // Load starter code if no saved code
      const starterCode = selectedQuestion.code[selectedLanguage].starterCode
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: starterCode
      }))
    }
    setHasUnsavedChanges(false)
  }, [selectedLanguage, selectedQuestion])

  // Auto-save with debouncing
  useEffect(() => {
    if (!selectedQuestion) return
    if (hasUnsavedChanges && code[selectedLanguage]) {
      // Clear existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }

      // Set new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        const problemId = `Greedy Algorithms-${selectedQuestion.id}`
        saveUserCode(problemId, code[selectedLanguage], selectedLanguage)
        setHasUnsavedChanges(false)
      }, 1000) // Save after 1 second of inactivity
    }

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }
    }
  }, [code, selectedLanguage, hasUnsavedChanges, selectedQuestion])

  // Save on unmount
  useEffect(() => {
    return () => {
      if (selectedQuestion && code[selectedLanguage]) {
        const problemId = `Greedy Algorithms-${selectedQuestion.id}`
        saveUserCode(problemId, code[selectedLanguage], selectedLanguage)
      }
    }
  }, [code, selectedLanguage, selectedQuestion])

  const handleCodeChange = (e) => {
    setCode(prev => ({
      ...prev,
      [selectedLanguage]: e.target.value
    }))
    setHasUnsavedChanges(true)
  }

  const handleLanguageToggle = () => {
    setSelectedLanguage(prev => prev === 'java' ? 'python' : 'java')
  }

  const runCode = () => {
    if (!selectedQuestion) return
    setIsRunning(true)
    setOutput('Running test cases...\n\n')

    setTimeout(() => {
      const currentQuestion = selectedQuestion
      const userCode = code[selectedLanguage] || ''

      // Simple validation
      if (!userCode.trim()) {
        setOutput('Error: Please write some code first!')
        setIsRunning(false)
        return
      }

      // Check for basic syntax (very basic check)
      if (selectedLanguage === 'java') {
        if (!userCode.includes('return') && !userCode.includes('System.out')) {
          setOutput('Warning: Your code might be missing a return statement.\n\nPlease implement the solution.')
          setIsRunning(false)
          return
        }
      } else {
        if (!userCode.includes('return') && !userCode.includes('print')) {
          setOutput('Warning: Your code might be missing a return statement.\n\nPlease implement the solution.')
          setIsRunning(false)
          return
        }
      }

      let results = 'Test Results:\n\n'
      let passed = 0

      currentQuestion.testCases.forEach((testCase, index) => {
        results += `Test Case ${index + 1}: ‚úì PASS\n`
        results += `Input: ${JSON.stringify(testCase).substring(0, 100)}...\n`
        results += `Expected: ${JSON.stringify(testCase.expected)}\n\n`
        passed++
      })

      results += `\n${passed}/${currentQuestion.testCases.length} test cases passed!\n`
      results += '\nNote: This is a simulated test environment. Submit to LeetCode for actual validation.'

      setOutput(results)
      setIsRunning(false)
    }, 1500)
  }

  const showSolution = () => {
    if (!selectedQuestion) return
    const solution = selectedQuestion.code[selectedLanguage].solution
    setCode(prev => ({
      ...prev,
      [selectedLanguage]: solution
    }))
    setHasUnsavedChanges(true)
    setOutput('Solution loaded! Read through the code and comments to understand the approach.')
  }

  const resetCode = () => {
    if (!selectedQuestion) return
    const starterCode = selectedQuestion.code[selectedLanguage].starterCode
    setCode(prev => ({
      ...prev,
      [selectedLanguage]: starterCode
    }))
    setHasUnsavedChanges(true)
    setOutput('')
  }

  const goToPreviousProblem = () => {
    if (!selectedQuestion) return
    const currentIndex = questions.findIndex(q => q.id === selectedQuestion.id)
    if (currentIndex > 0) {
      handleQuestionSelect(questions[currentIndex - 1])
    }
  }

  const goToNextProblem = () => {
    if (!selectedQuestion) return
    const currentIndex = questions.findIndex(q => q.id === selectedQuestion.id)
    if (currentIndex < questions.length - 1) {
      handleQuestionSelect(questions[currentIndex + 1])
    }
  }

  // QuestionCard component for the list view
  const QuestionCard = ({ question }) => {
    const problemId = `Greedy Algorithms-${question.id}`
    const isCompleted = isProblemCompleted(problemId)

    return (
      <div
        onClick={() => handleQuestionSelect(question)}
        className="bg-white rounded-xl shadow-lg p-6 mb-4 cursor-pointer hover:shadow-xl transition-all hover:-translate-y-1"
        style={{
          border: isCompleted ? '3px solid #10b981' : '2px solid #e5e7eb'
        }}
      >
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-xl font-bold text-gray-900">
            {isCompleted && <span className="text-green-600 mr-2">‚úì</span>}
            {question.id}. {question.title}
          </h3>
          <div className="flex items-center gap-3">
            <a
              href={question.leetcodeUrl}
              target="_blank"
              rel="noopener noreferrer"
              onClick={(e) => e.stopPropagation()}
              className="px-3 py-1 text-sm font-medium text-blue-600 bg-blue-50 border border-blue-600 rounded-lg hover:bg-blue-600 hover:text-white transition-colors"
            >
              LeetCode ‚Üí
            </a>
            <span className={`px-3 py-1 rounded-full text-sm font-medium ${
              question.difficulty === 'Easy' ? 'bg-green-100 text-green-800' :
              question.difficulty === 'Medium' ? 'bg-yellow-100 text-yellow-800' :
              'bg-red-100 text-red-800'
            }`}>
              {question.difficulty}
            </span>
          </div>
        </div>
        <p className="text-gray-600 text-sm line-clamp-2">
          {question.description}
        </p>
      </div>
    )
  }

  const currentCode = selectedQuestion ? (code[selectedLanguage] || selectedQuestion.code[selectedLanguage].starterCode) : ''

  return (
    <div className="min-h-screen bg-gradient-to-br from-green-50 to-emerald-100 p-8">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-xl shadow-lg p-6 mb-8">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h1 className="text-4xl font-bold text-gray-900 mb-2">üéØ Greedy Algorithms</h1>
              <p className="text-gray-600">Master greedy algorithm techniques and optimal choice strategies</p>
            </div>
            {selectedQuestion && (
              <CompletionCheckbox
                problemId={`Greedy Algorithms-${selectedQuestion.id}`}
                title={selectedQuestion.title}
              />
            )}
          </div>

          {/* Back button - always visible */}
          <div className="flex items-center gap-3">
            <button
              onClick={onBack}
              className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-semibold"
            >
              ‚Üê Back to Practice
            </button>
            {selectedQuestion && (
              <button
                onClick={() => setSelectedQuestion(null)}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
              >
                ‚Üê Back to Problem List
              </button>
            )}
          </div>
        </div>

        {/* Problem List View */}
        {!selectedQuestion && (
          <div>
            <h2 className="text-2xl font-bold text-gray-900 mb-6">
              Select a Problem ({questions.length} problems)
            </h2>
            <div className="space-y-4">
              {questions.map(question => (
                <QuestionCard key={question.id} question={question} />
              ))}
            </div>
          </div>
        )}

        {/* Problem Details - Only show when a question is selected */}
        {selectedQuestion && (
          <>
            {/* Navigation within problem view */}
            <div className="flex items-center justify-center gap-4 mb-6">
              <button
                onClick={goToPreviousProblem}
                disabled={questions.findIndex(q => q.id === selectedQuestion.id) === 0}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                ‚Üê Previous
              </button>
              <span className="text-sm font-medium text-gray-600">
                Problem {selectedQuestion.id} of {questions.length}
              </span>
              <button
                onClick={goToNextProblem}
                disabled={questions.findIndex(q => q.id === selectedQuestion.id) === questions.length - 1}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                Next ‚Üí
              </button>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
              {/* Left Column - Problem Description */}
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-2xl font-bold text-gray-900">{selectedQuestion.title}</h2>
                  <span className={`px-3 py-1 rounded-full text-sm font-medium ${
                    selectedQuestion.difficulty === 'Easy' ? 'bg-green-100 text-green-800' :
                    selectedQuestion.difficulty === 'Medium' ? 'bg-yellow-100 text-yellow-800' :
                    'bg-red-100 text-red-800'
                  }`}>
                    {selectedQuestion.difficulty}
                  </span>
                </div>

                <a
                  href={selectedQuestion.leetcodeUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="inline-flex items-center text-blue-600 hover:text-blue-800 mb-4"
                >
                  View on LeetCode ‚Üí
                </a>

                <div className="prose max-w-none">
                  <h3 className="text-lg font-semibold text-gray-900 mb-2">Problem Description</h3>
                  <p className="text-gray-700 mb-4">{selectedQuestion.description}</p>

                  <h3 className="text-lg font-semibold text-gray-900 mb-2">Examples</h3>
                  {selectedQuestion.examples.map((example, index) => (
                    <div key={index} className="bg-gray-50 rounded-lg p-4 mb-3">
                      <p className="font-mono text-sm mb-1"><strong>Input:</strong> {example.input}</p>
                      <p className="font-mono text-sm mb-1"><strong>Output:</strong> {example.output}</p>
                      <p className="text-sm text-gray-600"><strong>Explanation:</strong> {example.explanation}</p>
                    </div>
                  ))}

                  <h3 className="text-lg font-semibold text-gray-900 mb-2 mt-6">Explanation</h3>
                  <div className="bg-green-50 rounded-lg p-4 whitespace-pre-line text-sm">
                    {selectedQuestion.explanation}
                  </div>

                  <h3 className="text-lg font-semibold text-gray-900 mb-2 mt-6">Pseudocode</h3>
                  <pre className="bg-gray-900 text-gray-100 rounded-lg p-4 overflow-x-auto text-sm">
                    {selectedQuestion.pseudocode}
                  </pre>
                </div>
              </div>

          {/* Right Column - Code Editor */}
          <div className="bg-white rounded-xl shadow-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold text-gray-900">Code Editor</h3>
              <div className="flex items-center gap-2">
                <button
                  onClick={handleLanguageToggle}
                  className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-medium"
                >
                  {selectedLanguage === 'java' ? '‚òï Java' : 'üêç Python'}
                </button>
                {hasUnsavedChanges && (
                  <span className="text-sm text-orange-600">‚óè Unsaved</span>
                )}
              </div>
            </div>

            <textarea
              value={currentCode}
              onChange={handleCodeChange}
              className="w-full h-96 p-4 font-mono text-sm bg-gray-900 text-gray-100 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none resize-none"
              spellCheck="false"
              placeholder="Write your code here..."
            />

            <div className="flex gap-3 mt-4">
              <button
                onClick={runCode}
                disabled={isRunning}
                className="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 transition-colors font-medium"
              >
                {isRunning ? 'Running...' : '‚ñ∂ Run Code'}
              </button>
              <button
                onClick={showSolution}
                className="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors font-medium"
              >
                üí° Solution
              </button>
              <button
                onClick={resetCode}
                className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium"
              >
                ‚Ü∫ Reset
              </button>
              <button
                onClick={openDrawingModal}
                className={`px-4 py-2 text-white rounded-lg transition-colors font-medium ${
                  currentDrawing ? 'bg-purple-600 hover:bg-purple-700' : 'bg-indigo-600 hover:bg-indigo-700'
                }`}
              >
                {currentDrawing ? '‚úèÔ∏è Edit Drawing' : 'üé® Draw'}
              </button>
            </div>

            {/* Drawing Preview Section */}
            {currentDrawing && (
              <div className="mt-4">
                <div className="flex justify-between items-center mb-2">
                  <h4 className="text-sm font-semibold text-gray-900">üé® Your Drawing</h4>
                  <button
                    onClick={openDrawingModal}
                    className="px-3 py-1 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700 transition-colors"
                  >
                    ‚úèÔ∏è Edit
                  </button>
                </div>
                <div className="bg-gray-50 p-4 rounded-lg border-2 border-gray-200 text-center">
                  <img
                    src={currentDrawing}
                    alt="Your drawing"
                    className="max-w-full h-auto rounded"
                  />
                </div>
              </div>
            )}

            {/* Output Panel */}
            {output && (
              <div className="mt-4">
                <h4 className="text-sm font-semibold text-gray-900 mb-2">Output:</h4>
                <pre className="bg-gray-900 text-gray-100 rounded-lg p-4 overflow-x-auto text-sm whitespace-pre-wrap">
                  {output}
                </pre>
              </div>
            )}
          </div>
        </div>

        <KeyboardGuide />
      </>
    )}

      {/* Drawing Canvas Modal */}
      <DrawingCanvas
        isOpen={showDrawing}
        onClose={closeDrawingModal}
        problemId={selectedQuestion ? `GreedyAlgorithms-${selectedQuestion.id}` : ''}
        existingDrawing={currentDrawing}
      />
      </div>
    </div>
  )
}

export default GreedyAlgorithms
