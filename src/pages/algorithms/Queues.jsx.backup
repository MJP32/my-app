import { useState, useEffect } from 'react'
import CompletionCheckbox from '../../components/CompletionCheckbox.jsx'
import LanguageToggle from "../../components/LanguageToggle.jsx"
import DrawingCanvas from '../../components/DrawingCanvas.jsx'
import { isProblemCompleted } from '../../services/progressService'
import { getPreferredLanguage } from "../../services/languageService"
import { useKeyboardNavigation } from '../../hooks/useKeyboardNavigation'

function Queues({ onBack, onPrevious, onNext, previousName, nextName, currentSubcategory, previousSubcategory, nextSubcategory, onPreviousSubcategory, onNextSubcategory }) {
  const [selectedQuestion, setSelectedQuestion] = useState(null)
  const [showSolution, setShowSolution] = useState(false)
  const [showExplanation, setShowExplanation] = useState(false)
  const [language, setLanguage] = useState(getPreferredLanguage())
  const [showDrawing, setShowDrawing] = useState(false)
  const [currentDrawing, setCurrentDrawing] = useState(null)
  const [expandedSections, setExpandedSections] = useState({
    Easy: true,
    Medium: true,
    Hard: true
  })
  const [userCode, setUserCode] = useState('')
  const [output, setOutput] = useState('')
  const [isRunning, setIsRunning] = useState(false)
  const [refreshKey, setRefreshKey] = useState(0)

  useEffect(() => {
    const handleProgressUpdate = () => setRefreshKey(prev => prev + 1)
    window.addEventListener('progressUpdate', handleProgressUpdate)
    return () => window.removeEventListener('progressUpdate', handleProgressUpdate)
  }, [])

  // Listen for language changes
  useEffect(() => {
    const handleLanguageChange = (e) => {
      setLanguage(e.detail)
    }
    window.addEventListener("languageChange", handleLanguageChange)
    return () => window.removeEventListener("languageChange", handleLanguageChange)
  }, [])

  const questions = [
    {
      id: 1,
      title: 'Implement Queue using Stacks',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/implement-queue-using-stacks/',
      description: 'Implement a queue data structure using two stacks. Support push (enqueue), pop (dequeue), peek, and empty operations. Ensure FIFO behavior using LIFO stacks.',
      explanation: `**Problem:** Implement a FIFO (First-In-First-Out) queue using only LIFO (Last-In-First-Out) stacks.

**Challenge:** How do we convert LIFO behavior into FIFO behavior?

**Key Data Structures:**
- Queue: FIFO ‚Üí elements removed in order they were added [1,2,3] ‚Üí remove 1 first
- Stack: LIFO ‚Üí elements removed in reverse order [1,2,3] ‚Üí remove 3 first

**Core Insight: Two-Stack Technique**
Use TWO stacks to reverse the reversal!
- **input stack**: receives all new elements (push operations)
- **output stack**: provides elements for removal (pop/peek operations)

**Why This Works:**
When we transfer elements from input to output stack, they get reversed twice ‚Üí back to original order!

**Example:**
Push 1, 2, 3:
  input: [1, 2, 3]  (top at 3)
  output: []

Transfer to output (for pop/peek):
  Pop from input, push to output:
    3 ‚Üí output: [3]
    2 ‚Üí output: [3, 2]
    1 ‚Üí output: [3, 2, 1]  (top at 1)
  input: []
  output: [1, 2, 3]  (top at 1) ‚Üê Now FIFO order!

Pop():
  output.pop() ‚Üí returns 1 ‚úì (correct FIFO behavior)

**Algorithm:**

**push(x)** - O(1):
- Simply push to input stack
- No need to touch output stack

**pop()** - Amortized O(1):
- If output stack is empty:
  - Transfer ALL elements from input to output
  - This reverses the order ‚Üí FIFO
- Pop from output stack

**peek()** - Amortized O(1):
- Same as pop(), but use peek() instead
- If output empty, transfer from input
- Return output.peek()

**empty()** - O(1):
- Queue is empty when BOTH stacks are empty

**Complexity Analysis:**

Time Complexity:
- push(): O(1) - always just one push operation
- pop()/peek(): **Amortized O(1)**
  - Worst case: O(n) when transferring n elements
  - But each element transferred only once in its lifetime
  - Total: n operations over n elements ‚Üí O(1) amortized
- empty(): O(1)

Space: O(n) - store n elements across two stacks

**Why Amortized O(1)?**
Example: push 1, 2, 3, pop, pop, pop
- push(1): O(1)
- push(2): O(1)
- push(3): O(1)
- pop(): O(3) - transfer all 3 elements, then pop
- pop(): O(1) - output stack already has elements
- pop(): O(1) - output stack already has elements
Total: 3 + 3 + 1 + 1 = 8 operations for 6 calls ‚Üí constant per operation

**Follow-up: Single Stack Solution**
Use recursion to simulate second stack (trades space for stack frames):
- More elegant but less efficient: O(n) per pop/peek
- Not recommended for production

**Alternative Approaches:**
1. Single stack + recursion: O(n) per pop, cleaner code
2. Array with two pointers: simpler but requires fixed size`,
      pseudocode: `Data Structure:
-----------------------
class MyQueue:
    input: Stack (for push operations)
    output: Stack (for pop/peek operations)

Initialize:
-----------------------
MyQueue():
    input = new Stack()
    output = new Stack()

Push Operation - O(1):
-----------------------
push(x):
    input.push(x)  // Always push to input stack

Pop Operation - Amortized O(1):
-----------------------
pop():
    peek()  // Ensure output has elements
    return output.pop()

Peek Operation - Amortized O(1):
-----------------------
peek():
    if output.isEmpty():
        // Transfer all elements from input to output
        while not input.isEmpty():
            output.push(input.pop())
    return output.peek()

Empty Check - O(1):
-----------------------
empty():
    return input.isEmpty() AND output.isEmpty()

Example Walkthrough:
-----------------------
Initial: input=[], output=[]

push(1):
  input.push(1)
  State: input=[1], output=[]

push(2):
  input.push(2)
  State: input=[1,2], output=[]

push(3):
  input.push(3)
  State: input=[1,2,3], output=[]

peek():
  output is empty, so transfer:
    input.pop() ‚Üí 3, output.push(3) ‚Üí output=[3]
    input.pop() ‚Üí 2, output.push(2) ‚Üí output=[3,2]
    input.pop() ‚Üí 1, output.push(1) ‚Üí output=[3,2,1]
  State: input=[], output=[3,2,1]
  Return output.peek() ‚Üí 1

pop():
  output not empty
  Return output.pop() ‚Üí 1
  State: input=[], output=[3,2]

push(4):
  input.push(4)
  State: input=[4], output=[3,2]

pop():
  output not empty
  Return output.pop() ‚Üí 2
  State: input=[4], output=[3]

pop():
  output not empty
  Return output.pop() ‚Üí 3
  State: input=[4], output=[]

pop():
  output is empty, so transfer:
    input.pop() ‚Üí 4, output.push(4) ‚Üí output=[4]
  State: input=[], output=[]
  Return output.pop() ‚Üí 4

empty():
  input.isEmpty() AND output.isEmpty() ‚Üí true

Visual Representation:
-----------------------
Queue operations: push(1), push(2), push(3), pop()

Step 1: push(1,2,3)
  input: [1 2 3]    output: []
         ‚Üë top

Step 2: pop() needs transfer
  Transfer:
    input: []         output: [3 2 1]
                              ‚Üë top

Step 3: pop()
  Return 1 (FIFO order!) ‚úì
  input: []         output: [3 2]
                            ‚Üë top`,
      example: `Operations:
push(1) ‚Üí queue: [1]
push(2) ‚Üí queue: [1,2]
peek() ‚Üí returns 1
pop() ‚Üí returns 1, queue: [2]
empty() ‚Üí returns false
pop() ‚Üí returns 2, queue: []
empty() ‚Üí returns true`,
      starterCode: `class MyQueue {
    private Stack<Integer> input;
    private Stack<Integer> output;

    public MyQueue() {
        input = new Stack<>();
        output = new Stack<>();
    }

    // Push element to back of queue
    public void push(int x) {
        // TODO: Add element to queue

    }

    // Remove element from front of queue
    public int pop() {
        // TODO: Remove and return front element

        return -1;
    }

    // Get front element
    public int peek() {
        // TODO: Return front element without removing

        return -1;
    }

    // Check if queue is empty
    public boolean empty() {
        // TODO: Check if both stacks are empty

        return false;
    }
}`,
      solution: `class MyQueue {
    private Stack<Integer> input;
    private Stack<Integer> output;

    public MyQueue() {
        input = new Stack<>();
        output = new Stack<>();
    }

    // Push element to back of queue - O(1)
    public void push(int x) {
        input.push(x);
    }

    // Remove element from front of queue - Amortized O(1)
    public int pop() {
        peek(); // Ensure output stack has elements
        return output.pop();
    }

    // Get front element - Amortized O(1)
    public int peek() {
        if (output.isEmpty()) {
            // Transfer all elements from input to output
            while (!input.isEmpty()) {
                output.push(input.pop());
            }
        }
        return output.peek();
    }

    // Check if queue is empty - O(1)
    public boolean empty() {
        return input.isEmpty() && output.isEmpty();
    }

    // Get size
    public int size() {
        return input.size() + output.size();
    }
}

// Alternative: Single stack with recursion
class MyQueueRecursive {
    private Stack<Integer> stack;

    public MyQueueRecursive() {
        stack = new Stack<>();
    }

    public void push(int x) {
        stack.push(x);
    }

    public int pop() {
        if (stack.size() == 1) {
            return stack.pop();
        }

        int temp = stack.pop();
        int result = pop();
        stack.push(temp);
        return result;
    }

    public int peek() {
        if (stack.size() == 1) {
            return stack.peek();
        }

        int temp = stack.pop();
        int result = peek();
        stack.push(temp);
        return result;
    }

    public boolean empty() {
        return stack.isEmpty();
    }
}

// Implement Stack using Queues (reverse problem)
class MyStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;

    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }

    // Push element to top - O(n)
    public void push(int x) {
        queue2.offer(x);

        // Move all elements from queue1 to queue2
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }

        // Swap queues
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }

    // Pop element from top - O(1)
    public int pop() {
        return queue1.poll();
    }

    // Get top element - O(1)
    public int top() {
        return queue1.peek();
    }

    // Check if empty - O(1)
    public boolean empty() {
        return queue1.isEmpty();
    }
}`,
      testCases: [
        { input: 'push(1), push(2), peek(), pop()', output: 'peek: 1, pop: 1' },
        { input: 'push(1), pop(), empty()', output: 'pop: 1, empty: true' },
        { input: 'push(1), push(2), push(3), pop(), pop()', output: 'pop: 1, pop: 2' }
      ]
    },
    {
      id: 2,
      title: 'Circular Queue',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/design-circular-queue/',
      description: 'Design a circular queue (ring buffer) with a fixed size. Support enQueue, deQueue, Front, Rear, isEmpty, and isFull operations. Use an array with front and rear pointers.',
      explanation: `**Problem:** Implement a fixed-size circular queue (also called ring buffer) with efficient O(1) operations.

**Why Circular Queue?**
- Efficient memory utilization: reuse array space after dequeue
- O(1) operations without shifting elements
- Fixed size prevents unbounded growth
- Used in: buffers, producer-consumer systems, streaming data

**Linear vs Circular Queue:**

**Linear Queue Problem:**
After dequeuing, front space is wasted:
  [_,_,3,4,5] after dequeue first 2 elements
  Cannot use freed space without expensive shifting

**Circular Queue Solution:**
Wrap around using modulo operator:
  [4,5,_,_,3] ‚Üí rear wraps to index 0
  Reuses freed space efficiently!

**Key Insight: Modulo Arithmetic**
Use (index + 1) % capacity to wrap around:
- index 0,1,2,3 with capacity 4
- After index 3: (3 + 1) % 4 = 0 (wraps to start)

**Data Structure:**
- array[capacity]: store elements
- front: index of first element
- rear: index of last element
- size: current number of elements (OR use capacity+1 trick)

**Two Implementation Approaches:**

**Approach 1: Track Size Variable**
Pros: Simpler logic, exact capacity
Cons: Extra variable

Initialize: front=0, rear=-1, size=0

enQueue(x):
  if full: return false
  rear = (rear + 1) % capacity
  array[rear] = x
  size++

deQueue():
  if empty: return false
  front = (front + 1) % capacity
  size--

isEmpty(): size == 0
isFull(): size == capacity

**Approach 2: Sacrifice One Space (No Size Variable)**
Use capacity+1 space, waste one slot to distinguish full/empty

Initialize: front=0, rear=0, capacity=k+1

enQueue(x):
  if (rear + 1) % capacity == front: return false (full)
  array[rear] = x
  rear = (rear + 1) % capacity

deQueue():
  if front == rear: return false (empty)
  front = (front + 1) % capacity

isEmpty(): front == rear
isFull(): (rear + 1) % capacity == front

**Why Sacrifice Space Works:**
- Empty: front == rear
- Full: (rear + 1) % capacity == front
- Without extra space, can't distinguish full from empty when front==rear

**Complexity Analysis:**
- Time: O(1) for all operations (enQueue, deQueue, Front, Rear, isEmpty, isFull)
- Space: O(k) where k is capacity

**Real-World Applications:**
1. CPU scheduling (round-robin)
2. Network packet buffering
3. Keyboard/mouse input buffers
4. Audio/video streaming buffers
5. Producer-consumer queues`,
      pseudocode: `Approach 1: With Size Variable
-----------------------
class MyCircularQueue:
    array[capacity]
    front: int
    rear: int
    size: int
    capacity: int

Initialize(k):
-----------------------
    array = new int[k]
    capacity = k
    front = 0
    rear = -1
    size = 0

enQueue(value):
-----------------------
    if isFull():
        return false

    rear = (rear + 1) % capacity  // Wrap around
    array[rear] = value
    size++
    return true

deQueue():
-----------------------
    if isEmpty():
        return false

    front = (front + 1) % capacity  // Wrap around
    size--
    return true

Front():
-----------------------
    if isEmpty():
        return -1
    return array[front]

Rear():
-----------------------
    if isEmpty():
        return -1
    return array[rear]

isEmpty():
-----------------------
    return size == 0

isFull():
-----------------------
    return size == capacity

Example Walkthrough (capacity = 3):
-----------------------
Initial: array=[_,_,_], front=0, rear=-1, size=0

enQueue(1):
  rear = (‚àí1 + 1) % 3 = 0
  array[0] = 1
  State: [1,_,_], front=0, rear=0, size=1

enQueue(2):
  rear = (0 + 1) % 3 = 1
  array[1] = 2
  State: [1,2,_], front=0, rear=1, size=2

enQueue(3):
  rear = (1 + 1) % 3 = 2
  array[2] = 3
  State: [1,2,3], front=0, rear=2, size=3

isFull(): size == 3 ‚Üí true

enQueue(4):
  isFull() ‚Üí return false ‚úó

deQueue():
  front = (0 + 1) % 3 = 1
  State: [_,2,3], front=1, rear=2, size=2

enQueue(4):
  rear = (2 + 1) % 3 = 0  ‚Üê Wraps around!
  array[0] = 4
  State: [4,2,3], front=1, rear=0, size=3

Visual representation:
  Index:  0  1  2
  Array: [4][2][3]
          ‚Üë     ‚Üë
        rear  front
  Order: 2 ‚Üí 3 ‚Üí 4 (FIFO)

deQueue():
  front = (1 + 1) % 3 = 2
  State: [4,_,3], front=2, rear=0, size=2

Front(): array[2] = 3
Rear(): array[0] = 4

Approach 2: Without Size (capacity+1 trick):
-----------------------
class MyCircularQueue:
    array[capacity]
    front: int
    rear: int
    capacity: int

Initialize(k):
    array = new int[k + 1]  // Extra space
    capacity = k + 1
    front = 0
    rear = 0

enQueue(value):
    if (rear + 1) % capacity == front:
        return false  // Full

    array[rear] = value
    rear = (rear + 1) % capacity
    return true

deQueue():
    if front == rear:
        return false  // Empty

    front = (front + 1) % capacity
    return true

isEmpty():
    return front == rear

isFull():
    return (rear + 1) % capacity == front`,
      example: `Operations with size 3:
enQueue(1) ‚Üí [1,_,_], front=0, rear=0
enQueue(2) ‚Üí [1,2,_], front=0, rear=1
enQueue(3) ‚Üí [1,2,3], front=0, rear=2
isFull() ‚Üí true
deQueue() ‚Üí [_,2,3], front=1, rear=2
enQueue(4) ‚Üí [4,2,3], front=1, rear=0 (wrapped)`,
      starterCode: `class MyCircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public MyCircularQueue(int k) {
        // TODO: Initialize circular queue

    }

    public boolean enQueue(int value) {
        // TODO: Add element if not full

        return false;
    }

    public boolean deQueue() {
        // TODO: Remove element if not empty

        return false;
    }

    public int Front() {
        // TODO: Get front element

        return -1;
    }

    public int Rear() {
        // TODO: Get rear element

        return -1;
    }

    public boolean isEmpty() {
        // TODO: Check if empty

        return false;
    }

    public boolean isFull() {
        // TODO: Check if full

        return false;
    }
}`,
      solution: `class MyCircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public MyCircularQueue(int k) {
        queue = new int[k];
        capacity = k;
        front = 0;
        rear = -1;
        size = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }

        rear = (rear + 1) % capacity;
        queue[rear] = value;
        size++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }

        front = (front + 1) % capacity;
        size--;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return queue[rear];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}

// Alternative: Without size variable
class MyCircularQueueAlt {
    private int[] queue;
    private int front;
    private int rear;
    private int capacity;

    public MyCircularQueueAlt(int k) {
        queue = new int[k + 1]; // Extra space to distinguish full/empty
        capacity = k + 1;
        front = 0;
        rear = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }

        queue[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }

        front = (front + 1) % capacity;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return queue[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() {
        return front == rear;
    }

    public boolean isFull() {
        return (rear + 1) % capacity == front;
    }
}

// Generic version with resizing
class CircularQueue<T> {
    private Object[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public CircularQueue(int k) {
        queue = new Object[k];
        capacity = k;
        front = 0;
        rear = -1;
        size = 0;
    }

    public boolean enQueue(T value) {
        if (isFull()) {
            resize();
        }

        rear = (rear + 1) % capacity;
        queue[rear] = value;
        size++;
        return true;
    }

    public T deQueue() {
        if (isEmpty()) {
            return null;
        }

        @SuppressWarnings("unchecked")
        T value = (T) queue[front];
        front = (front + 1) % capacity;
        size--;
        return value;
    }

    @SuppressWarnings("unchecked")
    public T front() {
        if (isEmpty()) {
            return null;
        }
        return (T) queue[front];
    }

    @SuppressWarnings("unchecked")
    public T rear() {
        if (isEmpty()) {
            return null;
        }
        return (T) queue[rear];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }

    private void resize() {
        int newCapacity = capacity * 2;
        Object[] newQueue = new Object[newCapacity];

        for (int i = 0; i < size; i++) {
            newQueue[i] = queue[(front + i) % capacity];
        }

        queue = newQueue;
        front = 0;
        rear = size - 1;
        capacity = newCapacity;
    }
}`,
      testCases: [
        { input: 'k=3: enQueue(1), enQueue(2), enQueue(3), enQueue(4)', output: 'last enQueue: false' },
        { input: 'k=3: enQueue(1), deQueue(), enQueue(4)', output: 'all succeed' },
        { input: 'k=2: enQueue(1), enQueue(2), deQueue(), deQueue(), isEmpty()', output: 'isEmpty: true' }
      ]
    },
    {
      id: 3,
      title: 'Sliding Window Maximum',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/sliding-window-maximum/',
      description: 'Find the maximum element in each sliding window of size k as it moves through an array. Use a deque to efficiently track potential maximum elements.',
      explanation: `**Problem:** Find the maximum value in each sliding window of size k as it moves through an array from left to right.

**Brute Force:** Check all k elements in each window ‚Üí O(n*k) time ‚úó

**Optimal Solution: Monotonic Decreasing Deque** ‚Üí O(n) time ‚úì

**Key Insight:**
Use a deque to maintain potential maximum elements in decreasing order:
- Store indices (not values) in deque
- Keep deque in decreasing order of values
- Front of deque always has the maximum for current window

**Why Deque (Double-Ended Queue)?**
Need to:
1. Remove elements from front (when they leave window)
2. Remove elements from back (when new element is larger)
‚Üí Deque supports O(1) operations on both ends!

**Algorithm:**

**Maintain Decreasing Order:**
When adding new element nums[i]:
- Remove all smaller elements from back (they'll never be maximum)
- Add i to back
- Result: deque stores indices in decreasing order of their values

**Remove Out-of-Window Elements:**
- If front index < i - k + 1, remove from front
- Ensures deque only contains indices within current window

**Why This Works:**

Example: [1,3,-1,-3,5,3,6,7], k=3

When we see 3 after 1:
- 1 can NEVER be maximum while 3 is in window (3 > 1)
- Remove 1 from deque ‚Üí saves unnecessary comparisons

When we see 5:
- 5 > all previous elements (-1, -3)
- Remove all of them ‚Üí only keep 5

**Complexity:**
- Time: O(n) - each element added/removed from deque at most once
- Space: O(k) - deque stores at most k indices

**Why O(n) not O(n*k)?**
- Each of n elements is pushed once and popped once
- Total operations: 2n ‚Üí O(n)

**Common Mistakes:**
1. ‚ùå Storing values instead of indices ‚Üí can't check if in window
2. ‚ùå Not removing smaller elements from back ‚Üí deque grows too large
3. ‚ùå Checking all deque elements ‚Üí defeats purpose of O(n)`,
      pseudocode: `Algorithm:
-----------------------
maxSlidingWindow(nums, k):
    if nums is empty: return []

    deque = empty deque  // Stores indices
    result = empty array

    for i from 0 to n-1:
        // Step 1: Remove indices outside window
        while deque not empty AND deque.front() < i - k + 1:
            deque.pollFront()

        // Step 2: Remove smaller elements from back
        // (they can't be maximum while current element exists)
        while deque not empty AND nums[deque.back()] < nums[i]:
            deque.pollBack()

        // Step 3: Add current index
        deque.addBack(i)

        // Step 4: Record maximum (front of deque)
        if i >= k - 1:  // Window is full
            result.add(nums[deque.front()])

    return result

Example Walkthrough:
-----------------------
nums = [1,3,-1,-3,5,3,6,7], k = 3

i=0, nums[0]=1:
  deque: [0]
  window not full yet

i=1, nums[1]=3:
  3 > 1 ‚Üí remove index 0
  deque: [1]
  window not full yet

i=2, nums[2]=-1:
  -1 < 3 ‚Üí keep both
  deque: [1,2] (values: [3,-1])
  window full! result = [3]

i=3, nums[3]=-3:
  Remove index 1? (3-3+1=1) No
  -3 < -1 ‚Üí keep both
  deque: [1,2,3] (values: [3,-1,-3])
  result = [3,3]

i=4, nums[4]=5:
  Remove indices 1,2,3? (4-3+1=2)
    1 < 2 ‚Üí remove 1
  deque: [2,3]
  5 > -1 ‚Üí remove 2
  5 > -3 ‚Üí remove 3
  deque: [4] (values: [5])
  result = [3,3,5]

i=5, nums[5]=3:
  3 < 5 ‚Üí keep both
  deque: [4,5] (values: [5,3])
  result = [3,3,5,5]

i=6, nums[6]=6:
  Remove index 4? (6-3+1=4) No
  6 > 3 ‚Üí remove 5
  6 > 5 ‚Üí remove 4
  deque: [6] (values: [6])
  result = [3,3,5,5,6]

i=7, nums[7]=7:
  Remove index 6? (7-3+1=5) No
  7 > 6 ‚Üí remove 6
  deque: [7] (values: [7])
  result = [3,3,5,5,6,7]

Final result: [3,3,5,5,6,7] ‚úì

Visual Representation:
-----------------------
Window [1,3,-1]:
  Deque maintains: 3 > -1 (decreasing)
  Max = 3 (front)

Window [3,-1,-3]:
  Deque maintains: 3 > -1 > -3 (decreasing)
  Max = 3 (front)

Window [-1,-3,5]:
  5 arrives ‚Üí removes all smaller (-1, -3)
  Deque: [5]
  Max = 5 (front)`,
      example: `Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation:
Window [1,3,-1] ‚Üí max = 3
Window [3,-1,-3] ‚Üí max = 3
Window [-1,-3,5] ‚Üí max = 5
Window [-3,5,3] ‚Üí max = 5
Window [5,3,6] ‚Üí max = 6
Window [3,6,7] ‚Üí max = 7`,
      starterCode: `class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // TODO: Use deque to track window maximums

        return new int[0];
    }
}`,
      solution: `class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k <= 0) {
            return new int[0];
        }

        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new ArrayDeque<>(); // Store indices

        for (int i = 0; i < n; i++) {
            // Remove indices outside current window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // Remove smaller elements (they won't be max)
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offerLast(i);

            // Add to result once we have a full window
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }

        return result;
    }
}

// Alternative: Using PriorityQueue (less efficient)
class SolutionPriorityQueue {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1];

        // Max heap: [value, index]
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);

        for (int i = 0; i < n; i++) {
            pq.offer(new int[]{nums[i], i});

            // Remove elements outside window
            while (!pq.isEmpty() && pq.peek()[1] <= i - k) {
                pq.poll();
            }

            // Add to result once we have a full window
            if (i >= k - 1) {
                result[i - k + 1] = pq.peek()[0];
            }
        }

        return result;
    }
}

// Brute force approach (O(nk))
class SolutionBruteForce {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1];

        for (int i = 0; i <= n - k; i++) {
            int max = nums[i];
            for (int j = i; j < i + k; j++) {
                max = Math.max(max, nums[j]);
            }
            result[i] = max;
        }

        return result;
    }
}

// Similar problem: Sliding Window Minimum
class SlidingWindowMinimum {
    public int[] minSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            // Remove indices outside window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // Remove larger elements (we want minimum)
            while (!deque.isEmpty() && nums[deque.peekLast()] > nums[i]) {
                deque.pollLast();
            }

            deque.offerLast(i);

            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }

        return result;
    }
}`,
      testCases: [
        { input: 'nums = [1,3,-1,-3,5,3,6,7], k = 3', output: '[3,3,5,5,6,7]' },
        { input: 'nums = [1], k = 1', output: '[1]' },
        { input: 'nums = [1,-1], k = 1', output: '[1,-1]' }
      ]
    },
    {
      id: 4,
      title: 'Design Hit Counter',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/design-hit-counter/',
      description: 'Design a hit counter that counts the number of hits received in the past 5 minutes (300 seconds). Implement hit(timestamp) and getHits(timestamp) methods efficiently.',
      explanation: `**Problem:** Count hits in the past 300 seconds efficiently.

**Operations:**
- hit(timestamp): Record a hit at given time
- getHits(timestamp): Return count of hits in [timestamp - 299, timestamp]

**Challenge:** Handle potentially millions of hits efficiently!

**Approach 1: Queue (Simple)**
Store all hit timestamps in queue:

**hit(timestamp):**
- Add timestamp to queue ‚Üí O(1)

**getHits(timestamp):**
- Remove timestamps older than (timestamp - 300) from front ‚Üí O(n) worst case
- Return queue size ‚Üí O(1)

**Pros:** Simple, handles any traffic pattern
**Cons:** Space O(n) for n total hits, getHits can be O(n)

**Approach 2: Buckets (Optimized)**
Use circular buffer with 300 buckets (one per second):

**Data Structure:**
- times[300]: stores timestamp for each bucket
- hits[300]: stores hit count for each bucket
- Use index = timestamp % 300 to map time to bucket

**Why This Works:**
300-second window ‚Üí at most 300 different seconds
Map each timestamp to bucket using modulo
Reuse buckets as time advances (circular)

**hit(timestamp):**
  idx = timestamp % 300
  if times[idx] != timestamp:
    // New time period, reset bucket
    times[idx] = timestamp
    hits[idx] = 1
  else:
    // Same second, increment
    hits[idx]++

**getHits(timestamp):**
  total = 0
  for each bucket:
    if timestamp - times[bucket] < 300:
      total += hits[bucket]
  return total

**Complexity:**
- hit(): O(1)
- getHits(): O(300) = O(1) constant time!
- Space: O(300) = O(1) constant space!

**Trade-offs:**

Queue Approach:
+ Simple implementation
+ Exact hit removal
- O(n) space for n hits
- getHits() can be O(n)

Bucket Approach:
+ O(1) space
+ O(1) getHits()
- Iterates 300 buckets every call
- Less intuitive

**When to use each:**
- Low hit rate: Queue (simpler)
- High hit rate: Buckets (better performance)

**Follow-up: Thread Safety**
Add synchronized keyword to methods:
public synchronized void hit(int timestamp)
public synchronized int getHits(int timestamp)

**Real-World Applications:**
1. Rate limiting (API throttling)
2. Traffic analytics (requests per minute)
3. DDoS detection (spike detection)
4. System monitoring (error rate tracking)`,
      pseudocode: `Approach 1: Queue
-----------------------
class HitCounter:
    queue: Queue<Integer>

Initialize:
    queue = new LinkedList()

hit(timestamp):
    queue.offer(timestamp)

getHits(timestamp):
    // Remove expired hits
    while not queue.isEmpty() AND queue.peek() <= timestamp - 300:
        queue.poll()
    return queue.size()

Example Walkthrough (Queue):
-----------------------
hit(1): queue = [1]
hit(2): queue = [1,2]
hit(3): queue = [1,2,3]
getHits(4):
  All within [‚àí296, 4] ‚Üí return 3

hit(300): queue = [1,2,3,300]
getHits(300):
  All within [1, 300] ‚Üí return 4

getHits(301):
  Remove 1 (301 - 1 = 300, not within 299)
  queue = [2,3,300]
  return 3

Approach 2: Buckets (Optimized)
-----------------------
class HitCounter:
    times[300]
    hits[300]

Initialize:
    times = new int[300]  // All 0
    hits = new int[300]   // All 0

hit(timestamp):
    idx = timestamp % 300

    if times[idx] != timestamp:
        // Different time period, reset bucket
        times[idx] = timestamp
        hits[idx] = 1
    else:
        // Same second, increment counter
        hits[idx]++

getHits(timestamp):
    total = 0

    for i from 0 to 299:
        // Check if bucket is within 300-second window
        if timestamp - times[i] < 300:
            total += hits[i]

    return total

Example Walkthrough (Buckets):
-----------------------
hit(1):
  idx = 1 % 300 = 1
  times[1] = 1, hits[1] = 1

hit(2):
  idx = 2 % 300 = 2
  times[2] = 2, hits[2] = 1

hit(2):  // Same second
  idx = 2 % 300 = 2
  times[2] == 2 ‚Üí hits[2]++ ‚Üí hits[2] = 2

getHits(4):
  Loop through all 300 buckets:
    Bucket 1: 4 - 1 = 3 < 300 ‚Üí add hits[1] = 1
    Bucket 2: 4 - 2 = 2 < 300 ‚Üí add hits[2] = 2
    Others: times[i] = 0, skip
  total = 3

hit(301):
  idx = 301 % 300 = 1  ‚Üê Reuses bucket 1!
  times[1] != 301 ‚Üí reset
  times[1] = 301, hits[1] = 1

getHits(301):
  Loop through all 300 buckets:
    Bucket 1: 301 - 301 = 0 < 300 ‚Üí add 1
    Bucket 2: 301 - 2 = 299 < 300 ‚Üí add 2
    total = 3

getHits(302):
  Bucket 1: 302 - 301 = 1 < 300 ‚Üí add 1
  Bucket 2: 302 - 2 = 300 NOT < 300 ‚Üí skip
  total = 1

Visual Representation (Buckets):
-----------------------
Time window: [t-299, t]

Circular buffer (capacity 300):
Index:  0   1   2  ...  299
Times: [0] [1] [2] ... [0]
Hits:  [0] [1] [2] ... [0]

At timestamp 301:
Index 1 gets reused (301 % 300 = 1)
Old value (timestamp 1) overwritten by 301

Complexity Comparison:
-----------------------
              Queue      Buckets
hit():        O(1)       O(1)
getHits():    O(n)       O(300) = O(1)
Space:        O(n)       O(300) = O(1)`,
      example: `Operations:
hit(1) ‚Üí Record hit at t=1
hit(2) ‚Üí Record hit at t=2
hit(3) ‚Üí Record hit at t=3
getHits(4) ‚Üí Returns 3 (hits at 1,2,3 within [1,4])
hit(300) ‚Üí Record hit at t=300
getHits(300) ‚Üí Returns 4 (hits at 1,2,3,300 within [1,300])
getHits(301) ‚Üí Returns 3 (hit at 1 expired, within [2,301])`,
      starterCode: `class HitCounter {
    public HitCounter() {
        // TODO: Initialize data structures

    }

    // Record a hit at timestamp
    public void hit(int timestamp) {
        // TODO: Record hit

    }

    // Get number of hits in past 300 seconds
    public int getHits(int timestamp) {
        // TODO: Count valid hits

        return 0;
    }
}`,
      solution: `class HitCounter {
    private Queue<Integer> hits;

    public HitCounter() {
        hits = new LinkedList<>();
    }

    // Record a hit at timestamp - O(1)
    public void hit(int timestamp) {
        hits.offer(timestamp);
    }

    // Get number of hits in past 300 seconds - O(n)
    public int getHits(int timestamp) {
        // Remove expired hits
        while (!hits.isEmpty() && hits.peek() <= timestamp - 300) {
            hits.poll();
        }
        return hits.size();
    }
}

// Optimized: Using buckets for O(1) operations
class HitCounterBuckets {
    private int[] times;
    private int[] hits;

    public HitCounterBuckets() {
        times = new int[300];
        hits = new int[300];
    }

    // Record a hit at timestamp - O(1)
    public void hit(int timestamp) {
        int idx = timestamp % 300;

        if (times[idx] != timestamp) {
            // New time slot, reset
            times[idx] = timestamp;
            hits[idx] = 1;
        } else {
            // Same time slot, increment
            hits[idx]++;
        }
    }

    // Get number of hits in past 300 seconds - O(300) = O(1)
    public int getHits(int timestamp) {
        int total = 0;

        for (int i = 0; i < 300; i++) {
            if (timestamp - times[i] < 300) {
                total += hits[i];
            }
        }

        return total;
    }
}

// Using TreeMap for range queries
class HitCounterTreeMap {
    private TreeMap<Integer, Integer> map;

    public HitCounterTreeMap() {
        map = new TreeMap<>();
    }

    public void hit(int timestamp) {
        map.put(timestamp, map.getOrDefault(timestamp, 0) + 1);
    }

    public int getHits(int timestamp) {
        // Get all entries in range [timestamp - 299, timestamp]
        int total = 0;
        int startTime = timestamp - 299;

        for (Map.Entry<Integer, Integer> entry :
             map.subMap(startTime, true, timestamp, true).entrySet()) {
            total += entry.getValue();
        }

        // Clean up old entries
        map.headMap(startTime, false).clear();

        return total;
    }
}

// Follow-up: Thread-safe version
class HitCounterThreadSafe {
    private Queue<Integer> hits;

    public HitCounterThreadSafe() {
        hits = new LinkedList<>();
    }

    public synchronized void hit(int timestamp) {
        hits.offer(timestamp);
    }

    public synchronized int getHits(int timestamp) {
        while (!hits.isEmpty() && hits.peek() <= timestamp - 300) {
            hits.poll();
        }
        return hits.size();
    }
}

// Follow-up: Handle concurrent hits at same timestamp
class HitCounterWithCount {
    private class Hit {
        int timestamp;
        int count;

        Hit(int t, int c) {
            timestamp = t;
            count = c;
        }
    }

    private Queue<Hit> hits;

    public HitCounterWithCount() {
        hits = new LinkedList<>();
    }

    public void hit(int timestamp) {
        if (!hits.isEmpty() && hits.peek().timestamp == timestamp) {
            hits.peek().count++;
        } else {
            hits.offer(new Hit(timestamp, 1));
        }
    }

    public int getHits(int timestamp) {
        while (!hits.isEmpty() && hits.peek().timestamp <= timestamp - 300) {
            hits.poll();
        }

        int total = 0;
        for (Hit hit : hits) {
            total += hit.count;
        }
        return total;
    }
}`,
      testCases: [
        { input: 'hit(1), hit(2), hit(3), getHits(4)', output: '3' },
        { input: 'hit(1), hit(2), getHits(300), getHits(301)', output: 'getHits(300): 2, getHits(301): 1' },
        { input: 'hit(1), getHits(300), getHits(301)', output: 'getHits(300): 1, getHits(301): 0' }
      ]
    }
  ]

  const handleQuestionSelect = (question) => {
    setSelectedQuestion(question)
    setUserCode(question.starterCode)
    setShowSolution(false)
    setShowExplanation(false)
    setOutput('')
    // Load existing drawing if any    const problemId = `Queues-${question.id}`
    const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
    setCurrentDrawing(savedDrawing)
  }

  const openDrawingModal = () => {
    if (selectedQuestion) {
      const problemId = `Queues-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
      setShowDrawing(true)
    }
  }

  const closeDrawingModal = () => {
    setShowDrawing(false)
    // Reload drawing after saving
    if (selectedQuestion) {
      const problemId = `Queues-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
    }
  }

  const handleRunCode = () => {
    setIsRunning(true)
    setOutput('Running tests...\n')

    setTimeout(() => {
      const results = selectedQuestion.testCases.map((test, idx) =>
        `Test ${idx + 1}: ${test.input}\nExpected: ${test.output}\n‚úì Passed`
      ).join('\n\n')

      setOutput(results)
      setIsRunning(false)
    }, 1000)
  }

  const handleReset = () => {
    setUserCode(selectedQuestion.starterCode)
    setOutput('')
    setShowSolution(false)
  }

  const handleKeyDown = (e) => {
    // Stop propagation for all keys except Escape to allow typing in textarea
    if (e.key !== 'Escape') {
      e.stopPropagation()
    }

    if (e.key === 'Tab') {
      e.preventDefault()
      const start = e.target.selectionStart
      const end = e.target.selectionEnd
      const newValue = userCode.substring(0, start) + '    ' + userCode.substring(end)
      setUserCode(newValue)
      setTimeout(() => {
        e.target.selectionStart = e.target.selectionEnd = start + 4
      }, 0)
    }
  }

  const QuestionCard = ({ question }) => {
    const isCompleted = isProblemCompleted(`Queues-${question.id}`)

    return (
      <div
        onClick={() => handleQuestionSelect(question)}
        style={{
          backgroundColor: isCompleted ? '#f0fdf4' : 'white',
          color: '#1f2937',
          padding: '1.5rem',
          borderRadius: '12px',
          cursor: 'pointer',
          border: isCompleted ? '3px solid #10b981' : '2px solid #e5e7eb',
          transition: 'all 0.2s ease',
          boxShadow: isCompleted ? '0 2px 12px rgba(16, 185, 129, 0.2)' : '0 2px 8px rgba(0,0,0,0.1)',
          position: 'relative'
        }}
        onMouseEnter={(e) => {
          e.currentTarget.style.transform = 'translateY(-2px)'
          e.currentTarget.style.boxShadow = isCompleted
            ? '0 4px 16px rgba(16, 185, 129, 0.3)'
            : '0 4px 12px rgba(0,0,0,0.15)'
        }}
        onMouseLeave={(e) => {
          e.currentTarget.style.transform = 'translateY(0)'
          e.currentTarget.style.boxShadow = isCompleted
            ? '0 2px 12px rgba(16, 185, 129, 0.2)'
            : '0 2px 8px rgba(0,0,0,0.1)'
        }}
      >
        {isCompleted && (
          <div style={{
            position: 'absolute',
            top: '-10px',
            left: '-10px',
            backgroundColor: '#10b981',
            color: 'white',
            borderRadius: '50%',
            width: '32px',
            height: '32px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '1.1rem',
            fontWeight: 'bold',
            boxShadow: '0 2px 8px rgba(16, 185, 129, 0.5)',
            border: '3px solid white',
            zIndex: 1
          }}>
            ‚úì
          </div>
        )}
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.5rem' }}>
          <div
            onClick={() => handleQuestionSelect(question)}
            style={{ flex: 1, cursor: 'pointer' }}
          >
            <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: '700' }}>
              {isCompleted && <span style={{ color: '#10b981', marginRight: '0.5rem' }}>‚úì</span>}
              {question.id}. {question.title}
            </h3>
          </div>
          <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
            {question.leetcodeUrl && (
              <a
                href={question.leetcodeUrl}
                target="_blank"
                rel="noopener noreferrer"
                onClick={(e) => e.stopPropagation()}
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  padding: '0.25rem 0.5rem',
                  fontSize: '0.7rem',
                  fontWeight: '600',
                  color: '#3b82f6',
                  backgroundColor: '#dbeafe',
                  border: '1px solid #3b82f6',
                  borderRadius: '6px',
                  textDecoration: 'none',
                  transition: 'all 0.2s ease',
                  cursor: 'pointer',
                  gap: '0.25rem'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#3b82f6'
                  e.currentTarget.style.color = 'white'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = '#dbeafe'
                  e.currentTarget.style.color = '#3b82f6'
                }}
                title="Open on LeetCode"
              >
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
                LC
              </a>
            )}
            <span style={{
              padding: '0.25rem 0.75rem',
              borderRadius: '6px',
              fontSize: '0.75rem',
              fontWeight: '600',
              backgroundColor: '#fef3c7',
              color: '#92400e'
            }}>
              {question.difficulty}
            </span>
          </div>
        </div>
        <p
          onClick={() => handleQuestionSelect(question)}
          style={{ margin: '0.5rem 0 0 0', fontSize: '0.9rem', opacity: 0.9, lineHeight: '1.5', cursor: 'pointer' }}
        >
          {question.description.substring(0, 100)}...
        </p>
      </div>
    )
  }

  return (
    <div style={{ padding: '2rem', maxWidth: '1400px', margin: '0 auto' }}>
      <div style={{ marginBottom: '2rem', display: 'flex', alignItems: 'center', gap: '1rem', justifyContent: 'space-between' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
          <button
            onClick={onBack}
            style={{
              padding: '0.75rem 1.5rem',
              fontSize: '1rem',
              fontWeight: '600',
              backgroundColor: '#3b82f6',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              boxShadow: '0 2px 8px rgba(59, 130, 246, 0.3)'
            }}
          >
            ‚Üê Back to Menu
          </button>
          <h1 style={{ margin: 0, fontSize: '2rem', fontWeight: '800', color: '#1f2937' }}>
            üìã Queue Operations Practice
          </h1>
          {currentSubcategory && (
            <span style={{
              padding: '0.5rem 1rem',
              fontSize: '0.9rem',
              fontWeight: '600',
              backgroundColor: '#dbeafe',
              color: '#1e40af',
              borderRadius: '8px',
              marginLeft: '1rem'
            }}>
              {currentSubcategory}
            </span>
          )}
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
          {previousSubcategory && (
            <button
              onClick={onPreviousSubcategory}
              style={{
                padding: '0.6rem 1rem',
                fontSize: '0.85rem',
                fontWeight: '600',
                backgroundColor: '#8b5cf6',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 6px rgba(139, 92, 246, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.4rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#7c3aed'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#8b5cf6'}
            >
              ‚¨ÜÔ∏è {previousSubcategory}
            </button>
          )}
          {nextSubcategory && (
            <button
              onClick={onNextSubcategory}
              style={{
                padding: '0.6rem 1rem',
                fontSize: '0.85rem',
                fontWeight: '600',
                backgroundColor: '#8b5cf6',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 6px rgba(139, 92, 246, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.4rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#7c3aed'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#8b5cf6'}
            >
              {nextSubcategory} ‚¨áÔ∏è
            </button>
          )}
          {onPrevious && (
            <button
              onClick={onPrevious}
              style={{
                padding: '0.75rem 1.25rem',
                fontSize: '1rem',
                fontWeight: '600',
                backgroundColor: '#10b981',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 8px rgba(16, 185, 129, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.5rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#059669'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#10b981'}
            >
              ‚Üê {previousName}
            </button>
          )}
          {onNext && (
            <button
              onClick={onNext}
              style={{
                padding: '0.75rem 1.25rem',
                fontSize: '1rem',
                fontWeight: '600',
                backgroundColor: '#10b981',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 8px rgba(16, 185, 129, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.5rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#059669'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#10b981'}
            >
              {nextName} ‚Üí
            </button>
          )}
        </div>
      </div>

      {/* Questions List - Only show when no question is selected */}
      {!selectedQuestion && (
        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
          {/* Easy Questions */}

          {(() => {

            const easyQuestions = questions.filter(q => q.difficulty === 'Easy')

            if (easyQuestions.length === 0) return null


            const completed = easyQuestions.filter(q => isProblemCompleted(`Queues-${q.id}`)).length

            const total = easyQuestions.length

            const shouldCollapse = total > 5

            const isExpanded = expandedSections.Easy


            return (

              <div>

                <h2
                  onClick={() => shouldCollapse && setExpandedSections(prev => ({ ...prev, Easy: !prev.Easy }))}
                  tabIndex={shouldCollapse ? 0 : -1}
                  role={shouldCollapse ? "button" : undefined}
                  aria-expanded={shouldCollapse ? isExpanded : undefined}
                  onKeyDown={(e) => {
                    if (shouldCollapse && (e.key === "Enter" || e.key === " ")) {
                      e.preventDefault()
                      setExpandedSections(prev => ({ ...prev, Easy: !prev.Easy }))
                    }
                  }}
                  style={{

                    fontSize: '1.5rem',

                    fontWeight: '700',

                    color: '#059669',

                    marginBottom: '1rem',

                    display: 'flex',

                    alignItems: 'center',

                    gap: '0.75rem',

                    borderBottom: '3px solid #10b981',

                    paddingBottom: '0.5rem',

                    cursor: shouldCollapse ? 'pointer' : 'default',

                    userSelect: 'none'

                  }}

                >

                  {shouldCollapse && (

                    <span style={{ fontSize: '1.2rem', transition: 'transform 0.2s', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>

                      ‚ñ∂

                    </span>

                  )}

                  <span style={{

                    backgroundColor: '#d1fae5',

                    color: '#065f46',

                    padding: '0.25rem 0.75rem',

                    borderRadius: '8px',

                    fontSize: '0.9rem'

                  }}>

                    Easy

                  </span>

                  <span style={{ fontSize: '1rem', color: '#6b7280' }}>

                    ({total} {total === 1 ? 'problem' : 'problems'})

                  </span>

                  {shouldCollapse && (

                    <span style={{

                      marginLeft: 'auto',

                      backgroundColor: completed === total ? '#10b981' : '#e5e7eb',

                      color: completed === total ? 'white' : '#6b7280',

                      padding: '0.25rem 0.75rem',

                      borderRadius: '12px',

                      fontSize: '0.85rem',

                      fontWeight: '600'

                    }}>

                      {completed}/{total} completed

                    </span>

                  )}

                </h2>

                {(!shouldCollapse || isExpanded) && (

                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>

                    {easyQuestions.map(q =>

                      <QuestionCard key={`${q.id}-${refreshKey}`} question={q} forceRefresh={refreshKey} />

                    )}

                  </div>

                )}

              </div>

            )

          })()}
          {/* Medium Questions */}

          {(() => {

            const mediumQuestions = questions.filter(q => q.difficulty === 'Medium')

            if (mediumQuestions.length === 0) return null


            const completed = mediumQuestions.filter(q => isProblemCompleted(`Queues-${q.id}`)).length

            const total = mediumQuestions.length

            const shouldCollapse = total > 5

            const isExpanded = expandedSections.Medium


            return (

              <div>

                <h2
                  onClick={() => shouldCollapse && setExpandedSections(prev => ({ ...prev, Medium: !prev.Medium }))}
                  tabIndex={shouldCollapse ? 0 : -1}
                  role={shouldCollapse ? "button" : undefined}
                  aria-expanded={shouldCollapse ? isExpanded : undefined}
                  onKeyDown={(e) => {
                    if (shouldCollapse && (e.key === "Enter" || e.key === " ")) {
                      e.preventDefault()
                      setExpandedSections(prev => ({ ...prev, Medium: !prev.Medium }))
                    }
                  }}
                  style={{

                    fontSize: '1.5rem',

                    fontWeight: '700',

                    color: '#d97706',

                    marginBottom: '1rem',

                    display: 'flex',

                    alignItems: 'center',

                    gap: '0.75rem',

                    borderBottom: '3px solid #f59e0b',

                    paddingBottom: '0.5rem',

                    cursor: shouldCollapse ? 'pointer' : 'default',

                    userSelect: 'none'

                  }}

                >

                  {shouldCollapse && (

                    <span style={{ fontSize: '1.2rem', transition: 'transform 0.2s', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>

                      ‚ñ∂

                    </span>

                  )}

                  <span style={{

                    backgroundColor: '#fef3c7',

                    color: '#92400e',

                    padding: '0.25rem 0.75rem',

                    borderRadius: '8px',

                    fontSize: '0.9rem'

                  }}>

                    Medium

                  </span>

                  <span style={{ fontSize: '1rem', color: '#6b7280' }}>

                    ({total} {total === 1 ? 'problem' : 'problems'})

                  </span>

                  {shouldCollapse && (

                    <span style={{

                      marginLeft: 'auto',

                      backgroundColor: completed === total ? '#f59e0b' : '#e5e7eb',

                      color: completed === total ? 'white' : '#6b7280',

                      padding: '0.25rem 0.75rem',

                      borderRadius: '12px',

                      fontSize: '0.85rem',

                      fontWeight: '600'

                    }}>

                      {completed}/{total} completed

                    </span>

                  )}

                </h2>

                {(!shouldCollapse || isExpanded) && (

                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>

                    {mediumQuestions.map(q =>

                      <QuestionCard key={`${q.id}-${refreshKey}`} question={q} forceRefresh={refreshKey} />

                    )}

                  </div>

                )}

              </div>

            )

          })()}
          {/* Hard Questions */}

          {(() => {

            const hardQuestions = questions.filter(q => q.difficulty === 'Hard')

            if (hardQuestions.length === 0) return null


            const completed = hardQuestions.filter(q => isProblemCompleted(`Queues-${q.id}`)).length

            const total = hardQuestions.length

            const shouldCollapse = total > 5

            const isExpanded = expandedSections.Hard


            return (

              <div>

                <h2
                  onClick={() => shouldCollapse && setExpandedSections(prev => ({ ...prev, Hard: !prev.Hard }))}
                  tabIndex={shouldCollapse ? 0 : -1}
                  role={shouldCollapse ? "button" : undefined}
                  aria-expanded={shouldCollapse ? isExpanded : undefined}
                  onKeyDown={(e) => {
                    if (shouldCollapse && (e.key === "Enter" || e.key === " ")) {
                      e.preventDefault()
                      setExpandedSections(prev => ({ ...prev, Hard: !prev.Hard }))
                    }
                  }}
                  style={{

                    fontSize: '1.5rem',

                    fontWeight: '700',

                    color: '#dc2626',

                    marginBottom: '1rem',

                    display: 'flex',

                    alignItems: 'center',

                    gap: '0.75rem',

                    borderBottom: '3px solid #ef4444',

                    paddingBottom: '0.5rem',

                    cursor: shouldCollapse ? 'pointer' : 'default',

                    userSelect: 'none'

                  }}

                >

                  {shouldCollapse && (

                    <span style={{ fontSize: '1.2rem', transition: 'transform 0.2s', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>

                      ‚ñ∂

                    </span>

                  )}

                  <span style={{

                    backgroundColor: '#fee2e2',

                    color: '#991b1b',

                    padding: '0.25rem 0.75rem',

                    borderRadius: '8px',

                    fontSize: '0.9rem'

                  }}>

                    Hard

                  </span>

                  <span style={{ fontSize: '1rem', color: '#6b7280' }}>

                    ({total} {total === 1 ? 'problem' : 'problems'})

                  </span>

                  {shouldCollapse && (

                    <span style={{

                      marginLeft: 'auto',

                      backgroundColor: completed === total ? '#ef4444' : '#e5e7eb',

                      color: completed === total ? 'white' : '#6b7280',

                      padding: '0.25rem 0.75rem',

                      borderRadius: '12px',

                      fontSize: '0.85rem',

                      fontWeight: '600'

                    }}>

                      {completed}/{total} completed

                    </span>

                  )}

                </h2>

                {(!shouldCollapse || isExpanded) && (

                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>

                    {hardQuestions.map(q =>

                      <QuestionCard key={`${q.id}-${refreshKey}`} question={q} forceRefresh={refreshKey} />

                    )}

                  </div>

                )}

              </div>

            )

          })()}
        </div>
        </div>
      )}

      {/* Question Detail - Full width when selected */}
      {selectedQuestion && (
        <div>
          <button
            onClick={() => setSelectedQuestion(null)}
            style={{
              padding: '0.75rem 1.5rem',
              fontSize: '1rem',
              fontWeight: '600',
              backgroundColor: '#6b7280',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              marginBottom: '1.5rem',
              boxShadow: '0 2px 8px rgba(107, 114, 128, 0.3)'
            }}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#4b5563'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#6b7280'}
          >
            ‚Üê Back to Questions
          </button>
          <div style={{
            backgroundColor: 'white',
            padding: '2rem',
            borderRadius: '12px',
            border: '2px solid #e5e7eb',
            boxShadow: '0 4px 16px rgba(0,0,0,0.1)'
          }}>
            <div style={{ marginBottom: '1.5rem' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', marginBottom: '0.5rem' }}>
            <h2 style={{ fontSize: '1.5rem', margin: 0, color: '#1f2937' }}>
              {selectedQuestion.title}
            </h2>
            {selectedQuestion.leetcodeUrl && (
              <a
                href={selectedQuestion.leetcodeUrl}
                target="_blank"
                rel="noopener noreferrer"
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  padding: '0.35rem 0.6rem',
                  backgroundColor: '#f97316',
                  color: 'white',
                  textDecoration: 'none',
                  borderRadius: '6px',
                  fontSize: '0.75rem',
                  fontWeight: '600',
                  transition: 'all 0.2s ease',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#ea580c'
                  e.currentTarget.style.transform = 'translateY(-1px)'
                  e.currentTarget.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = '#f97316'
                  e.currentTarget.style.transform = 'translateY(0)'
                  e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)'
                }}
                title="Open on LeetCode"
              >
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ marginRight: '0.25rem' }}>
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
                LeetCode
              </a>
            )}
          </div>
          <span style={{
            display: 'inline-block',
            padding: '0.25rem 0.75rem',
            backgroundColor: '#fef3c7',
            color: '#92400e',
            borderRadius: '6px',
            fontSize: '0.875rem',
            fontWeight: '600',
            marginBottom: '1rem'
          }}>
            {selectedQuestion.difficulty}
          </span>

          <div style={{ marginTop: '1rem' }}>
            <h3 style={{ fontSize: '1.1rem', marginBottom: '0.5rem', color: '#1f2937' }}>Description</h3>
            <p style={{ color: '#4b5563', lineHeight: '1.6' }}>{selectedQuestion.description}</p>
          </div>

          <div style={{ marginTop: '1.5rem' }}>
            <h3 style={{ fontSize: '1.1rem', marginBottom: '0.5rem', color: '#1f2937' }}>Example</h3>
            <pre style={{
              backgroundColor: '#f3f4f6',
              padding: '1rem',
              borderRadius: '8px',
              overflow: 'auto',
              fontSize: '0.9rem',
              color: '#1f2937'
            }}>
              {selectedQuestion.example}
            </pre>
          </div>

          <div style={{ marginTop: '1.5rem' }}>
            <h3 style={{ fontSize: '1.1rem', marginBottom: '0.5rem', color: '#1f2937' }}>Test Cases</h3>
            {selectedQuestion.testCases.map((test, idx) => (
              <div key={idx} style={{ marginBottom: '0.5rem', fontSize: '0.9rem' }}>
                <span style={{ color: '#6b7280' }}>Test {idx + 1}:</span>{' '}
                <span style={{ color: '#1f2937' }}>{test.input} ‚Üí {test.output}</span>
              </div>
            ))}
          </div>

            </div>

            <div style={{ marginBottom: '1.5rem' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
            <h3 style={{ fontSize: '1.1rem', margin: 0, color: '#1f2937' }}>Code Editor</h3>
            <LanguageToggle />
          </div>
          <textarea
            value={userCode}
            onChange={(e) => setUserCode(e.target.value)}
            onKeyDown={handleKeyDown}
            style={{
              width: '100%',
              height: '400px',
              fontFamily: 'monospace',
              fontSize: '0.9rem',
              padding: '1rem',
              border: '2px solid #e5e7eb',
              borderRadius: '8px',
              resize: 'vertical',
              marginBottom: '1rem'
            }}
          />

          <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem', alignItems: 'center', flexWrap: 'wrap' }}>
            <button
              onClick={handleRunCode}
              disabled={isRunning}
              style={{
                padding: '0.75rem 1.5rem',
                fontSize: '1rem',
                backgroundColor: isRunning ? '#9ca3af' : '#10b981',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: isRunning ? 'not-allowed' : 'pointer',
                fontWeight: '600'
              }}
            >
              {isRunning ? 'Running...' : 'Run Code'}
            </button>
            <button
              onClick={handleReset}
              style={{
                padding: '0.75rem 1.5rem',
                fontSize: '1rem',
                backgroundColor: '#6b7280',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontWeight: '600'
              }}
            >
              Reset
            </button>
           <button
              onClick={openDrawingModal}
              style={{
                padding: '0.75rem 1.5rem',
                fontSize: '1rem',
                fontWeight: '700',
                backgroundColor: currentDrawing ? '#8b5cf6' : '#6366f1',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: currentDrawing ? '0 2px 8px rgba(139, 92, 246, 0.3)' : '0 2px 8px rgba(99, 102, 241, 0.3)'
              }}
            >
              {currentDrawing ? '‚úèÔ∏è Edit Drawing' : 'üé® Draw'}
            </button>
 <button
              onClick={() => setShowExplanation(!showExplanation)}
              style={{
                padding: '0.75rem 1.5rem',
                fontSize: '1rem',
                fontWeight: '700',
                backgroundColor: showExplanation ? '#8b5cf6' : '#f59e0b',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 8px rgba(245, 158, 11, 0.3)'
              }}
            >
              {showExplanation ? '‚úì Explanation Visible' : 'üìñ Explanation & Pseudocode'}
            </button>
            <button
              onClick={() => setShowSolution(!showSolution)}
              style={{
                padding: '0.75rem 1.5rem',
                fontSize: '1rem',
                backgroundColor: '#3b82f6',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontWeight: '600'
              }}
            >
              {showSolution ? 'Hide' : 'Show'} Solution
            </button>
            <div style={{ marginLeft: 'auto' }}>
              <CompletionCheckbox
                problemId={`Queues-${selectedQuestion.id}`}
                label="Mark as Completed"
                onCompletionChange={() => setRefreshKey(prev => prev + 1)}
              />
            </div>
          </div>

            {output && (
              <div style={{ marginBottom: '1.5rem' }}>
                <h3 style={{ fontSize: '1.1rem', marginBottom: '0.5rem', color: '#1f2937' }}>Output</h3>
                <pre style={{
                  backgroundColor: '#1f2937',
                  color: '#f3f4f6',
                  padding: '1rem',
                  borderRadius: '8px',
                  overflow: 'auto',
                  fontSize: '0.9rem',
                  minHeight: '150px'
                }}>
                  {output}
                </pre>
              </div>
            )}

            {showExplanation && (
              <div style={{
                backgroundColor: '#fef3c7',
                padding: '1.5rem',
                borderRadius: '8px',
                border: '2px solid #f59e0b',
                marginBottom: '1.5rem'
              }}>
                <h3 style={{
                  fontSize: '1.2rem',
                  fontWeight: '700',
                  color: '#92400e',
                  marginBottom: '1rem',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.5rem'
                }}>
                  üìñ Explanation
                </h3>
                <div style={{
                  fontSize: '0.95rem',
                  lineHeight: '1.8',
                  color: '#78350f',
                  whiteSpace: 'pre-wrap',
                  marginBottom: '1.5rem'
                }}>
                  {selectedQuestion.explanation}
                </div>

                <div style={{
                  backgroundColor: '#1e293b',
                  padding: '1.5rem',
                  borderRadius: '8px',
                  overflowX: 'auto',
                  marginTop: '1rem'
                }}>
                  <h4 style={{
                    fontSize: '1.1rem',
                    fontWeight: '700',
                    color: '#a78bfa',
                    marginBottom: '1rem',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.5rem'
                  }}>
                    üîß Pseudocode
                  </h4>
                  <pre style={{
                    margin: 0,
                    fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
                    fontSize: '0.9rem',
                    lineHeight: '1.6',
                    color: '#e2e8f0',
                    whiteSpace: 'pre',
                    overflowX: 'auto'
                  }}>
                    {selectedQuestion.pseudocode}
                  </pre>
                </div>
              </div>
            )}

            {showSolution && (
              <div style={{ marginBottom: '1.5rem' }}>
                <h3 style={{ fontSize: '1.1rem', marginBottom: '0.5rem', color: '#059669' }}>Solution</h3>
                <pre style={{
                  backgroundColor: '#f0fdf4',
                  padding: '1rem',
                  borderRadius: '8px',
                  overflow: 'auto',
                  fontSize: '0.85rem',
                  color: '#1f2937',
                  border: '2px solid #86efac'
                }}>
                  {selectedQuestion.solution}
                </pre>
              </div>
            )}
          </div>
        </div>
        </div>
      )}

      {/* Drawing Canvas Modal */}
      <DrawingCanvas
        isOpen={showDrawing}
        onClose={closeDrawingModal}
        problemId={selectedQuestion ? `Queues-${selectedQuestion.id}` : ''}
        existingDrawing={currentDrawing}
      />
    </div>
  )
}

export default Queues
