import { useState, useEffect } from 'react'
import CompletionCheckbox from '../../components/CompletionCheckbox.jsx'
import LanguageToggle from '../../components/LanguageToggle.jsx'
import DrawingCanvas from '../../components/DrawingCanvas.jsx'
import { isProblemCompleted } from '../../services/progressService'
import { getPreferredLanguage } from '../../services/languageService'
import { useKeyboardNavigation } from '../../hooks/useKeyboardNavigation'

function Stacks({ onBack, onPrevious, onNext, previousName, nextName, currentSubcategory, previousSubcategory, nextSubcategory, onPreviousSubcategory, onNextSubcategory }) {
  const [selectedQuestion, setSelectedQuestion] = useState(null)
  const [showSolution, setShowSolution] = useState(false)
  const [showExplanation, setShowExplanation] = useState(false)
  const [userCode, setUserCode] = useState('')
  const [output, setOutput] = useState('')
  const [isRunning, setIsRunning] = useState(false)
  const [refreshKey, setRefreshKey] = useState(0)
  const [language, setLanguage] = useState(getPreferredLanguage())
  const [showDrawing, setShowDrawing] = useState(false)
  const [currentDrawing, setCurrentDrawing] = useState(null)
  const [expandedSections, setExpandedSections] = useState({
    Easy: true,
    Medium: true,
    Hard: true
  })

  // Listen for completion changes
  useEffect(() => {
    const handleProgressUpdate = () => {
      console.log('Progress update event received in Stacks! Incrementing refreshKey')
      setRefreshKey(prev => prev + 1)
    }

    window.addEventListener('progressUpdate', handleProgressUpdate)
    return () => window.removeEventListener('progressUpdate', handleProgressUpdate)
  }, [])

  // Listen for language changes
  useEffect(() => {
    const handleLanguageChange = (e) => {
      setLanguage(e.detail)
      if (selectedQuestion) {
        setUserCode(selectedQuestion.code[e.detail].starterCode)
      }
    }
    window.addEventListener('languageChange', handleLanguageChange)
    return () => window.removeEventListener('languageChange', handleLanguageChange)
  }, [selectedQuestion])

  const questions = [
    {
      id: 1,
      title: 'Valid Parentheses',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/valid-parentheses/',
      description: 'Given a string s containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets and open brackets must be closed in the correct order.',
      code: {
        java: {
          starterCode: `public boolean isValid(String s) {
    // Write your code here

}`,
          solution: `// Approach: Stack - O(n) time, O(n) space
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    Map<Character, Character> pairs = new HashMap<>();
    pairs.put(')', '(');
    pairs.put('}', '{');
    pairs.put(']', '[');

    for (char c : s.toCharArray()) {
        if (pairs.containsKey(c)) {
            // Closing bracket
            if (stack.isEmpty() || stack.pop() != pairs.get(c)) {
                return false;
            }
        } else {
            // Opening bracket
            stack.push(c);
        }
    }

    return stack.isEmpty();
}`
        },
        python: {
          starterCode: `def isValid(self, s: str) -> bool:
    # Write your code here
    pass`,
          solution: `# Approach: Stack - O(n) time, O(n) space
def isValid(self, s: str) -> bool:
    stack = []
    pairs = {
        ')': '(',
        '}': '{',
        ']': '['
    }

    for c in s:
        if c in pairs:
            # Closing bracket
            if not stack or stack.pop() != pairs[c]:
                return False
        else:
            # Opening bracket
            stack.append(c)

    return len(stack) == 0`
        }
      },
      testCases: [
        { s: '()', expected: true },
        { s: '()[]{}', expected: true },
        { s: '(]', expected: false }
      ],
      examples: [
        { input: 's = "()"', output: 'true' },
        { input: 's = "()[]{}"', output: 'true' },
        { input: 's = "(]"', output: 'false' }
      ],
      explanation: `**Problem:** Determine if a string containing only brackets is valid (all brackets properly opened and closed in correct order).

**Key Insight:** Use a stack to match closing brackets with their corresponding opening brackets. Last opened must be first closed (LIFO).

**Approach:**
1. Create a mapping of closing brackets to opening brackets
2. Iterate through string:
   - **Opening bracket** '(', '{', '[': Push to stack
   - **Closing bracket** ')', '}', ']':
     * If stack empty OR top doesn't match: return false
     * Otherwise pop from stack
3. At end, stack must be empty (all brackets matched)

**Why Stack Works:**
- Stack maintains most recently opened bracket at top
- Closing bracket must match most recent opening bracket
- LIFO property of stack perfectly matches bracket nesting rules

**Edge Cases:**
- Empty string: valid (return true)
- Only opening brackets: invalid (stack not empty at end)
- Only closing brackets: invalid (stack empty when trying to match)
- Mismatched types: '([)]' is invalid

**Complexity:** Time O(n), Space O(n) - worst case all opening brackets`,
      pseudocode: `stack = []
pairs = {')': '(', '}': '{', ']': '['}

for c in s:
    if c in pairs:  // Closing bracket
        if stack is empty OR stack.pop() != pairs[c]:
            return false
    else:  // Opening bracket
        stack.push(c)

return stack.isEmpty()

Example 1: s = "()[]{}"
Process '(': push → stack = ['(']
Process ')': pop, matches '(' → stack = []
Process '[': push → stack = ['[']
Process ']': pop, matches '[' → stack = []
Process '{': push → stack = ['{']
Process '}': pop, matches '{' → stack = []
Stack empty → return true

Example 2: s = "(]"
Process '(': push → stack = ['(']
Process ']': pop gives '(', doesn't match '[' → return false

Example 3: s = "([)]"
Process '(': push → stack = ['(']
Process '[': push → stack = ['(', '[']
Process ')': pop gives '[', doesn't match '(' → return false`
    },
    {
      id: 2,
      title: 'Min Stack',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/min-stack/',
      description: 'Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with push(val), pop(), top(), and getMin() methods.',
      code: {
        java: {
          starterCode: `class MinStack {
    public MinStack() {
        // Initialize your data structure here
    }

    public void push(int val) {
        // Write your code here
    }

    public void pop() {
        // Write your code here
    }

    public int top() {
        // Write your code here
    }

    public int getMin() {
        // Write your code here
    }
}`,
          solution: `// Approach: Two Stacks - O(1) for all operations
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {
        int val = stack.pop();
        if (val == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

// Approach 2: Single Stack with pairs
class MinStack {
    private Stack<int[]> stack; // [value, min]

    public MinStack() {
        stack = new Stack<>();
    }

    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(new int[]{val, val});
        } else {
            int currentMin = Math.min(val, stack.peek()[1]);
            stack.push(new int[]{val, currentMin});
        }
    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return stack.peek()[0];
    }

    public int getMin() {
        return stack.peek()[1];
    }
}`
        },
        python: {
          starterCode: `class MinStack:
    def __init__(self):
        # Initialize your data structure here
        pass

    def push(self, val: int) -> None:
        # Write your code here
        pass

    def pop(self) -> None:
        # Write your code here
        pass

    def top(self) -> int:
        # Write your code here
        pass

    def getMin(self) -> int:
        # Write your code here
        pass`,
          solution: `# Approach: Two Stacks - O(1) for all operations
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        val = self.stack.pop()
        if val == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]


# Approach 2: Single Stack with tuples
class MinStack:
    def __init__(self):
        self.stack = []  # [(value, min), ...]

    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append((val, val))
        else:
            current_min = min(val, self.stack[-1][1])
            self.stack.append((val, current_min))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]`
        }
      },
      testCases: [
        { operations: ['MinStack','push','push','push','getMin','pop','top','getMin'], expected: '[null,null,null,null,-3,null,0,-2]' }
      ],
      examples: [
        {
          input: 'Operations: ["MinStack","push","push","push","getMin","pop","top","getMin"]\\nValues: [[],[-2],[0],[-3],[],[],[],[]]',
          output: '[null,null,null,null,-3,null,0,-2]',
          explanation: 'MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3; minStack.pop(); minStack.top(); // return 0; minStack.getMin(); // return -2'
        }
      ],
      explanation: `**Problem:** Design a stack supporting push, pop, top, and getMin in O(1) time.

**Key Insight:** Track the minimum value at each state. Use either two stacks or store pairs (value, min) in one stack.

**Approach 1: Two Stacks**
1. **Main stack**: stores all values normally
2. **Min stack**: stores minimum values
   - Push to min stack only when value ≤ current minimum
   - Pop from min stack only when popped value equals min stack top
3. getMin() simply returns min stack top

**Why This Works:**
- Min stack top always represents minimum of main stack
- When we pop the minimum, min stack also pops to reveal previous minimum
- Saves space: min stack only stores values that are new minimums

**Approach 2: Single Stack with Pairs**
1. Each element stores (value, currentMin)
2. When pushing: currentMin = min(value, previous min)
3. getMin() returns the min from top pair

**Trade-offs:**
- Two stacks: More space efficient, slightly complex pop logic
- Single stack: Simpler logic, more space (stores min for every element)

**Complexity:** All operations O(1) time, O(n) space`,
      pseudocode: `Two Stacks Approach:
-----------------------
class MinStack:
    stack = []
    minStack = []

    push(val):
        stack.push(val)
        if minStack.isEmpty() OR val <= minStack.top():
            minStack.push(val)

    pop():
        val = stack.pop()
        if val == minStack.top():
            minStack.pop()

    top():
        return stack.top()

    getMin():
        return minStack.top()

Example: push(-2), push(0), push(-3)
After push(-2):
    stack = [-2]
    minStack = [-2]

After push(0):
    stack = [-2, 0]
    minStack = [-2]  (0 > -2, don't push)

After push(-3):
    stack = [-2, 0, -3]
    minStack = [-2, -3]  (-3 <= -2, push)

getMin() → -3 (minStack.top())
pop() → -3, minStack.pop() too
getMin() → -2 (minStack.top())

Single Stack with Pairs:
-----------------------
class MinStack:
    stack = []  // [(value, min), ...]

    push(val):
        if stack.isEmpty():
            stack.push((val, val))
        else:
            currentMin = min(val, stack.top().min)
            stack.push((val, currentMin))

    getMin():
        return stack.top().min`
    },
    {
      id: 3,
      title: 'Daily Temperatures',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/daily-temperatures/',
      description: 'Given an array of integers temperatures representing daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0.',
      code: {
        java: {
          starterCode: `public int[] dailyTemperatures(int[] temperatures) {
    // Write your code here

}`,
          solution: `// Approach: Monotonic Stack - O(n) time, O(n) space
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] result = new int[n];
    Stack<Integer> stack = new Stack<>(); // stores indices

    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int prevIndex = stack.pop();
            result[prevIndex] = i - prevIndex;
        }
        stack.push(i);
    }

    return result;
}`
        },
        python: {
          starterCode: `def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
    # Write your code here
    pass`,
          solution: `# Approach: Monotonic Stack - O(n) time, O(n) space
def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
    n = len(temperatures)
    result = [0] * n
    stack = []  # stores indices

    for i in range(n):
        while stack and temperatures[i] > temperatures[stack[-1]]:
            prev_index = stack.pop()
            result[prev_index] = i - prev_index
        stack.append(i)

    return result`
        }
      },
      testCases: [
        { temperatures: [73,74,75,71,69,72,76,73], expected: [1,1,4,2,1,1,0,0] },
        { temperatures: [30,40,50,60], expected: [1,1,1,0] },
        { temperatures: [30,60,90], expected: [1,1,0] }
      ],
      examples: [
        { input: 'temperatures = [73,74,75,71,69,72,76,73]', output: '[1,1,4,2,1,1,0,0]' },
        { input: 'temperatures = [30,40,50,60]', output: '[1,1,1,0]' },
        { input: 'temperatures = [30,60,90]', output: '[1,1,0]' }
      ],
      explanation: `**Problem:** For each day, find how many days until a warmer temperature. Return 0 if no warmer day exists.

**Key Insight:** Use a monotonic decreasing stack to track indices of days waiting for warmer temperatures. When we find a warmer day, we can resolve all previous colder days.

**Approach: Monotonic Stack**
1. Create stack to store indices (not temperatures!)
2. For each day i:
   - While stack not empty AND current temp > temp[stack.top()]:
     * Found answer for day at stack.top()
     * result[stack.top()] = i - stack.top()
     * Pop from stack
   - Push current index i to stack
3. Remaining indices in stack have no warmer day (keep 0)

**Why Monotonic Stack?**
- Stack maintains decreasing temperatures from bottom to top
- When we see a warmer temperature, it resolves all colder temps in stack
- We only visit each element once → O(n) time
- Each element pushed and popped at most once

**Example:** [73,74,75,71,69,72,76,73]
- Day 0 (73): stack = [0]
- Day 1 (74 > 73): resolve day 0 → result[0] = 1-0 = 1, stack = [1]
- Day 2 (75 > 74): resolve day 1 → result[1] = 2-1 = 1, stack = [2]
- Day 3 (71 < 75): stack = [2,3]
- Day 4 (69 < 71): stack = [2,3,4]
- Day 5 (72): resolves days 4,3 → result[4]=1, result[3]=2, stack = [2,5]
- Day 6 (76): resolves all → result[5]=1, result[2]=4, stack = [6]
- Day 7 (73 < 76): stack = [6,7], no warmer day → result[6]=0, result[7]=0

**Complexity:** Time O(n), Space O(n)`,
      pseudocode: `result = array of size n, initialized to 0
stack = []  // stores indices

for i from 0 to n-1:
    while stack not empty AND temperatures[i] > temperatures[stack.top()]:
        prevIndex = stack.pop()
        result[prevIndex] = i - prevIndex
    stack.push(i)

return result

Detailed Example: [73,74,75,71,69,72,76,73]
Initial: result = [0,0,0,0,0,0,0,0], stack = []

i=0, temp=73: stack = [0]
i=1, temp=74 > 73:
    pop 0, result[0] = 1-0 = 1
    stack = [1]
i=2, temp=75 > 74:
    pop 1, result[1] = 2-1 = 1
    stack = [2]
i=3, temp=71 < 75: stack = [2, 3]
i=4, temp=69 < 71: stack = [2, 3, 4]
i=5, temp=72:
    72 > 69: pop 4, result[4] = 5-4 = 1
    72 > 71: pop 3, result[3] = 5-3 = 2
    72 < 75: stop
    stack = [2, 5]
i=6, temp=76:
    76 > 72: pop 5, result[5] = 6-5 = 1
    76 > 75: pop 2, result[2] = 6-2 = 4
    stack = [6]
i=7, temp=73 < 76: stack = [6, 7]

Final result: [1,1,4,2,1,1,0,0]`
    },
    {
      id: 4,
      title: 'Evaluate Reverse Polish Notation',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/evaluate-reverse-polish-notation/',
      description: 'You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation. Evaluate the expression and return an integer that represents the value of the expression.',
      code: {
        java: {
          starterCode: `public int evalRPN(String[] tokens) {
    // Write your code here

}`,
          solution: `// Approach: Stack - O(n) time, O(n) space
public int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    Set<String> operators = new HashSet<>(Arrays.asList("+", "-", "*", "/"));

    for (String token : tokens) {
        if (!operators.contains(token)) {
            stack.push(Integer.parseInt(token));
        } else {
            int b = stack.pop();
            int a = stack.pop();

            switch (token) {
                case "+":
                    stack.push(a + b);
                    break;
                case "-":
                    stack.push(a - b);
                    break;
                case "*":
                    stack.push(a * b);
                    break;
                case "/":
                    stack.push(a / b);
                    break;
            }
        }
    }

    return stack.pop();
}`
        },
        python: {
          starterCode: `def evalRPN(self, tokens: List[str]) -> int:
    # Write your code here
    pass`,
          solution: `# Approach: Stack - O(n) time, O(n) space
def evalRPN(self, tokens: List[str]) -> int:
    stack = []
    operators = {'+', '-', '*', '/'}

    for token in tokens:
        if token not in operators:
            stack.append(int(token))
        else:
            b = stack.pop()
            a = stack.pop()

            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                # Python division truncates toward negative infinity
                # Use int(a / b) to truncate toward zero like Java
                stack.append(int(a / b))

    return stack.pop()`
        }
      },
      testCases: [
        { tokens: ['2','1','+','3','*'], expected: 9 },
        { tokens: ['4','13','5','/','+'], expected: 6 },
        { tokens: ['10','6','9','3','+','-11','*','/','*','17','+','5','+'], expected: 22 }
      ],
      examples: [
        { input: 'tokens = ["2","1","+","3","*"]', output: '9', explanation: '((2 + 1) * 3) = 9' },
        { input: 'tokens = ["4","13","5","/","+"]', output: '6', explanation: '(4 + (13 / 5)) = 6' }
      ],
      explanation: `**Problem:** Evaluate an arithmetic expression in Reverse Polish Notation (RPN). In RPN, operators come after operands.

**Key Insight:** RPN is naturally solved with a stack. Push numbers, pop two operands when you see an operator, push result back.

**What is RPN?**
- Normal (infix): (2 + 1) * 3
- RPN (postfix): 2 1 + 3 *
- Operators come after operands: "2 1 +" means "2 + 1"

**Algorithm:**
1. Iterate through tokens:
   - **Number**: Push to stack
   - **Operator** (+, -, *, /):
     * Pop two operands: b = pop(), a = pop()
     * **Order matters!** a is first operand, b is second
     * Compute: a operator b
     * Push result back to stack
2. Final answer is the only element left in stack

**Why Stack?**
- RPN processes innermost operations first
- Stack holds intermediate results
- When we see operator, top two stack elements are ready operands

**Critical Detail - Operand Order:**
- For + and *: order doesn't matter (commutative)
- For - and /: ORDER MATTERS!
- Pop gives b first, then a: compute a - b, NOT b - a

**Example:** ["2","1","+","3","*"]
- Push 2: stack = [2]
- Push 1: stack = [2, 1]
- See '+': pop 1, pop 2, compute 2+1=3, push 3 → stack = [3]
- Push 3: stack = [3, 3]
- See '*': pop 3, pop 3, compute 3*3=9, push 9 → stack = [9]
- Result: 9

**Complexity:** Time O(n), Space O(n)`,
      pseudocode: `stack = []
operators = {'+', '-', '*', '/'}

for token in tokens:
    if token not in operators:
        stack.push(int(token))
    else:
        b = stack.pop()  // Second operand
        a = stack.pop()  // First operand

        if token == '+':
            stack.push(a + b)
        elif token == '-':
            stack.push(a - b)  // NOT b - a!
        elif token == '*':
            stack.push(a * b)
        elif token == '/':
            stack.push(int(a / b))  // Truncate toward zero

return stack.pop()

Example 1: ["2","1","+","3","*"]
Push 2: [2]
Push 1: [2, 1]
'+': pop 1, pop 2 → 2+1=3, push 3 → [3]
Push 3: [3, 3]
'*': pop 3, pop 3 → 3*3=9, push 9 → [9]
Result: 9

Example 2: ["4","13","5","/","+"]
Push 4: [4]
Push 13: [4, 13]
Push 5: [4, 13, 5]
'/': pop 5, pop 13 → 13/5=2, push 2 → [4, 2]
'+': pop 2, pop 4 → 4+2=6, push 6 → [6]
Result: 6

Example 3: ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
[10]
[10, 6]
[10, 6, 9]
[10, 6, 9, 3]
'+': 9+3=12 → [10, 6, 12]
[10, 6, 12, -11]
'*': 12*(-11)=-132 → [10, 6, -132]
'/': 6/(-132)=0 → [10, 0]
'*': 10*0=0 → [0]
[0, 17]
'+': 0+17=17 → [17]
[17, 5]
'+': 17+5=22 → [22]
Result: 22`
    },
    {
      id: 5,
      title: 'Simplify Path',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/simplify-path/',
      description: 'Given an absolute path for a Unix-style file system, which begins with a slash \'/\', transform this path into its simplified canonical path. In Unix-style file system context, a single period \'.\' signifies the current directory, a double period \".." denotes moving up one directory level, and multiple slashes such as "//" are interpreted as a single slash. In this problem, treat sequences of periods not covered by the previous rules (like \"...\") as valid names for files or directories.',
      code: {
        java: {
          starterCode: `public String simplifyPath(String path) {
    // Write your code here

}`,
          solution: `// Approach: Stack - O(n) time, O(n) space
public String simplifyPath(String path) {
    Stack<String> stack = new Stack<>();
    String[] parts = path.split("/");

    for (String part : parts) {
        // Skip empty strings and current directory markers
        if (part.equals("") || part.equals(".")) {
            continue;
        }
        // Go up one directory if possible
        else if (part.equals("..")) {
            if (!stack.isEmpty()) {
                stack.pop();
            }
        }
        // Valid directory or file name
        else {
            stack.push(part);
        }
    }

    // Build the simplified path
    StringBuilder result = new StringBuilder();
    for (String dir : stack) {
        result.append("/").append(dir);
    }

    // Return "/" if stack is empty, otherwise return the built path
    return result.length() > 0 ? result.toString() : "/";
}

// Alternative: Using Deque for better performance
public String simplifyPath(String path) {
    Deque<String> deque = new ArrayDeque<>();
    String[] parts = path.split("/");

    for (String part : parts) {
        if (part.equals("..")) {
            if (!deque.isEmpty()) {
                deque.pollLast();
            }
        } else if (!part.isEmpty() && !part.equals(".")) {
            deque.offerLast(part);
        }
    }

    return "/" + String.join("/", deque);
}`
        },
        python: {
          starterCode: `def simplifyPath(self, path: str) -> str:
    # Write your code here
    pass`,
          solution: `# Approach: Stack - O(n) time, O(n) space
def simplifyPath(self, path: str) -> str:
    stack = []
    parts = path.split('/')

    for part in parts:
        # Skip empty strings and current directory markers
        if part == '' or part == '.':
            continue
        # Go up one directory if possible
        elif part == '..':
            if stack:
                stack.pop()
        # Valid directory or file name
        else:
            stack.append(part)

    # Build the simplified path
    return '/' + '/'.join(stack)

# Alternative: More concise using list comprehension
def simplifyPath(self, path: str) -> str:
    stack = []

    for part in path.split('/'):
        if part == '..':
            if stack:
                stack.pop()
        elif part and part != '.':
            stack.append(part)

    return '/' + '/'.join(stack)`
        }
      },
      testCases: [
        { path: '/home/', expected: '/home' },
        { path: '/home//foo/', expected: '/home/foo' },
        { path: '/home/user/Documents/../Pictures', expected: '/home/user/Pictures' },
        { path: '/../', expected: '/' },
        { path: '/.../a/../b/c/../d/./', expected: '/.../b/d' }
      ],
      examples: [
        { input: 'path = "/home/"', output: '"/home"', explanation: 'Trailing slash is removed.' },
        { input: 'path = "/home//foo/"', output: '"/home/foo"', explanation: 'Multiple consecutive slashes are replaced by a single one.' },
        { input: 'path = "/home/user/Documents/../Pictures"', output: '"/home/user/Pictures"', explanation: '".." moves up one directory level from Documents to user.' },
        { input: 'path = "/../"', output: '"/"', explanation: 'Going one level up from the root directory is not possible.' }
      ],
      explanation: `**Problem:** Convert an absolute Unix path to its simplified canonical form, handling ".", "..", and multiple slashes.

**Key Insight:** Use a stack to track directory names. Push valid names, pop when seeing "..", and ignore "." and empty strings.

**Path Components:**
- **"."**: Current directory (ignore)
- **".."**: Parent directory (pop from stack)
- **""**: Empty from consecutive slashes like "//" (ignore)
- **Valid name**: Any other string (push to stack)
- **"..."**: Valid directory name (not a special marker, push to stack)

**Algorithm:**
1. Split path by "/" to get all components
2. Process each component:
   - **Empty or "."**: Skip (continue)
   - **".."**: Go up one level (pop from stack if not empty)
   - **Any other string**: Valid directory name (push to stack)
3. Join stack elements with "/" and prepend "/"
4. If stack is empty, return "/"

**Why Stack?**
- Stack maintains current path from root
- ".." operation is naturally a pop
- Final path is stack contents joined with "/"

**Edge Cases:**
- Multiple slashes "//": split creates empty strings, we ignore them
- ".." at root: stack is empty, can't pop (ignore)
- Trailing slash: removed automatically
- "..." or "....": Valid names, not special markers

**Example:** "/a/./b/../../c/"
- Split: ["", "a", ".", "b", "..", "..", "c", ""]
- Process "": skip
- Process "a": push → stack = ["a"]
- Process ".": skip → stack = ["a"]
- Process "b": push → stack = ["a", "b"]
- Process "..": pop → stack = ["a"]
- Process "..": pop → stack = []
- Process "c": push → stack = ["c"]
- Process "": skip
- Result: "/c"

**Complexity:** Time O(n), Space O(n) where n is path length`,
      pseudocode: `stack = []
parts = path.split('/')

for part in parts:
    if part == '' or part == '.':
        // Ignore empty strings and current directory
        continue
    elif part == '..':
        // Go up one directory
        if stack is not empty:
            stack.pop()
    else:
        // Valid directory or file name
        stack.push(part)

// Build result: "/" + join all parts with "/"
if stack is empty:
    return "/"
else:
    return "/" + "/".join(stack)

Example 1: path = "/home/"
Split: ["", "home", ""]
Process "": skip
Process "home": push → ["home"]
Process "": skip
Result: "/home"

Example 2: path = "/a/./b/../../c/"
Split: ["", "a", ".", "b", "..", "..", "c", ""]
"": skip → []
"a": push → ["a"]
".": skip → ["a"]
"b": push → ["a", "b"]
"..": pop → ["a"]
"..": pop → []
"c": push → ["c"]
"": skip → ["c"]
Result: "/c"

Example 3: path = "/.../a/../b/c/../d/./"
Split: ["", "...", "a", "..", "b", "c", "..", "d", ".", ""]
"": skip → []
"...": push → ["..."]  // Valid name, not ".."!
"a": push → ["...", "a"]
"..": pop → ["..."]
"b": push → ["...", "b"]
"c": push → ["...", "b", "c"]
"..": pop → ["...", "b"]
"d": push → ["...", "b", "d"]
".": skip → ["...", "b", "d"]
"": skip → ["...", "b", "d"]
Result: "/.../b/d"`
    },
    {
      id: 6,
      title: 'Basic Calculator',
      difficulty: 'Hard',
      leetcodeUrl: 'https://leetcode.com/problems/basic-calculator/',
      description: 'Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). The expression string may contain open \'(\' and closing parentheses \')\', the plus \'+\' or minus sign \'-\', non-negative integers and empty spaces.',
      code: {
        java: {
          starterCode: `public int calculate(String s) {
    // Write your code here

}`,
          solution: `// Approach: Stack with Sign Tracking - O(n) time, O(n) space
public int calculate(String s) {
    Stack<Integer> stack = new Stack<>();
    int result = 0;       // Current result
    int number = 0;       // Current number being formed
    int sign = 1;         // Current sign: +1 or -1

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);

        if (Character.isDigit(c)) {
            // Build multi-digit number
            number = number * 10 + (c - '0');
        }
        else if (c == '+') {
            // Add current number with its sign to result
            result += sign * number;
            number = 0;
            sign = 1;  // Next number is positive
        }
        else if (c == '-') {
            // Add current number with its sign to result
            result += sign * number;
            number = 0;
            sign = -1;  // Next number is negative
        }
        else if (c == '(') {
            // Save current result and sign to stack
            stack.push(result);
            stack.push(sign);
            // Reset for new sub-expression
            result = 0;
            sign = 1;
        }
        else if (c == ')') {
            // Complete current number
            result += sign * number;
            number = 0;
            // Pop sign and previous result
            result *= stack.pop();  // Apply sign before parenthesis
            result += stack.pop();  // Add result before parenthesis
        }
        // Ignore spaces
    }

    // Add the last number
    result += sign * number;

    return result;
}

// Alternative: More detailed with comments
public int calculate(String s) {
    if (s == null || s.length() == 0) return 0;

    Stack<Integer> stack = new Stack<>();
    int result = 0;
    int number = 0;
    int sign = 1;

    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            number = number * 10 + (c - '0');
        } else if (c == '+') {
            result += sign * number;
            sign = 1;
            number = 0;
        } else if (c == '-') {
            result += sign * number;
            sign = -1;
            number = 0;
        } else if (c == '(') {
            // Push result and sign onto stack
            stack.push(result);
            stack.push(sign);
            // Reset for sub-expression
            result = 0;
            sign = 1;
        } else if (c == ')') {
            result += sign * number;
            number = 0;
            // Pop sign, then previous result
            int prevSign = stack.pop();
            int prevResult = stack.pop();
            result = prevResult + prevSign * result;
        }
    }

    if (number != 0) {
        result += sign * number;
    }

    return result;
}`
        },
        python: {
          starterCode: `def calculate(self, s: str) -> int:
    # Write your code here
    pass`,
          solution: `# Approach: Stack with Sign Tracking - O(n) time, O(n) space
def calculate(self, s: str) -> int:
    stack = []
    result = 0      # Current result
    number = 0      # Current number being formed
    sign = 1        # Current sign: +1 or -1

    for c in s:
        if c.isdigit():
            # Build multi-digit number
            number = number * 10 + int(c)
        elif c == '+':
            # Add current number with its sign to result
            result += sign * number
            number = 0
            sign = 1  # Next number is positive
        elif c == '-':
            # Add current number with its sign to result
            result += sign * number
            number = 0
            sign = -1  # Next number is negative
        elif c == '(':
            # Save current result and sign to stack
            stack.append(result)
            stack.append(sign)
            # Reset for new sub-expression
            result = 0
            sign = 1
        elif c == ')':
            # Complete current number
            result += sign * number
            number = 0
            # Pop sign and previous result
            result *= stack.pop()  # Apply sign before parenthesis
            result += stack.pop()  # Add result before parenthesis
        # Ignore spaces

    # Add the last number
    result += sign * number

    return result

# Alternative: Cleaner version
def calculate(self, s: str) -> int:
    stack = []
    operand = 0
    result = 0
    sign = 1

    for ch in s:
        if ch.isdigit():
            operand = operand * 10 + int(ch)
        elif ch in ['+', '-']:
            result += sign * operand
            sign = 1 if ch == '+' else -1
            operand = 0
        elif ch == '(':
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif ch == ')':
            result += sign * operand
            result *= stack.pop()
            result += stack.pop()
            operand = 0

    return result + sign * operand`
        }
      },
      testCases: [
        { s: '1 + 1', expected: 2 },
        { s: ' 2-1 + 2 ', expected: 3 },
        { s: '(1+(4+5+2)-3)+(6+8)', expected: 23 },
        { s: '2147483647', expected: 2147483647 }
      ],
      examples: [
        { input: 's = "1 + 1"', output: '2' },
        { input: 's = " 2-1 + 2 "', output: '3' },
        { input: 's = "(1+(4+5+2)-3)+(6+8)"', output: '23' }
      ],
      explanation: `**Problem:** Evaluate a mathematical expression with +, -, parentheses, and spaces. Return the integer result.

**Key Insight:** Use a stack to handle parentheses. Track current result, current number, and current sign. When seeing '(', save context to stack. When seeing ')', restore context and apply.

**Core Variables:**
- **result**: Running total of current expression level
- **number**: Current number being formed (multi-digit)
- **sign**: Sign (+1 or -1) to apply to current number
- **stack**: Stores (result, sign) pairs when entering parentheses

**Algorithm:**
1. Iterate through each character:
   - **Digit**: Build multi-digit number → number = number * 10 + digit
   - **'+'**: Add current number to result → result += sign * number, reset number, set sign = +1
   - **'-'**: Add current number to result → result += sign * number, reset number, set sign = -1
   - **'('**: Save state → push result and sign to stack, reset result and sign
   - **')'**: Complete sub-expression → result += sign * number, then apply saved context:
     * result *= stack.pop() (apply sign before parenthesis)
     * result += stack.pop() (add result before parenthesis)
   - **Space**: Ignore
2. After loop: Add final number → result += sign * number

**Why This Works:**
- Stack stores context when entering parentheses
- Each '(' creates a new level, ')' completes it
- Sign tracking handles subtraction elegantly
- Number building handles multi-digit numbers

**Example:** "(1+(4+5+2)-3)+(6+8)"
Initial: result=0, number=0, sign=1, stack=[]

'(': push 0, 1 → stack=[0,1], result=0, sign=1
'1': number=1
'+': result += 1*1=1, sign=1, number=0
'(': push 1, 1 → stack=[0,1,1,1], result=0, sign=1
'4': number=4
'+': result += 1*4=4, sign=1, number=0
'5': number=5
'+': result += 1*5=9, sign=1, number=0
'2': number=2
')': result += 1*2=11, result *= pop()=11*1=11, result += pop()=11+1=12
     stack=[0,1], result=12, number=0
'-': result += 1*0=12, sign=-1, number=0
'3': number=3
')': result += -1*3=9, result *= pop()=9*1=9, result += pop()=9+0=9
     stack=[], result=9, number=0
'+': result += 1*0=9, sign=1, number=0
'(': push 9, 1 → stack=[9,1], result=0, sign=1
'6': number=6
'+': result += 1*6=6, sign=1, number=0
'8': number=8
')': result += 1*8=14, result *= pop()=14*1=14, result += pop()=14+9=23
     stack=[], result=23, number=0

Final: result + sign * number = 23 + 1*0 = 23

**Complexity:** Time O(n), Space O(n) for stack`,
      pseudocode: `stack = []
result = 0      // Current running total
number = 0      // Current number being built
sign = 1        // Current sign: +1 or -1

for c in s:
    if c is digit:
        number = number * 10 + int(c)

    elif c == '+':
        result += sign * number
        sign = 1
        number = 0

    elif c == '-':
        result += sign * number
        sign = -1
        number = 0

    elif c == '(':
        // Save current state
        stack.push(result)
        stack.push(sign)
        // Reset for sub-expression
        result = 0
        sign = 1

    elif c == ')':
        // Complete current number
        result += sign * number
        number = 0
        // Restore previous state
        prevSign = stack.pop()
        prevResult = stack.pop()
        result = prevResult + prevSign * result

    // Ignore spaces

// Don't forget the last number!
result += sign * number

return result

Example: "2-(5-6)"
Initial: result=0, number=0, sign=1, stack=[]

'2': number=2
'-': result=0+1*2=2, sign=-1, number=0
'(': stack=[2,-1], result=0, sign=1
'5': number=5
'-': result=0+1*5=5, sign=-1, number=0
'6': number=6
')': result=5+(-1)*6=-1
     prevSign=stack.pop()=-1
     prevResult=stack.pop()=2
     result=2+(-1)*(-1)=2+1=3
Final: 3+(-1)*0=3

Trace: "1+2"
'1': number=1
'+': result=0+1*1=1, sign=1, number=0
'2': number=2
End: result=1+1*2=3

Trace: "(1)"
'(': stack=[0,1], result=0, sign=1
'1': number=1
')': result=0+1*1=1
     result=1*1=1
     result=1+0=1
End: 1+1*0=1`
    },
    {
      id: 7,
      title: '907. Sum of Subarray Minimums',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/sum-of-subarray-minimums/',
      description: 'Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 10^9 + 7.',
      code: {
        java: {
          starterCode: `public int sumSubarrayMins(int[] arr) {
    // Write your code here

}`,
          solution: `// Approach 1: Monotonic Stack - O(n) time, O(n) space
public int sumSubarrayMins(int[] arr) {
    int MOD = 1_000_000_007;
    int n = arr.length;

    // Arrays to store previous and next smaller element distances
    int[] prevSmaller = new int[n]; // Distance to previous smaller element
    int[] nextSmaller = new int[n]; // Distance to next smaller element

    // Initialize with default values (distance to array boundaries)
    Arrays.fill(prevSmaller, -1);
    Arrays.fill(nextSmaller, n);

    // Find previous smaller element using monotonic increasing stack
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
            stack.pop();
        }
        prevSmaller[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(i);
    }

    // Find next smaller element using monotonic increasing stack
    stack.clear();
    for (int i = n - 1; i >= 0; i--) {
        while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
            stack.pop();
        }
        nextSmaller[i] = stack.isEmpty() ? n : stack.peek();
        stack.push(i);
    }

    // Calculate sum of minimums
    long result = 0;
    for (int i = 0; i < n; i++) {
        // Number of subarrays where arr[i] is minimum
        long left = i - prevSmaller[i];   // Subarrays extending left
        long right = nextSmaller[i] - i;  // Subarrays extending right
        long count = left * right;        // Total subarrays with arr[i] as min

        result = (result + arr[i] * count) % MOD;
    }

    return (int) result;
}

// Approach 2: One-Pass Monotonic Stack - O(n) time, O(n) space
public int sumSubarrayMins2(int[] arr) {
    int MOD = 1_000_000_007;
    int n = arr.length;
    Stack<Integer> stack = new Stack<>();
    long result = 0;

    for (int i = 0; i <= n; i++) {
        // Use 0 as sentinel value to pop all remaining elements
        int currValue = (i == n) ? 0 : arr[i];

        while (!stack.isEmpty() && arr[stack.peek()] > currValue) {
            int idx = stack.pop();
            int left = stack.isEmpty() ? idx + 1 : idx - stack.peek();
            int right = i - idx;
            result = (result + (long) arr[idx] * left * right) % MOD;
        }
        stack.push(i);
    }

    return (int) result;
}`
        },
        python: {
          starterCode: `def sumSubarrayMins(arr: List[int]) -> int:
    # Write your code here
    pass`,
          solution: `# Approach 1: Monotonic Stack - O(n) time, O(n) space
def sumSubarrayMins(arr: List[int]) -> int:
    MOD = 10**9 + 7
    n = len(arr)

    # Arrays to store distances to previous/next smaller elements
    prev_smaller = [-1] * n
    next_smaller = [n] * n

    # Find previous smaller element using monotonic stack
    stack = []
    for i in range(n):
        while stack and arr[stack[-1]] > arr[i]:
            stack.pop()
        prev_smaller[i] = stack[-1] if stack else -1
        stack.append(i)

    # Find next smaller element using monotonic stack
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] >= arr[i]:
            stack.pop()
        next_smaller[i] = stack[-1] if stack else n
        stack.append(i)

    # Calculate sum of minimums
    result = 0
    for i in range(n):
        # Count subarrays where arr[i] is minimum
        left = i - prev_smaller[i]
        right = next_smaller[i] - i
        count = left * right
        result = (result + arr[i] * count) % MOD

    return result

# Approach 2: One-Pass Monotonic Stack
def sumSubarrayMins2(arr: List[int]) -> int:
    MOD = 10**9 + 7
    stack = []
    result = 0

    for i in range(len(arr) + 1):
        curr = 0 if i == len(arr) else arr[i]

        while stack and arr[stack[-1]] > curr:
            idx = stack.pop()
            left = idx - stack[-1] if stack else idx + 1
            right = i - idx
            result = (result + arr[idx] * left * right) % MOD

        stack.append(i)

    return result`
        }
      },
      explanation: `**Problem Understanding:**
For each subarray, find its minimum element and sum all these minimums. The key insight is that we don't need to generate all subarrays - we can count how many subarrays have each element as their minimum.

**Key Insights:**
1. For each element arr[i], count how many subarrays have it as minimum
2. Use monotonic increasing stack to find previous/next smaller elements
3. Number of subarrays = (distance to prev smaller) × (distance to next smaller)
4. Contribution of arr[i] = arr[i] × (number of subarrays)

**Approaches:**

**Approach 1: Two-Pass Monotonic Stack**
- Time: O(n) - Two linear passes
- Space: O(n) - Arrays and stack
- Find previous smaller element for each index
- Find next smaller element for each index
- Calculate contribution of each element

**Approach 2: One-Pass Monotonic Stack**
- Time: O(n) - Single pass
- Space: O(n) - Stack only
- Process elements and calculate contributions on-the-fly
- Pop when current element is smaller than stack top

**Edge Cases:**
- Single element array
- All elements same
- Strictly increasing/decreasing array
- Result overflow (use MOD)`,
      pseudocode: `ALGORITHM SumSubarrayMins(arr):
    MOD = 10^9 + 7
    n = length(arr)

    // Find previous smaller element distances
    prevSmaller = array of size n, initialized to -1
    stack = empty stack

    FOR i = 0 TO n-1:
        WHILE stack not empty AND arr[stack.top] > arr[i]:
            stack.pop()
        prevSmaller[i] = stack.top if not empty else -1
        stack.push(i)

    // Find next smaller element distances
    nextSmaller = array of size n, initialized to n
    stack = empty stack

    FOR i = n-1 DOWN TO 0:
        WHILE stack not empty AND arr[stack.top] >= arr[i]:
            stack.pop()
        nextSmaller[i] = stack.top if not empty else n
        stack.push(i)

    // Calculate sum
    result = 0
    FOR i = 0 TO n-1:
        left = i - prevSmaller[i]
        right = nextSmaller[i] - i
        count = left * right
        result = (result + arr[i] * count) % MOD

    RETURN result

KEY INSIGHT:
For element at index i:
- left = number of elements to left where arr[i] is minimum
- right = number of elements to right where arr[i] is minimum
- Total subarrays with arr[i] as min = left × right
- Contribution = arr[i] × left × right

Example: arr = [3,1,2,4]
For arr[1]=1 (index 1):
- prevSmaller[1] = -1 (no smaller on left)
- nextSmaller[1] = 4 (no smaller on right)
- left = 1 - (-1) = 2 (subarrays: [3,1], [1])
- right = 4 - 1 = 3 (subarrays: [1], [1,2], [1,2,4])
- count = 2 × 3 = 6 subarrays have 1 as minimum
- contribution = 1 × 6 = 6

TIME COMPLEXITY: O(n) - Each element pushed/popped once
SPACE COMPLEXITY: O(n) - Arrays and stack`,
      trace: `Example: arr = [3,1,2,4]

Step 1: Find Previous Smaller
i=0: arr[0]=3, stack=[], prevSmaller[0]=-1, stack=[0]
i=1: arr[1]=1, pop 0, prevSmaller[1]=-1, stack=[1]
i=2: arr[2]=2, stack=[1], prevSmaller[2]=1, stack=[1,2]
i=3: arr[3]=4, stack=[1,2], prevSmaller[3]=2, stack=[1,2,3]
Result: prevSmaller = [-1,-1,1,2]

Step 2: Find Next Smaller
i=3: arr[3]=4, stack=[], nextSmaller[3]=4, stack=[3]
i=2: arr[2]=2, pop 3, nextSmaller[2]=4, stack=[2]
i=1: arr[1]=1, stack=[2], nextSmaller[1]=4, stack=[1,2]
i=0: arr[0]=3, pop 2,1, nextSmaller[0]=1, stack=[0,1]
Result: nextSmaller = [1,4,4,4]

Step 3: Calculate Sum
i=0: arr[0]=3
  left=0-(-1)=1, right=1-0=1, count=1×1=1
  contribution=3×1=3

i=1: arr[1]=1
  left=1-(-1)=2, right=4-1=3, count=2×3=6
  contribution=1×6=6

i=2: arr[2]=2
  left=2-1=1, right=4-2=2, count=1×2=2
  contribution=2×2=4

i=3: arr[3]=4
  left=3-2=1, right=4-3=1, count=1×1=1
  contribution=4×1=4

Total: 3+6+4+4 = 17

Verification - All subarrays:
[3]: min=3
[3,1]: min=1
[3,1,2]: min=1
[3,1,2,4]: min=1
[1]: min=1
[1,2]: min=1
[1,2,4]: min=1
[2]: min=2
[2,4]: min=2
[4]: min=4
Sum: 3+1+1+1+1+1+1+2+2+4 = 17 ✓`
    },
    {
      id: 8,
      title: '496. Next Greater Element I',
      difficulty: 'Easy',
      leetcodeUrl: 'https://leetcode.com/problems/next-greater-element-i/',
      description: 'The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.',
      code: {
        java: {
          starterCode: `public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    // Write your code here

}`,
          solution: `// Monotonic Stack + HashMap - O(n + m) time, O(n) space
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    // Step 1: Build next greater element map for nums2
    Map<Integer, Integer> nextGreater = new HashMap<>();
    Stack<Integer> stack = new Stack<>();

    // Process nums2 from right to left
    for (int i = nums2.length - 1; i >= 0; i--) {
        int num = nums2[i];

        // Pop smaller or equal elements (they can't be next greater)
        while (!stack.isEmpty() && stack.peek() <= num) {
            stack.pop();
        }

        // Top of stack is next greater element (or -1 if empty)
        nextGreater.put(num, stack.isEmpty() ? -1 : stack.peek());

        // Push current number for future elements
        stack.push(num);
    }

    // Step 2: Build result array using the map
    int[] result = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        result[i] = nextGreater.get(nums1[i]);
    }

    return result;
}

// Alternative: Left-to-right approach
public int[] nextGreaterElement2(int[] nums1, int[] nums2) {
    Map<Integer, Integer> nextGreater = new HashMap<>();
    Stack<Integer> stack = new Stack<>();

    // Process nums2 from left to right
    for (int num : nums2) {
        // Current num is next greater for all smaller elements in stack
        while (!stack.isEmpty() && stack.peek() < num) {
            nextGreater.put(stack.pop(), num);
        }
        stack.push(num);
    }

    // Remaining elements in stack have no next greater
    while (!stack.isEmpty()) {
        nextGreater.put(stack.pop(), -1);
    }

    // Build result
    int[] result = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        result[i] = nextGreater.get(nums1[i]);
    }

    return result;
}`
        },
        python: {
          starterCode: `def nextGreaterElement(nums1: List[int], nums2: List[int]) -> List[int]:
    # Write your code here
    pass`,
          solution: `# Approach 1: Monotonic Stack (Right to Left) - O(n + m) time, O(n) space
def nextGreaterElement(nums1: List[int], nums2: List[int]) -> List[int]:
    # Build next greater element map for nums2
    next_greater = {}
    stack = []

    # Process nums2 from right to left
    for num in reversed(nums2):
        # Pop smaller or equal elements
        while stack and stack[-1] <= num:
            stack.pop()

        # Top of stack is next greater (or -1 if empty)
        next_greater[num] = stack[-1] if stack else -1

        # Push current number
        stack.append(num)

    # Build result array
    return [next_greater[num] for num in nums1]

# Approach 2: Monotonic Stack (Left to Right) - O(n + m) time, O(n) space
def nextGreaterElement2(nums1: List[int], nums2: List[int]) -> List[int]:
    next_greater = {}
    stack = []

    # Process nums2 from left to right
    for num in nums2:
        # Current num is next greater for all smaller in stack
        while stack and stack[-1] < num:
            next_greater[stack.pop()] = num
        stack.append(num)

    # Remaining elements have no next greater
    for num in stack:
        next_greater[num] = -1

    # Build result
    return [next_greater[num] for num in nums1]`
        }
      },
      testCases: [
        { nums1: [4,1,2], nums2: [1,3,4,2], expected: '[-1,3,-1]' },
        { nums1: [2,4], nums2: [1,2,3,4], expected: '[3,-1]' }
      ],
      examples: [
        {
          input: 'nums1 = [4,1,2], nums2 = [1,3,4,2]',
          output: '[-1,3,-1]',
          explanation: 'For 4: no greater element to right → -1. For 1: first greater is 3. For 2: no greater to right → -1'
        },
        {
          input: 'nums1 = [2,4], nums2 = [1,2,3,4]',
          output: '[3,-1]',
          explanation: 'For 2: first greater is 3. For 4: no greater element → -1'
        }
      ],
      explanation: `**Problem:** Find the next greater element for each number in nums1 within nums2.

**What is Next Greater Element?**
For a number x at position i, the next greater element is the first number greater than x that appears to the right of position i.

**Key Insights:**
1. All elements in nums1 exist in nums2 (nums1 is subset of nums2)
2. All elements are distinct (no duplicates)
3. Can preprocess nums2 to find next greater for all elements
4. Use HashMap to store results and Stack for efficient computation

**Why Monotonic Stack?**
- Stack maintains elements in decreasing order (from bottom to top)
- When we see a larger element, it's the "next greater" for all smaller elements in stack
- O(n) time because each element pushed/popped at most once

**Algorithm (Right to Left):**
1. Traverse nums2 from right to left
2. For current element:
   - Pop all smaller/equal elements from stack (can't be next greater)
   - Top of stack is next greater element (or -1 if empty)
   - Store in HashMap: element → next greater
   - Push current element to stack
3. For each element in nums1, look up in HashMap

**Example Walkthrough:**
nums2 = [1,3,4,2]

Process right to left:
- i=3: num=2, stack=[], next[2]=-1, stack=[2]
- i=2: num=4, pop 2, next[4]=-1, stack=[4]
- i=1: num=3, 4>3, next[3]=4, stack=[4,3]
- i=0: num=1, 3>1, next[1]=3, stack=[4,3,1]

Result map: {1→3, 3→4, 4→-1, 2→-1}

For nums1=[4,1,2]: lookup → [-1, 3, -1]`,
      pseudocode: `Algorithm NextGreaterElement(nums1, nums2):
---------------------------------
    // Step 1: Build next greater map for nums2
    CREATE empty HashMap nextGreater
    CREATE empty Stack stack

    // Process nums2 from right to left
    FOR i FROM len(nums2)-1 DOWN TO 0:
        num = nums2[i]

        // Pop elements that are smaller or equal
        WHILE stack is not empty AND stack.top() <= num:
            stack.pop()

        // Store result for current number
        IF stack is empty:
            nextGreater[num] = -1
        ELSE:
            nextGreater[num] = stack.top()

        // Push current number
        stack.push(num)

    // Step 2: Build result array
    CREATE result array of size len(nums1)
    FOR i FROM 0 TO len(nums1)-1:
        result[i] = nextGreater[nums1[i]]

    RETURN result

KEY INSIGHT:
Monotonic Stack Pattern:
- Traverse from right: stack contains potential "next greater" candidates
- Pop smaller elements: they can never be answer for current or future
- Top of stack: first element greater than current
- Push current: it might be answer for elements on its left

TIME COMPLEXITY: O(n + m) where n=len(nums2), m=len(nums1)
- Process each element in nums2 once: O(n)
- Each element pushed/popped at most once: O(n)
- Look up m elements: O(m)

SPACE COMPLEXITY: O(n)
- HashMap: O(n) to store results
- Stack: O(n) worst case (all decreasing)`,
      trace: `Example: nums1 = [4,1,2], nums2 = [1,3,4,2]

Step 1: Build Next Greater Map (traverse right to left)

i=3: num=2
  stack=[] (empty)
  nextGreater[2] = -1
  stack=[2]

i=2: num=4
  stack=[2]
  4 > 2, so pop 2 (can't be next greater for anything on left)
  stack=[] (empty)
  nextGreater[4] = -1
  stack=[4]

i=1: num=3
  stack=[4]
  4 > 3 (don't pop, this is our answer!)
  nextGreater[3] = 4
  stack=[4, 3]

i=0: num=1
  stack=[4, 3]
  3 > 1 (first greater element found!)
  nextGreater[1] = 3
  stack=[4, 3, 1]

HashMap: {2→-1, 4→-1, 3→4, 1→3}

Step 2: Build Result Array

For nums1 = [4, 1, 2]:
  result[0] = nextGreater[4] = -1
  result[1] = nextGreater[1] = 3
  result[2] = nextGreater[2] = -1

Final result: [-1, 3, -1]

Verification:
nums2 = [1, 3, 4, 2]
- 4: elements to right are [2] → no greater → -1 ✓
- 1: elements to right are [3,4,2] → first greater is 3 ✓
- 2: elements to right are [] → no greater → -1 ✓`
    }
  ]

  const handleQuestionSelect = (question) => {
    setSelectedQuestion(question)
    setShowSolution(false)
    setShowExplanation(false)
    setUserCode(question.code[language].starterCode || '')
    setOutput('')
    // Load existing drawing if any
    const problemId = `Stacks-${question.id}`
    const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
    setCurrentDrawing(savedDrawing)
  }

  const openDrawingModal = () => {
    if (selectedQuestion) {
      const problemId = `Stacks-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
      setShowDrawing(true)
    }
  }

  const closeDrawingModal = () => {
    setShowDrawing(false)
    // Reload drawing after saving
    if (selectedQuestion) {
      const problemId = `Stacks-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
    }
  }

  // Question navigation
  const currentIndex = selectedQuestion ? questions.findIndex(q => q.id === selectedQuestion.id) : -1
  const hasPrevious = currentIndex > 0
  const hasNext = currentIndex >= 0 && currentIndex < questions.length - 1

  const goToPrevious = () => {
    if (hasPrevious) {
      handleQuestionSelect(questions[currentIndex - 1])
    }
  }

  const goToNext = () => {
    if (hasNext) {
      handleQuestionSelect(questions[currentIndex + 1])
    }
  }

  const runCode = async () => {
    setIsRunning(true)
    setOutput('Compiling and running your code...\n\n')
    await new Promise(resolve => setTimeout(resolve, 800))

    let outputText = `Running ${language === 'java' ? 'Solution.java' : 'solution.py'}...\n\n`

    if (selectedQuestion.testCases) {
      let passedTests = 0
      let totalTests = selectedQuestion.testCases.length

      selectedQuestion.testCases.forEach((testCase, index) => {
        const passed = Math.random() > 0.3 // Simulate success rate
        if (passed) passedTests++

        outputText += `Test Case ${index + 1}:\n`

        // Format input based on test case properties
        if (testCase.s) {
          outputText += `Input: s = "${testCase.s}"\n`
        } else if (testCase.path) {
          outputText += `Input: path = "${testCase.path}"\n`
        } else if (testCase.temperatures) {
          outputText += `Input: temperatures = [${testCase.temperatures.join(', ')}]\n`
        } else if (testCase.tokens) {
          outputText += `Input: tokens = [${testCase.tokens.map(t => '"' + t + '"').join(', ')}]\n`
        } else if (testCase.operations) {
          outputText += `Operations: ${testCase.operations.join(', ')}\n`
        }

        outputText += `Expected: ${testCase.expected}\n`

        if (passed) {
          outputText += `Output: ${testCase.expected}\n`
          outputText += `✅ PASSED\n\n`
        } else {
          const wrongOutput = typeof testCase.expected === 'number'
            ? testCase.expected + 1
            : typeof testCase.expected === 'boolean'
            ? !testCase.expected
            : 'null'
          outputText += `Output: ${wrongOutput}\n`
          outputText += `❌ FAILED\n\n`
        }
      })

      outputText += `\n${'='.repeat(50)}\n`
      if (passedTests === totalTests) {
        outputText += `✅ All tests passed! (${passedTests}/${totalTests})\n`
        outputText += `\n🎉 Great job! Your solution is correct!\n`
      } else {
        outputText += `⚠️  ${passedTests}/${totalTests} tests passed\n`
        outputText += `\n💡 Tip: Review the failed test cases and check your logic.\n`
      }
    }

    setOutput(outputText)
    setIsRunning(false)
  }

  const QuestionCard = ({ question, forceRefresh }) => {
    const problemId = `Stacks-${question.id}`
    const isCompleted = isProblemCompleted(problemId)

    return (
      <div
        onClick={() => handleQuestionSelect(question)}
        style={{
          backgroundColor: isCompleted ? '#f0fdf4' : 'white',
          color: '#1f2937',
          padding: '1.5rem',
          borderRadius: '12px',
          cursor: 'pointer',
          border: isCompleted ? '3px solid #10b981' : '2px solid #e5e7eb',
          transition: 'all 0.2s ease',
          boxShadow: isCompleted ? '0 2px 12px rgba(16, 185, 129, 0.2)' : '0 2px 8px rgba(0,0,0,0.1)',
          marginBottom: '1rem',
          position: 'relative'
        }}
        onMouseEnter={(e) => {
          e.currentTarget.style.transform = 'translateY(-2px)'
          e.currentTarget.style.boxShadow = isCompleted ? '0 4px 16px rgba(16, 185, 129, 0.3)' : '0 4px 12px rgba(0,0,0,0.15)'
        }}
        onMouseLeave={(e) => {
          e.currentTarget.style.transform = 'translateY(0)'
          e.currentTarget.style.boxShadow = isCompleted ? '0 2px 12px rgba(16, 185, 129, 0.2)' : '0 2px 8px rgba(0,0,0,0.1)'
        }}
      >
        {isCompleted && (
          <div style={{
            position: 'absolute',
            top: '-10px',
            left: '-10px',
            backgroundColor: '#10b981',
            color: 'white',
            borderRadius: '50%',
            width: '32px',
            height: '32px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '1.1rem',
            fontWeight: 'bold',
            boxShadow: '0 2px 8px rgba(16, 185, 129, 0.5)',
            border: '3px solid white',
            zIndex: 1
          }}>
            ✓
          </div>
        )}
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.5rem' }}>
          <div
            onClick={() => handleQuestionSelect(question)}
            style={{ flex: 1, cursor: 'pointer' }}
          >
            <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: '700' }}>
              {isCompleted && <span style={{ color: '#10b981', marginRight: '0.5rem' }}>✓</span>}
              {question.id}. {question.title}
            </h3>
          </div>
          <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
            {question.leetcodeUrl && (
              <a
                href={question.leetcodeUrl}
                target="_blank"
                rel="noopener noreferrer"
                onClick={(e) => e.stopPropagation()}
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  padding: '0.25rem 0.5rem',
                  fontSize: '0.7rem',
                  fontWeight: '600',
                  color: '#3b82f6',
                  backgroundColor: '#dbeafe',
                  border: '1px solid #3b82f6',
                  borderRadius: '6px',
                  textDecoration: 'none',
                  transition: 'all 0.2s ease',
                  cursor: 'pointer',
                  gap: '0.25rem'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#3b82f6'
                  e.currentTarget.style.color = 'white'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = '#dbeafe'
                  e.currentTarget.style.color = '#3b82f6'
                }}
                title="Open on LeetCode"
              >
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
                LC
              </a>
            )}
            <span style={{
              padding: '0.25rem 0.75rem',
              borderRadius: '6px',
              fontSize: '0.75rem',
              fontWeight: '600',
              backgroundColor: '#fbbf24',
              color: '#78350f'
            }}>
              {question.difficulty}
            </span>
          </div>
        </div>
        <p
          onClick={() => handleQuestionSelect(question)}
          style={{ margin: '0.5rem 0 0 0', fontSize: '0.9rem', opacity: 0.9, lineHeight: '1.5', cursor: 'pointer' }}
        >
          {question.description.substring(0, 100)}...
        </p>
      </div>
    )
  }

  return (
    <div style={{ padding: '2rem', maxWidth: '1400px', margin: '0 auto' }}>
      <div style={{ marginBottom: '2rem', display: 'flex', alignItems: 'center', gap: '1rem', justifyContent: 'space-between' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
          <button
            onClick={onBack}
            style={{
              padding: '0.75rem 1.5rem',
              fontSize: '1rem',
              fontWeight: '600',
              backgroundColor: '#3b82f6',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              boxShadow: '0 2px 8px rgba(59, 130, 246, 0.3)'
            }}
          >
            ← Back to Menu
          </button>
          <h1 style={{ margin: 0, fontSize: '2rem', fontWeight: '800', color: '#1f2937' }}>
            📚 Stack Practice Questions
          </h1>
          {currentSubcategory && (
            <span style={{
              padding: '0.5rem 1rem',
              fontSize: '0.9rem',
              fontWeight: '600',
              backgroundColor: '#dbeafe',
              color: '#1e40af',
              borderRadius: '8px',
              marginLeft: '1rem'
            }}>
              {currentSubcategory}
            </span>
          )}
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
          {previousSubcategory && (
            <button
              onClick={onPreviousSubcategory}
              style={{
                padding: '0.6rem 1rem',
                fontSize: '0.85rem',
                fontWeight: '600',
                backgroundColor: '#8b5cf6',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 6px rgba(139, 92, 246, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.4rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#7c3aed'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#8b5cf6'}
            >
              ⬆️ {previousSubcategory}
            </button>
          )}
          {nextSubcategory && (
            <button
              onClick={onNextSubcategory}
              style={{
                padding: '0.6rem 1rem',
                fontSize: '0.85rem',
                fontWeight: '600',
                backgroundColor: '#8b5cf6',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 6px rgba(139, 92, 246, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.4rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#7c3aed'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#8b5cf6'}
            >
              {nextSubcategory} ⬇️
            </button>
          )}
          {onPrevious && (
            <button
              onClick={onPrevious}
              style={{
                padding: '0.75rem 1.25rem',
                fontSize: '1rem',
                fontWeight: '600',
                backgroundColor: '#10b981',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 8px rgba(16, 185, 129, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.5rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#059669'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#10b981'}
            >
              ← {previousName}
            </button>
          )}
          {onNext && (
            <button
              onClick={onNext}
              style={{
                padding: '0.75rem 1.25rem',
                fontSize: '1rem',
                fontWeight: '600',
                backgroundColor: '#10b981',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                boxShadow: '0 2px 8px rgba(16, 185, 129, 0.3)',
                display: 'flex',
                alignItems: 'center',
                gap: '0.5rem'
              }}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#059669'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#10b981'}
            >
              {nextName} →
            </button>
          )}
        </div>
      </div>

      {!selectedQuestion && (
        <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
          {/* Easy Questions */}
          {(() => {
            const easyQuestions = questions.filter(q => q.difficulty === 'Easy')
            if (easyQuestions.length === 0) return null

            const completed = easyQuestions.filter(q => isProblemCompleted(`Stacks-${q.id}`)).length
            const total = easyQuestions.length
            const shouldCollapse = total > 5
            const isExpanded = expandedSections.Easy

            return (
              <div>
                <h2
                  onClick={() => shouldCollapse && setExpandedSections(prev => ({ ...prev, Easy: !prev.Easy }))}
                  tabIndex={shouldCollapse ? 0 : -1}
                  role={shouldCollapse ? "button" : undefined}
                  aria-expanded={shouldCollapse ? isExpanded : undefined}
                  onKeyDown={(e) => {
                    if (shouldCollapse && (e.key === "Enter" || e.key === " ")) {
                      e.preventDefault()
                      setExpandedSections(prev => ({ ...prev, Easy: !prev.Easy }))
                    }
                  }}
                  style={{
                    fontSize: '1.5rem',
                    fontWeight: '700',
                    color: '#059669',
                    marginBottom: '1rem',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.75rem',
                    borderBottom: '3px solid #10b981',
                    paddingBottom: '0.5rem',
                    cursor: shouldCollapse ? 'pointer' : 'default',
                    userSelect: 'none'
                  }}
                >
                  {shouldCollapse && (
                    <span style={{ fontSize: '1.2rem', transition: 'transform 0.2s', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>
                      ▶
                    </span>
                  )}
                  <span style={{
                    backgroundColor: '#d1fae5',
                    color: '#065f46',
                    padding: '0.25rem 0.75rem',
                    borderRadius: '8px',
                    fontSize: '0.9rem'
                  }}>
                    Easy
                  </span>
                  <span style={{ fontSize: '1rem', color: '#6b7280' }}>
                    {total} {total === 1 ? 'problem' : 'problems'}
                  </span>
                  <span style={{
                    fontSize: '0.9rem',
                    color: completed === total ? '#059669' : '#6b7280',
                    fontWeight: '600',
                    backgroundColor: completed === total ? '#d1fae5' : '#f3f4f6',
                    padding: '0.25rem 0.75rem',
                    borderRadius: '6px'
                  }}>
                    {completed}/{total} completed
                  </span>
                </h2>
                {(!shouldCollapse || isExpanded) && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    {easyQuestions.map(q =>
                      <QuestionCard key={`${q.id}-${refreshKey}`} question={q} forceRefresh={refreshKey} />
                    )}
                  </div>
                )}
              </div>
            )
          })()}

          {/* Medium Questions */}
          {(() => {
            const mediumQuestions = questions.filter(q => q.difficulty === 'Medium')
            if (mediumQuestions.length === 0) return null

            const completed = mediumQuestions.filter(q => isProblemCompleted(`Stacks-${q.id}`)).length
            const total = mediumQuestions.length
            const shouldCollapse = total > 5
            const isExpanded = expandedSections.Medium

            return (
              <div>
                <h2
                  onClick={() => shouldCollapse && setExpandedSections(prev => ({ ...prev, Medium: !prev.Medium }))}
                  tabIndex={shouldCollapse ? 0 : -1}
                  role={shouldCollapse ? "button" : undefined}
                  aria-expanded={shouldCollapse ? isExpanded : undefined}
                  onKeyDown={(e) => {
                    if (shouldCollapse && (e.key === "Enter" || e.key === " ")) {
                      e.preventDefault()
                      setExpandedSections(prev => ({ ...prev, Medium: !prev.Medium }))
                    }
                  }}
                  style={{
                    fontSize: '1.5rem',
                    fontWeight: '700',
                    color: '#d97706',
                    marginBottom: '1rem',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.75rem',
                    borderBottom: '3px solid #f59e0b',
                    paddingBottom: '0.5rem',
                    cursor: shouldCollapse ? 'pointer' : 'default',
                    userSelect: 'none'
                  }}
                >
                  {shouldCollapse && (
                    <span style={{ fontSize: '1.2rem', transition: 'transform 0.2s', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>
                      ▶
                    </span>
                  )}
                  <span style={{
                    backgroundColor: '#fef3c7',
                    color: '#92400e',
                    padding: '0.25rem 0.75rem',
                    borderRadius: '8px',
                    fontSize: '0.9rem'
                  }}>
                    Medium
                  </span>
                  <span style={{ fontSize: '1rem', color: '#6b7280' }}>
                    {total} {total === 1 ? 'problem' : 'problems'}
                  </span>
                  <span style={{
                    fontSize: '0.9rem',
                    color: completed === total ? '#d97706' : '#6b7280',
                    fontWeight: '600',
                    backgroundColor: completed === total ? '#fef3c7' : '#f3f4f6',
                    padding: '0.25rem 0.75rem',
                    borderRadius: '6px'
                  }}>
                    {completed}/{total} completed
                  </span>
                </h2>
                {(!shouldCollapse || isExpanded) && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    {mediumQuestions.map(q =>
                      <QuestionCard key={`${q.id}-${refreshKey}`} question={q} forceRefresh={refreshKey} />
                    )}
                  </div>
                )}
              </div>
            )
          })()}

          {/* Hard Questions */}
          {(() => {
            const hardQuestions = questions.filter(q => q.difficulty === 'Hard')
            if (hardQuestions.length === 0) return null

            const completed = hardQuestions.filter(q => isProblemCompleted(`Stacks-${q.id}`)).length
            const total = hardQuestions.length
            const shouldCollapse = total > 5
            const isExpanded = expandedSections.Hard

            return (
              <div>
                <h2
                  onClick={() => shouldCollapse && setExpandedSections(prev => ({ ...prev, Hard: !prev.Hard }))}
                  tabIndex={shouldCollapse ? 0 : -1}
                  role={shouldCollapse ? "button" : undefined}
                  aria-expanded={shouldCollapse ? isExpanded : undefined}
                  onKeyDown={(e) => {
                    if (shouldCollapse && (e.key === "Enter" || e.key === " ")) {
                      e.preventDefault()
                      setExpandedSections(prev => ({ ...prev, Hard: !prev.Hard }))
                    }
                  }}
                  style={{
                    fontSize: '1.5rem',
                    fontWeight: '700',
                    color: '#dc2626',
                    marginBottom: '1rem',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.75rem',
                    borderBottom: '3px solid #ef4444',
                    paddingBottom: '0.5rem',
                    cursor: shouldCollapse ? 'pointer' : 'default',
                    userSelect: 'none'
                  }}
                >
                  {shouldCollapse && (
                    <span style={{ fontSize: '1.2rem', transition: 'transform 0.2s', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>
                      ▶
                    </span>
                  )}
                  <span style={{
                    backgroundColor: '#fee2e2',
                    color: '#991b1b',
                    padding: '0.25rem 0.75rem',
                    borderRadius: '8px',
                    fontSize: '0.9rem'
                  }}>
                    Hard
                  </span>
                  <span style={{ fontSize: '1rem', color: '#6b7280' }}>
                    {total} {total === 1 ? 'problem' : 'problems'}
                  </span>
                  <span style={{
                    fontSize: '0.9rem',
                    color: completed === total ? '#dc2626' : '#6b7280',
                    fontWeight: '600',
                    backgroundColor: completed === total ? '#fee2e2' : '#f3f4f6',
                    padding: '0.25rem 0.75rem',
                    borderRadius: '6px'
                  }}>
                    {completed}/{total} completed
                  </span>
                </h2>
                {(!shouldCollapse || isExpanded) && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    {hardQuestions.map(q =>
                      <QuestionCard key={`${q.id}-${refreshKey}`} question={q} forceRefresh={refreshKey} />
                    )}
                  </div>
                )}
              </div>
            )
          })()}
        </div>
      )}

      {selectedQuestion && (
        <div>
          <button
            onClick={() => setSelectedQuestion(null)}
            style={{
              padding: '0.75rem 1.5rem',
              fontSize: '1rem',
              fontWeight: '600',
              backgroundColor: '#6b7280',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              marginBottom: '1.5rem',
              boxShadow: '0 2px 8px rgba(107, 114, 128, 0.3)'
            }}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#4b5563'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#6b7280'}
          >
            ← Back to Questions
          </button>
          <div style={{
            backgroundColor: 'white',
            padding: '2rem',
            borderRadius: '12px',
            border: '2px solid #e5e7eb',
            boxShadow: '0 4px 16px rgba(0,0,0,0.1)'
          }}>
            <div style={{ marginBottom: '1.5rem' }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '1rem' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                  <h2 style={{ margin: 0, fontSize: '1.5rem', fontWeight: '800', color: '#1f2937' }}>
                    {selectedQuestion.id}. {selectedQuestion.title}
                  </h2>
                  {selectedQuestion.leetcodeUrl && (
                    <a
                      href={selectedQuestion.leetcodeUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      style={{
                        display: 'inline-flex',
                        alignItems: 'center',
                        padding: '0.35rem 0.6rem',
                        backgroundColor: '#f97316',
                        color: 'white',
                        textDecoration: 'none',
                        borderRadius: '6px',
                        fontSize: '0.75rem',
                        fontWeight: '600',
                        transition: 'all 0.2s ease',
                        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.backgroundColor = '#ea580c'
                        e.currentTarget.style.transform = 'translateY(-1px)'
                        e.currentTarget.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.backgroundColor = '#f97316'
                        e.currentTarget.style.transform = 'translateY(0)'
                        e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)'
                      }}
                      title="Open on LeetCode"
                    >
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ marginRight: '0.25rem' }}>
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                        <polyline points="15 3 21 3 21 9"></polyline>
                        <line x1="10" y1="14" x2="21" y2="3"></line>
                      </svg>
                      LeetCode
                    </a>
                  )}
                </div>
                <span style={{
                  padding: '0.5rem 1rem',
                  borderRadius: '8px',
                  fontSize: '0.85rem',
                  fontWeight: '700',
                  backgroundColor: '#fbbf24',
                  color: '#78350f'
                }}>
                  {selectedQuestion.difficulty}
                </span>
              </div>
              <p style={{ fontSize: '1rem', lineHeight: '1.7', color: '#4b5563', margin: '1rem 0' }}>
                {selectedQuestion.description}
              </p>

              {/* Previous/Next Navigation */}
              <div style={{ display: 'flex', gap: '1rem', marginTop: '1rem' }}>
                <button
                  onClick={goToPrevious}
                  disabled={!hasPrevious}
                  style={{
                    padding: '0.5rem 1rem',
                    fontSize: '0.9rem',
                    fontWeight: '600',
                    backgroundColor: hasPrevious ? '#6b7280' : '#d1d5db',
                    color: 'white',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: hasPrevious ? 'pointer' : 'not-allowed',
                    transition: 'all 0.2s ease',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.5rem'
                  }}
                  onMouseEnter={(e) => {
                    if (hasPrevious) e.currentTarget.style.backgroundColor = '#4b5563'
                  }}
                  onMouseLeave={(e) => {
                    if (hasPrevious) e.currentTarget.style.backgroundColor = '#6b7280'
                  }}
                >
                  ← Previous
                </button>
                <button
                  onClick={goToNext}
                  disabled={!hasNext}
                  style={{
                    padding: '0.5rem 1rem',
                    fontSize: '0.9rem',
                    fontWeight: '600',
                    backgroundColor: hasNext ? '#6b7280' : '#d1d5db',
                    color: 'white',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: hasNext ? 'pointer' : 'not-allowed',
                    transition: 'all 0.2s ease',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.5rem'
                  }}
                  onMouseEnter={(e) => {
                    if (hasNext) e.currentTarget.style.backgroundColor = '#4b5563'
                  }}
                  onMouseLeave={(e) => {
                    if (hasNext) e.currentTarget.style.backgroundColor = '#6b7280'
                  }}
                >
                  Next →
                </button>
              </div>
            </div>

            <div style={{ marginBottom: '1.5rem' }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                <h3 style={{ fontSize: '1.1rem', fontWeight: '700', color: '#1f2937', margin: 0 }}>
                  💻 Code Editor
                </h3>
                <LanguageToggle />
              </div>
              <div style={{
                backgroundColor: '#1e293b',
                borderRadius: '8px',
                overflow: 'hidden',
                border: '2px solid #334155'
              }}>
                <div style={{
                  backgroundColor: '#0f172a',
                  padding: '0.75rem 1rem',
                  borderBottom: '1px solid #334155',
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center'
                }}>
                  <span style={{ color: '#94a3b8', fontSize: '0.85rem', fontWeight: '600' }}>
                    {language === 'java' ? 'Solution.java' : 'solution.py'}
                  </span>
                  <span style={{ color: '#64748b', fontSize: '0.75rem' }}>
                    {language === 'java' ? 'Java' : 'Python'}
                  </span>
                </div>
                <textarea
                  value={userCode}
                  onChange={(e) => setUserCode(e.target.value)}
                  onKeyDown={(e) => {
                    // Stop propagation for all keys except Escape to allow typing in textarea
                    if (e.key !== 'Escape') {
                      e.stopPropagation()
                    }

                    if (e.key === 'Tab') {
                      e.preventDefault()
                      const start = e.target.selectionStart
                      const end = e.target.selectionEnd
                      const newValue = userCode.substring(0, start) + '    ' + userCode.substring(end)
                      setUserCode(newValue)
                      setTimeout(() => {
                        e.target.selectionStart = e.target.selectionEnd = start + 4
                      }, 0)
                    }
                  }}
                  spellCheck="false"
                  style={{
                    width: '100%',
                    minHeight: '600px',
                    padding: '1rem',
                    fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
                    fontSize: '0.9rem',
                    lineHeight: '1.6',
                    color: '#e2e8f0',
                    backgroundColor: '#1e293b',
                    border: 'none',
                    outline: 'none',
                    resize: 'vertical',
                    whiteSpace: 'pre',
                    overflowX: 'auto'
                  }}
                  placeholder="Write your solution here..."
                />
              </div>
              <div style={{ display: 'flex', gap: '1rem', marginTop: '1rem', alignItems: 'center', flexWrap: 'wrap' }}>
                <button
                  onClick={runCode}
                  disabled={isRunning}
                  style={{
                    padding: '0.75rem 1.5rem',
                    fontSize: '0.95rem',
                    fontWeight: '700',
                    backgroundColor: isRunning ? '#6b7280' : '#10b981',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: isRunning ? 'not-allowed' : 'pointer',
                    transition: 'all 0.2s ease',
                    boxShadow: '0 2px 8px rgba(16, 185, 129, 0.3)',
                    flex: 1,
                    minWidth: '120px'
                  }}
                >
                  {isRunning ? '⏳ Running...' : '▶️ Run Code'}
                </button>
                <button
                  onClick={() => setUserCode(selectedQuestion.code[language].starterCode || '')}
                  style={{
                    padding: '0.75rem 1.5rem',
                    fontSize: '0.95rem',
                    fontWeight: '700',
                    backgroundColor: '#ef4444',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    boxShadow: '0 2px 8px rgba(239, 68, 68, 0.3)',
                    minWidth: '120px'
                  }}
                >
                  🔄 Reset
                </button>
                <button
                  onClick={openDrawingModal}
                  style={{
                    padding: '0.75rem 1.5rem',
                    fontSize: '0.95rem',
                    fontWeight: '700',
                    backgroundColor: currentDrawing ? '#8b5cf6' : '#6366f1',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    boxShadow: currentDrawing ? '0 2px 8px rgba(139, 92, 246, 0.3)' : '0 2px 8px rgba(99, 102, 241, 0.3)',
                    minWidth: '120px'
                  }}
                >
                  {currentDrawing ? '✏️ Edit Drawing' : '🎨 Draw'}
                </button>
              </div>
            </div>

            {currentDrawing && (
              <div style={{ marginBottom: '1.5rem' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                  <h3 style={{ fontSize: '1.1rem', fontWeight: '700', color: '#1f2937', margin: 0 }}>
                    🎨 Your Drawing
                  </h3>
                  <button
                    onClick={openDrawingModal}
                    style={{
                      padding: '0.5rem 1rem',
                      fontSize: '0.875rem',
                      fontWeight: '600',
                      backgroundColor: '#6366f1',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      transition: 'all 0.2s ease'
                    }}
                  >
                    ✏️ Edit
                  </button>
                </div>
                <div style={{
                  backgroundColor: '#f9fafb',
                  padding: '1rem',
                  borderRadius: '8px',
                  border: '2px solid #e5e7eb',
                  textAlign: 'center'
                }}>
                  <img
                    src={currentDrawing}
                    alt="Problem drawing"
                    style={{
                      maxWidth: '100%',
                      height: 'auto',
                      borderRadius: '8px',
                      border: '1px solid #cbd5e1'
                    }}
                  />
                </div>
              </div>
            )}

            {output && (
              <div style={{ marginBottom: '1.5rem' }}>
                <h3 style={{ fontSize: '1.1rem', fontWeight: '700', color: '#1f2937', marginBottom: '1rem' }}>
                  📊 Output
                </h3>
                <div style={{
                  backgroundColor: '#0f172a',
                  padding: '1rem',
                  borderRadius: '8px',
                  border: '2px solid #334155'
                }}>
                  <pre style={{
                    margin: 0,
                    fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
                    fontSize: '0.85rem',
                    lineHeight: '1.6',
                    color: '#e2e8f0',
                    whiteSpace: 'pre-wrap',
                    wordWrap: 'break-word'
                  }}>
                    {output}
                  </pre>
                </div>
              </div>
            )}

            <div style={{ marginBottom: '1.5rem' }}>
              <h3 style={{ fontSize: '1.1rem', fontWeight: '700', color: '#1f2937', marginBottom: '1rem' }}>
                Examples:
              </h3>
              {selectedQuestion.examples.map((example, idx) => (
                <div key={idx} style={{
                  backgroundColor: '#f9fafb',
                  padding: '1rem',
                  borderRadius: '8px',
                  marginBottom: '0.75rem',
                  border: '1px solid #e5e7eb'
                }}>
                  <div style={{ marginBottom: '0.5rem' }}>
                    <strong style={{ color: '#1f2937' }}>Input:</strong>
                    <code style={{
                      backgroundColor: '#1e293b',
                      color: '#e2e8f0',
                      padding: '0.25rem 0.5rem',
                      borderRadius: '4px',
                      marginLeft: '0.5rem',
                      fontFamily: 'monospace',
                      fontSize: '0.9rem'
                    }}>
                      {example.input}
                    </code>
                  </div>
                  <div style={{ marginBottom: example.explanation ? '0.5rem' : '0' }}>
                    <strong style={{ color: '#1f2937' }}>Output:</strong>
                    <code style={{
                      backgroundColor: '#1e293b',
                      color: '#e2e8f0',
                      padding: '0.25rem 0.5rem',
                      borderRadius: '4px',
                      marginLeft: '0.5rem',
                      fontFamily: 'monospace',
                      fontSize: '0.9rem'
                    }}>
                      {example.output}
                    </code>
                  </div>
                  {example.explanation && (
                    <div style={{ fontSize: '0.9rem', color: '#6b7280', fontStyle: 'italic' }}>
                      {example.explanation}
                    </div>
                  )}
                </div>
              ))}
            </div>

            <div style={{ display: 'flex', gap: '1rem', alignItems: 'center', marginBottom: '1rem', flexWrap: 'wrap' }}>
              <button
                onClick={() => setShowExplanation(!showExplanation)}
                style={{
                  padding: '0.75rem 1.5rem',
                  fontSize: '1rem',
                  fontWeight: '700',
                  backgroundColor: showExplanation ? '#8b5cf6' : '#f59e0b',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease',
                  boxShadow: '0 2px 8px rgba(245, 158, 11, 0.3)',
                  flex: 1,
                  minWidth: '200px'
                }}
              >
                {showExplanation ? '✓ Explanation Visible' : '📖 Explanation & Pseudocode'}
              </button>
              <button
                onClick={() => setShowSolution(!showSolution)}
                style={{
                  padding: '0.75rem 1.5rem',
                  fontSize: '1rem',
                  fontWeight: '700',
                  backgroundColor: showSolution ? '#10b981' : '#3b82f6',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease',
                  boxShadow: '0 2px 8px rgba(59, 130, 246, 0.3)',
                  flex: 1,
                  minWidth: '200px'
                }}
              >
                {showSolution ? '✓ Solution Visible' : '👁️ Show Solution'}
              </button>
              <div style={{ marginLeft: 'auto' }}>
                <CompletionCheckbox
                  problemId={`Stacks-${selectedQuestion.id}`}
                  label="Mark as Completed"
                  onCompletionChange={() => setRefreshKey(prev => prev + 1)}
                />
              </div>
            </div>

            {showExplanation && (
              <div style={{
                backgroundColor: '#fef3c7',
                padding: '1.5rem',
                borderRadius: '8px',
                border: '2px solid #f59e0b',
                marginBottom: '1rem'
              }}>
                <h3 style={{ fontSize: '1.2rem', fontWeight: '700', color: '#92400e', marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                  📖 Explanation
                </h3>
                <div style={{
                  fontSize: '0.95rem',
                  lineHeight: '1.8',
                  color: '#78350f',
                  whiteSpace: 'pre-wrap',
                  marginBottom: '1.5rem'
                }}>
                  {selectedQuestion.explanation}
                </div>

                <div style={{
                  backgroundColor: '#1e293b',
                  padding: '1.5rem',
                  borderRadius: '8px',
                  overflowX: 'auto',
                  marginTop: '1rem'
                }}>
                  <h4 style={{ fontSize: '1.1rem', fontWeight: '700', color: '#a78bfa', marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    🔧 Pseudocode
                  </h4>
                  <pre style={{
                    margin: 0,
                    fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
                    fontSize: '0.9rem',
                    lineHeight: '1.6',
                    color: '#e2e8f0',
                    whiteSpace: 'pre',
                    overflowX: 'auto'
                  }}>
                    {selectedQuestion.pseudocode}
                  </pre>
                </div>
              </div>
            )}

            {showSolution && (
              <div style={{
                backgroundColor: '#1e293b',
                padding: '1.5rem',
                borderRadius: '8px',
                overflowX: 'auto'
              }}>
                <h3 style={{ fontSize: '1.1rem', fontWeight: '700', color: '#60a5fa', marginBottom: '1rem' }}>
                  Solution ({language === 'java' ? 'Java' : 'Python'}):
                </h3>
                <pre style={{
                  margin: 0,
                  fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
                  fontSize: '0.85rem',
                  lineHeight: '1.6',
                  color: '#d4d4d4',
                  whiteSpace: 'pre',
                  overflowX: 'auto'
                }}>
                  {selectedQuestion.code[language].solution}
                </pre>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Drawing Canvas Modal */}
      <DrawingCanvas
        isOpen={showDrawing}
        onClose={closeDrawingModal}
        problemId={selectedQuestion ? `Stacks-${selectedQuestion.id}` : ''}
        existingDrawing={currentDrawing}
      />
    </div>
  )
}

export default Stacks
