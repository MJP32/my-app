import React, { useState, useEffect, useRef } from 'react'
import CompletionCheckbox from '../../components/CompletionCheckbox'
import KeyboardGuide from '../../components/KeyboardGuide'
import DrawingCanvas from '../../components/DrawingCanvas'
import { saveUserCode, getUserCode, isProblemCompleted } from '../../services/progressService'
import { useKeyboardNavigation } from '../../hooks/useKeyboardNavigation'

const FamousAlgorithms = ({ onBack }) => {
  const [selectedQuestion, setSelectedQuestion] = useState(null)
  const [showDrawing, setShowDrawing] = useState(false)
  const [currentDrawing, setCurrentDrawing] = useState(null)

  const questions = [
    {
      id: 1,
      title: 'Maximum Subarray (Kadane\'s Algorithm)',
      difficulty: 'Medium',
      leetcodeUrl: 'https://leetcode.com/problems/maximum-subarray/',
      description: 'Given an integer array nums, find the subarray with the largest sum, and return its sum. A subarray is a contiguous non-empty sequence of elements within an array.',
      explanation: `**Problem Understanding:**
Find the contiguous subarray with the maximum sum using Kadane's Algorithm - one of the most famous algorithms in computer science.

**Key Insights - Kadane's Algorithm:**
1. At each position, decide whether to extend the current subarray or start a new one
2. Keep track of the maximum sum seen so far
3. If current sum becomes negative, reset to 0 (or start fresh from next element)
4. This greedy approach works because a negative prefix can never help maximize the sum

**Approaches:**

**Approach 1: Kadane's Algorithm**
- Time: O(n) - Single pass
- Space: O(1) - Constant space
- Core idea: maxEndingHere = max(num, maxEndingHere + num)
- Track maximum sum seen so far

**Approach 2: Divide and Conquer**
- Time: O(n log n) - Recursive division
- Space: O(log n) - Recursion stack
- Divide array, find max in left, right, and crossing middle

**Approach 3: Dynamic Programming**
- Time: O(n) - Single pass
- Space: O(n) - DP array (can be optimized to O(1))
- Similar to Kadane's but explicitly store DP states

**Edge Cases:**
- All negative numbers
- Single element
- All positive numbers
- Mixed positive and negative`,
      pseudocode: `ALGORITHM MaxSubArray(nums):
    maxSoFar = nums[0]
    maxEndingHere = nums[0]

    FOR i = 1 TO length(nums) - 1:
        // Either extend existing subarray or start new one
        maxEndingHere = MAX(nums[i], maxEndingHere + nums[i])

        // Update global maximum
        maxSoFar = MAX(maxSoFar, maxEndingHere)

    RETURN maxSoFar

KADANE'S ALGORITHM INTUITION:
- At each step, we ask: "Should I add this element to my current sum,
  or start fresh from this element?"
- We choose whichever gives a larger value

TIME COMPLEXITY: O(n) - Single pass
SPACE COMPLEXITY: O(1) - Constant space`,
      code: {
        java: {
          starterCode: `public int maxSubArray(int[] nums) {
    // Write your code here

}`,
          solution: `// Approach 1: Kadane's Algorithm - O(n) time, O(1) space
public int maxSubArray(int[] nums) {
    int maxSoFar = nums[0];
    int maxEndingHere = nums[0];

    for (int i = 1; i < nums.length; i++) {
        // Either extend the existing subarray or start a new one
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);

        // Update the global maximum
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

// Approach 2: Kadane's Algorithm (Alternative Implementation)
public int maxSubArrayAlt(int[] nums) {
    int maxSum = Integer.MIN_VALUE;
    int currentSum = 0;

    for (int num : nums) {
        currentSum += num;
        maxSum = Math.max(maxSum, currentSum);

        // If current sum becomes negative, reset to 0
        if (currentSum < 0) {
            currentSum = 0;
        }
    }

    return maxSum;
}

// Approach 3: Divide and Conquer - O(n log n) time, O(log n) space
public int maxSubArrayDivideConquer(int[] nums) {
    return maxSubArrayHelper(nums, 0, nums.length - 1);
}

private int maxSubArrayHelper(int[] nums, int left, int right) {
    if (left == right) {
        return nums[left];
    }

    int mid = left + (right - left) / 2;

    // Maximum in left half
    int leftMax = maxSubArrayHelper(nums, left, mid);

    // Maximum in right half
    int rightMax = maxSubArrayHelper(nums, mid + 1, right);

    // Maximum crossing the middle
    int crossMax = maxCrossingSum(nums, left, mid, right);

    return Math.max(Math.max(leftMax, rightMax), crossMax);
}

private int maxCrossingSum(int[] nums, int left, int mid, int right) {
    // Max sum in left half ending at mid
    int leftSum = Integer.MIN_VALUE;
    int sum = 0;
    for (int i = mid; i >= left; i--) {
        sum += nums[i];
        leftSum = Math.max(leftSum, sum);
    }

    // Max sum in right half starting from mid+1
    int rightSum = Integer.MIN_VALUE;
    sum = 0;
    for (int i = mid + 1; i <= right; i++) {
        sum += nums[i];
        rightSum = Math.max(rightSum, sum);
    }

    return leftSum + rightSum;
}

// Approach 4: Dynamic Programming (Explicit DP Array)
public int maxSubArrayDP(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    dp[0] = nums[0];
    int maxSum = dp[0];

    for (int i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
        maxSum = Math.max(maxSum, dp[i]);
    }

    return maxSum;
}`
        },
        python: {
          starterCode: `def maxSubArray(self, nums: List[int]) -> int:
    # Write your code here
    pass`,
          solution: `# Approach 1: Kadane's Algorithm - O(n) time, O(1) space
def maxSubArray(self, nums: List[int]) -> int:
    max_so_far = nums[0]
    max_ending_here = nums[0]

    for i in range(1, len(nums)):
        # Either extend the existing subarray or start a new one
        max_ending_here = max(nums[i], max_ending_here + nums[i])

        # Update the global maximum
        max_so_far = max(max_so_far, max_ending_here)

    return max_so_far

# Approach 2: Kadane's Algorithm (Alternative Implementation)
def max_sub_array_alt(self, nums: List[int]) -> int:
    max_sum = float('-inf')
    current_sum = 0

    for num in nums:
        current_sum += num
        max_sum = max(max_sum, current_sum)

        # If current sum becomes negative, reset to 0
        if current_sum < 0:
            current_sum = 0

    return max_sum

# Approach 3: Divide and Conquer - O(n log n) time, O(log n) space
def max_sub_array_divide_conquer(self, nums: List[int]) -> int:
    def max_crossing_sum(left, mid, right):
        # Max sum in left half ending at mid
        left_sum = float('-inf')
        total = 0
        for i in range(mid, left - 1, -1):
            total += nums[i]
            left_sum = max(left_sum, total)

        # Max sum in right half starting from mid+1
        right_sum = float('-inf')
        total = 0
        for i in range(mid + 1, right + 1):
            total += nums[i]
            right_sum = max(right_sum, total)

        return left_sum + right_sum

    def helper(left, right):
        if left == right:
            return nums[left]

        mid = (left + right) // 2

        left_max = helper(left, mid)
        right_max = helper(mid + 1, right)
        cross_max = max_crossing_sum(left, mid, right)

        return max(left_max, right_max, cross_max)

    return helper(0, len(nums) - 1)

# Approach 4: Dynamic Programming (Explicit DP Array)
def max_sub_array_dp(self, nums: List[int]) -> int:
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    max_sum = dp[0]

    for i in range(1, n):
        dp[i] = max(nums[i], dp[i - 1] + nums[i])
        max_sum = max(max_sum, dp[i])

    return max_sum

# Pythonic one-liner (Kadane's)
def max_sub_array_oneliner(self, nums: List[int]) -> int:
    return max(accumulate(nums, lambda max_so_far, num: max(num, max_so_far + num)))
    # Note: requires from itertools import accumulate`
        }
      },
      testCases: [
        { nums: [-2,1,-3,4,-1,2,1,-5,4], expected: 6 },
        { nums: [1], expected: 1 },
        { nums: [5,4,-1,7,8], expected: 23 },
        { nums: [-1], expected: -1 },
        { nums: [-2,-1], expected: -1 }
      ],
      examples: [
        {
          input: 'nums = [-2,1,-3,4,-1,2,1,-5,4]',
          output: '6',
          explanation: 'The subarray [4,-1,2,1] has the largest sum 6.'
        },
        {
          input: 'nums = [1]',
          output: '1',
          explanation: 'The subarray [1] has the largest sum 1.'
        }
      ]
    },
    {
      id: 2,
      title: 'Linked List Cycle (Floyd\'s Cycle Detection)',
      difficulty: 'Easy',
      leetcodeUrl: 'https://leetcode.com/problems/linked-list-cycle/',
      description: 'Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Return true if there is a cycle in the linked list. Otherwise, return false.',
      explanation: `**Problem Understanding:**
Detect if a linked list has a cycle using Floyd's Cycle Detection Algorithm (Tortoise and Hare).

**Key Insights - Floyd's Algorithm:**
1. Use two pointers: slow (moves 1 step) and fast (moves 2 steps)
2. If there's a cycle, fast will eventually catch up to slow
3. If there's no cycle, fast will reach the end (null)
4. This is also called the "Tortoise and Hare" algorithm

**Why It Works:**
- In a cycle, the fast pointer gains on the slow pointer by 1 position per iteration
- Eventually, they will meet inside the cycle
- If no cycle exists, fast reaches null

**Approaches:**

**Approach 1: Floyd's Cycle Detection (Two Pointers)**
- Time: O(n) - At most 2n steps
- Space: O(1) - Constant space
- Most optimal solution

**Approach 2: Hash Set**
- Time: O(n) - Visit each node once
- Space: O(n) - Store visited nodes
- Straightforward but uses extra space

**Edge Cases:**
- Empty list (no cycle)
- Single node (no cycle)
- Two nodes with cycle
- Cycle at the beginning vs middle`,
      pseudocode: `ALGORITHM HasCycle(head):
    IF head is NULL OR head.next is NULL:
        RETURN false

    slow = head
    fast = head

    WHILE fast != NULL AND fast.next != NULL:
        slow = slow.next           // Move 1 step
        fast = fast.next.next      // Move 2 steps

        IF slow == fast:           // They met - cycle exists
            RETURN true

    RETURN false                    // Fast reached end - no cycle

FLOYD'S ALGORITHM INTUITION:
- Think of it like a race track
- If there's a loop, the faster runner will eventually lap the slower one
- If there's no loop, the faster runner reaches the finish line

TIME COMPLEXITY: O(n) - At most 2n steps
SPACE COMPLEXITY: O(1) - Only two pointers`,
      code: {
        java: {
          starterCode: `/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public boolean hasCycle(ListNode head) {
    // Write your code here

}`,
          solution: `// Approach 1: Floyd's Cycle Detection - O(n) time, O(1) space
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }

    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;           // Move 1 step
        fast = fast.next.next;      // Move 2 steps

        if (slow == fast) {         // Cycle detected
            return true;
        }
    }

    return false;  // No cycle - fast reached the end
}

// Approach 2: Hash Set - O(n) time, O(n) space
public boolean hasCycleHashSet(ListNode head) {
    Set<ListNode> visited = new HashSet<>();

    ListNode current = head;
    while (current != null) {
        if (visited.contains(current)) {
            return true;  // Found a cycle
        }
        visited.add(current);
        current = current.next;
    }

    return false;  // No cycle found
}

// Approach 3: Floyd's with Clear Variable Names
public boolean hasCycleClear(ListNode head) {
    if (head == null) return false;

    ListNode tortoise = head;
    ListNode hare = head;

    while (hare != null && hare.next != null) {
        tortoise = tortoise.next;        // Slow: 1 step
        hare = hare.next.next;           // Fast: 2 steps

        if (tortoise == hare) {
            return true;  // They met - cycle exists
        }
    }

    return false;  // Hare reached the end - no cycle
}`
        },
        python: {
          starterCode: `# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

def hasCycle(self, head: Optional[ListNode]) -> bool:
    # Write your code here
    pass`,
          solution: `# Approach 1: Floyd's Cycle Detection - O(n) time, O(1) space
def hasCycle(self, head: Optional[ListNode]) -> bool:
    if not head or not head.next:
        return False

    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next           # Move 1 step
        fast = fast.next.next      # Move 2 steps

        if slow == fast:           # Cycle detected
            return True

    return False  # No cycle - fast reached the end

# Approach 2: Hash Set - O(n) time, O(n) space
def has_cycle_hashset(self, head: Optional[ListNode]) -> bool:
    visited = set()

    current = head
    while current:
        if current in visited:
            return True  # Found a cycle
        visited.add(current)
        current = current.next

    return False  # No cycle found

# Approach 3: Floyd's with Clear Variable Names
def has_cycle_clear(self, head: Optional[ListNode]) -> bool:
    if not head:
        return False

    tortoise = head
    hare = head

    while hare and hare.next:
        tortoise = tortoise.next        # Slow: 1 step
        hare = hare.next.next           # Fast: 2 steps

        if tortoise == hare:
            return True  # They met - cycle exists

    return False  # Hare reached the end - no cycle

# Approach 4: Pythonic with walrus operator (Python 3.8+)
def has_cycle_pythonic(self, head: Optional[ListNode]) -> bool:
    slow = fast = head
    while fast and (fast := fast.next):
        slow = slow.next
        if slow == (fast := fast.next):
            return True
    return False`
        }
      },
      testCases: [
        { description: 'List: [3,2,0,-4], pos = 1 (cycle)', expected: true },
        { description: 'List: [1,2], pos = 0 (cycle)', expected: true },
        { description: 'List: [1], pos = -1 (no cycle)', expected: false },
        { description: 'List: [], pos = -1 (empty list)', expected: false }
      ],
      examples: [
        {
          input: 'head = [3,2,0,-4], pos = 1',
          output: 'true',
          explanation: 'There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).'
        },
        {
          input: 'head = [1], pos = -1',
          output: 'false',
          explanation: 'There is no cycle in the linked list.'
        }
      ]
    },
    {
      id: 3,
      title: 'Majority Element (Boyer-Moore Voting)',
      difficulty: 'Easy',
      leetcodeUrl: 'https://leetcode.com/problems/majority-element/',
      description: 'Given an array nums of size n, return the majority element. The majority element is the element that appears more than ‚åän / 2‚åã times. You may assume that the majority element always exists in the array.',
      explanation: `**Problem Understanding:**
Find the majority element (appears more than n/2 times) using Boyer-Moore Voting Algorithm.

**Key Insights - Boyer-Moore Voting:**
1. The majority element appears more than n/2 times
2. If we cancel out different elements, majority element will remain
3. Use a candidate and count approach
4. When count reaches 0, switch to a new candidate
5. The final candidate is guaranteed to be the majority element

**Why It Works:**
- Even in the worst case, the majority element appears more than all other elements combined
- Canceling different elements leaves the majority element

**Approaches:**

**Approach 1: Boyer-Moore Voting Algorithm**
- Time: O(n) - Single pass
- Space: O(1) - Constant space
- Optimal solution

**Approach 2: Hash Map**
- Time: O(n) - Count occurrences
- Space: O(n) - Store counts
- Straightforward but uses extra space

**Approach 3: Sorting**
- Time: O(n log n) - Sort the array
- Space: O(1) - In-place sort
- Middle element will be majority after sorting

**Edge Cases:**
- Single element
- All elements are the same
- Majority element at the beginning vs end`,
      pseudocode: `ALGORITHM FindMajorityElement(nums):
    candidate = NULL
    count = 0

    // Phase 1: Find candidate
    FOR each num IN nums:
        IF count == 0:
            candidate = num

        IF num == candidate:
            count = count + 1
        ELSE:
            count = count - 1

    // Phase 2: Verify candidate (optional if majority guaranteed)
    // In this problem, majority element always exists, so return candidate
    RETURN candidate

BOYER-MOORE INTUITION:
- Think of it as a voting process where different votes cancel out
- The majority candidate will always have votes remaining
- Like a battle where the majority side wins even when paired against all others

TIME COMPLEXITY: O(n) - Single pass
SPACE COMPLEXITY: O(1) - Only two variables`,
      code: {
        java: {
          starterCode: `public int majorityElement(int[] nums) {
    // Write your code here

}`,
          solution: `// Approach 1: Boyer-Moore Voting Algorithm - O(n) time, O(1) space
public int majorityElement(int[] nums) {
    int candidate = 0;
    int count = 0;

    // Phase 1: Find candidate
    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }

        if (num == candidate) {
            count++;
        } else {
            count--;
        }
    }

    // Phase 2: Verify (optional - problem guarantees majority exists)
    // In this problem, we can directly return candidate
    return candidate;
}

// Approach 2: Boyer-Moore with Verification
public int majorityElementWithVerify(int[] nums) {
    int candidate = 0;
    int count = 0;

    // Find candidate
    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }

    // Verify candidate (if majority not guaranteed)
    count = 0;
    for (int num : nums) {
        if (num == candidate) {
            count++;
        }
    }

    return count > nums.length / 2 ? candidate : -1;
}

// Approach 3: Hash Map - O(n) time, O(n) space
public int majorityElementHashMap(int[] nums) {
    Map<Integer, Integer> counts = new HashMap<>();

    for (int num : nums) {
        counts.put(num, counts.getOrDefault(num, 0) + 1);
        if (counts.get(num) > nums.length / 2) {
            return num;
        }
    }

    return -1;  // Should never reach here if majority exists
}

// Approach 4: Sorting - O(n log n) time, O(1) space
public int majorityElementSort(int[] nums) {
    Arrays.sort(nums);
    // The middle element is guaranteed to be the majority
    return nums[nums.length / 2];
}

// Approach 5: Bit Manipulation - O(32n) time, O(1) space
public int majorityElementBit(int[] nums) {
    int majority = 0;
    int n = nums.length;

    // Check each bit position
    for (int i = 0; i < 32; i++) {
        int bit = 1 << i;
        int count = 0;

        for (int num : nums) {
            if ((num & bit) != 0) {
                count++;
            }
        }

        // If more than half have this bit set
        if (count > n / 2) {
            majority |= bit;
        }
    }

    return majority;
}`
        },
        python: {
          starterCode: `def majorityElement(self, nums: List[int]) -> int:
    # Write your code here
    pass`,
          solution: `# Approach 1: Boyer-Moore Voting Algorithm - O(n) time, O(1) space
def majorityElement(self, nums: List[int]) -> int:
    candidate = None
    count = 0

    # Phase 1: Find candidate
    for num in nums:
        if count == 0:
            candidate = num

        count += 1 if num == candidate else -1

    # Phase 2: Return candidate (majority guaranteed in problem)
    return candidate

# Approach 2: Boyer-Moore with Verification
def majority_element_with_verify(self, nums: List[int]) -> int:
    # Find candidate
    candidate = None
    count = 0

    for num in nums:
        if count == 0:
            candidate = num
        count += 1 if num == candidate else -1

    # Verify candidate (if majority not guaranteed)
    if nums.count(candidate) > len(nums) // 2:
        return candidate
    return -1

# Approach 3: Hash Map (Counter) - O(n) time, O(n) space
def majority_element_counter(self, nums: List[int]) -> int:
    from collections import Counter
    counts = Counter(nums)
    return counts.most_common(1)[0][0]

# Approach 4: Sorting - O(n log n) time, O(1) space
def majority_element_sort(self, nums: List[int]) -> int:
    nums.sort()
    return nums[len(nums) // 2]

# Approach 5: Pythonic One-liner
def majority_element_oneliner(self, nums: List[int]) -> int:
    from collections import Counter
    return Counter(nums).most_common(1)[0][0]

# Approach 6: Bit Manipulation - O(32n) time, O(1) space
def majority_element_bit(self, nums: List[int]) -> int:
    majority = 0
    n = len(nums)

    for i in range(32):
        bit = 1 << i
        count = sum(1 for num in nums if num & bit)

        if count > n // 2:
            majority |= bit

    return majority`
        }
      },
      testCases: [
        { nums: [3,2,3], expected: 3 },
        { nums: [2,2,1,1,1,2,2], expected: 2 },
        { nums: [1], expected: 1 },
        { nums: [6,5,5], expected: 5 }
      ],
      examples: [
        {
          input: 'nums = [3,2,3]',
          output: '3',
          explanation: 'The majority element is 3, which appears 2 times (> 3/2).'
        },
        {
          input: 'nums = [2,2,1,1,1,2,2]',
          output: '2',
          explanation: 'The majority element is 2, which appears 4 times (> 7/2).'
        }
      ]
    }
  ]

  const [code, setCode] = useState({})
  const [output, setOutput] = useState('')
  const [isRunning, setIsRunning] = useState(false)
  const [selectedLanguage, setSelectedLanguage] = useState('java')
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)
  const saveTimeoutRef = useRef(null)

  // Handle question selection
  const handleQuestionSelect = (question) => {
    setSelectedQuestion(question)
    setOutput('')
    // Load existing drawing if any
    const problemId = `FamousAlgorithms-${question.id}`
    const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
    setCurrentDrawing(savedDrawing)
    // Load saved code or starter code for the selected question
    const problemId2 = `Famous Algorithms-${question.id}`
    const savedCode = getUserCode(problemId, selectedLanguage)
    if (savedCode) {
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: savedCode
      }))
    } else {
      const starterCode = question.code[selectedLanguage].starterCode
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: starterCode
      }))
    }
    setHasUnsavedChanges(false)
  }

  const openDrawingModal = () => {
    if (selectedQuestion) {
      const problemId = `FamousAlgorithms-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
      setShowDrawing(true)
    }
  }

  const closeDrawingModal = () => {
    setShowDrawing(false)
    // Reload drawing after saving
    if (selectedQuestion) {
      const problemId = `FamousAlgorithms-${selectedQuestion.id}`
      const savedDrawing = localStorage.getItem(`drawing-${problemId}`)
      setCurrentDrawing(savedDrawing)
    }
  }

  // Load saved code when language changes
  useEffect(() => {
    if (!selectedQuestion) return
    const problemId = `Famous Algorithms-${selectedQuestion.id}`
    const savedCode = getUserCode(problemId, selectedLanguage)

    if (savedCode) {
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: savedCode
      }))
    } else {
      // Load starter code if no saved code
      const starterCode = selectedQuestion.code[selectedLanguage].starterCode
      setCode(prev => ({
        ...prev,
        [selectedLanguage]: starterCode
      }))
    }
    setHasUnsavedChanges(false)
  }, [selectedLanguage, selectedQuestion])

  // Auto-save with debouncing
  useEffect(() => {
    if (!selectedQuestion) return
    if (hasUnsavedChanges && code[selectedLanguage]) {
      // Clear existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }

      // Set new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        const problemId = `Famous Algorithms-${selectedQuestion.id}`
        saveUserCode(problemId, code[selectedLanguage], selectedLanguage)
        setHasUnsavedChanges(false)
      }, 1000) // Save after 1 second of inactivity
    }

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }
    }
  }, [code, selectedLanguage, hasUnsavedChanges, selectedQuestion])

  // Save on unmount
  useEffect(() => {
    return () => {
      if (selectedQuestion && code[selectedLanguage]) {
        const problemId = `Famous Algorithms-${selectedQuestion.id}`
        saveUserCode(problemId, code[selectedLanguage], selectedLanguage)
      }
    }
  }, [code, selectedLanguage, selectedQuestion])

  const handleCodeChange = (e) => {
    setCode(prev => ({
      ...prev,
      [selectedLanguage]: e.target.value
    }))
    setHasUnsavedChanges(true)
  }

  const handleLanguageToggle = () => {
    setSelectedLanguage(prev => prev === 'java' ? 'python' : 'java')
  }

  const runCode = () => {
    if (!selectedQuestion) return
    setIsRunning(true)
    setOutput('Running test cases...\n\n')

    setTimeout(() => {
      const currentQuestion = selectedQuestion
      const userCode = code[selectedLanguage] || ''

      // Simple validation
      if (!userCode.trim()) {
        setOutput('Error: Please write some code first!')
        setIsRunning(false)
        return
      }

      // Check for basic syntax (very basic check)
      if (selectedLanguage === 'java') {
        if (!userCode.includes('return') && !userCode.includes('System.out')) {
          setOutput('Warning: Your code might be missing a return statement.\n\nPlease implement the solution.')
          setIsRunning(false)
          return
        }
      } else {
        if (!userCode.includes('return') && !userCode.includes('print')) {
          setOutput('Warning: Your code might be missing a return statement.\n\nPlease implement the solution.')
          setIsRunning(false)
          return
        }
      }

      let results = 'Test Results:\n\n'
      let passed = 0

      currentQuestion.testCases.forEach((testCase, index) => {
        results += `Test Case ${index + 1}: ‚úì PASS\n`
        results += `Input: ${JSON.stringify(testCase).substring(0, 100)}...\n`
        results += `Expected: ${JSON.stringify(testCase.expected)}\n\n`
        passed++
      })

      results += `\n${passed}/${currentQuestion.testCases.length} test cases passed!\n`
      results += '\nNote: This is a simulated test environment. Submit to LeetCode for actual validation.'

      setOutput(results)
      setIsRunning(false)
    }, 1500)
  }

  const showSolution = () => {
    if (!selectedQuestion) return
    const solution = selectedQuestion.code[selectedLanguage].solution
    setCode(prev => ({
      ...prev,
      [selectedLanguage]: solution
    }))
    setHasUnsavedChanges(true)
    setOutput('Solution loaded! Read through the code and comments to understand the approach.')
  }

  const resetCode = () => {
    if (!selectedQuestion) return
    const starterCode = selectedQuestion.code[selectedLanguage].starterCode
    setCode(prev => ({
      ...prev,
      [selectedLanguage]: starterCode
    }))
    setHasUnsavedChanges(true)
    setOutput('')
  }

  const goToPreviousProblem = () => {
    if (!selectedQuestion) return
    const currentIndex = questions.findIndex(q => q.id === selectedQuestion.id)
    if (currentIndex > 0) {
      handleQuestionSelect(questions[currentIndex - 1])
    }
  }

  const goToNextProblem = () => {
    if (!selectedQuestion) return
    const currentIndex = questions.findIndex(q => q.id === selectedQuestion.id)
    if (currentIndex < questions.length - 1) {
      handleQuestionSelect(questions[currentIndex + 1])
    }
  }

  // QuestionCard component for the list view
  const QuestionCard = ({ question }) => {
    const problemId = `Famous Algorithms-${question.id}`
    const isCompleted = isProblemCompleted(problemId)

    return (
      <div
        onClick={() => handleQuestionSelect(question)}
        className="bg-white rounded-xl shadow-lg p-6 mb-4 cursor-pointer hover:shadow-xl transition-all hover:-translate-y-1"
        style={{
          border: isCompleted ? '3px solid #10b981' : '2px solid #e5e7eb'
        }}
      >
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-xl font-bold text-gray-900">
            {isCompleted && <span className="text-green-600 mr-2">‚úì</span>}
            {question.id}. {question.title}
          </h3>
          <div className="flex items-center gap-3">
            <a
              href={question.leetcodeUrl}
              target="_blank"
              rel="noopener noreferrer"
              onClick={(e) => e.stopPropagation()}
              className="px-3 py-1 text-sm font-medium text-blue-600 bg-blue-50 border border-blue-600 rounded-lg hover:bg-blue-600 hover:text-white transition-colors"
            >
              LeetCode ‚Üí
            </a>
            <span className={`px-3 py-1 rounded-full text-sm font-medium ${
              question.difficulty === 'Easy' ? 'bg-green-100 text-green-800' :
              question.difficulty === 'Medium' ? 'bg-yellow-100 text-yellow-800' :
              'bg-red-100 text-red-800'
            }`}>
              {question.difficulty}
            </span>
          </div>
        </div>
        <p className="text-gray-600 text-sm line-clamp-2">
          {question.description}
        </p>
      </div>
    )
  }

  const currentCode = selectedQuestion ? (code[selectedLanguage] || selectedQuestion.code[selectedLanguage].starterCode) : ''

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 p-8">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-xl shadow-lg p-6 mb-8">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h1 className="text-4xl font-bold text-gray-900 mb-2">‚≠ê Famous Algorithms</h1>
              <p className="text-gray-600">Master legendary algorithms every programmer should know</p>
            </div>
            {selectedQuestion && (
              <CompletionCheckbox
                problemId={`Famous Algorithms-${selectedQuestion.id}`}
                title={selectedQuestion.title}
              />
            )}
          </div>

          {/* Back button - always visible */}
          <div className="flex items-center gap-3">
            <button
              onClick={onBack}
              className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors font-semibold"
            >
              ‚Üê Back to Practice
            </button>
            {selectedQuestion && (
              <button
                onClick={() => setSelectedQuestion(null)}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
              >
                ‚Üê Back to Problem List
              </button>
            )}
          </div>
        </div>

        {/* Problem List View */}
        {!selectedQuestion && (
          <div>
            <h2 className="text-2xl font-bold text-gray-900 mb-6">
              Select a Problem ({questions.length} problems)
            </h2>
            <div className="space-y-4">
              {questions.map(question => (
                <QuestionCard key={question.id} question={question} />
              ))}
            </div>
          </div>
        )}

        {/* Problem Details - Only show when a question is selected */}
        {selectedQuestion && (
          <>
            {/* Navigation within problem view */}
            <div className="flex items-center justify-center gap-4 mb-6">
              <button
                onClick={goToPreviousProblem}
                disabled={questions.findIndex(q => q.id === selectedQuestion.id) === 0}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                ‚Üê Previous
              </button>
              <span className="text-sm font-medium text-gray-600">
                Problem {selectedQuestion.id} of {questions.length}
              </span>
              <button
                onClick={goToNextProblem}
                disabled={questions.findIndex(q => q.id === selectedQuestion.id) === questions.length - 1}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                Next ‚Üí
              </button>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
              {/* Left Column - Problem Description */}
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-2xl font-bold text-gray-900">{selectedQuestion.title}</h2>
                  <span className={`px-3 py-1 rounded-full text-sm font-medium ${
                    selectedQuestion.difficulty === 'Easy' ? 'bg-green-100 text-green-800' :
                    selectedQuestion.difficulty === 'Medium' ? 'bg-yellow-100 text-yellow-800' :
                    'bg-red-100 text-red-800'
                  }`}>
                    {selectedQuestion.difficulty}
                  </span>
                </div>

                <a
                  href={selectedQuestion.leetcodeUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="inline-flex items-center text-blue-600 hover:text-blue-800 mb-4"
                >
                  View on LeetCode ‚Üí
                </a>

                <div className="prose max-w-none">
                  <h3 className="text-lg font-semibold text-gray-900 mb-2">Problem Description</h3>
                  <p className="text-gray-700 mb-4">{selectedQuestion.description}</p>

                  <h3 className="text-lg font-semibold text-gray-900 mb-2">Examples</h3>
                  {selectedQuestion.examples.map((example, index) => (
                    <div key={index} className="bg-gray-50 rounded-lg p-4 mb-3">
                      <p className="font-mono text-sm mb-1"><strong>Input:</strong> {example.input}</p>
                      <p className="font-mono text-sm mb-1"><strong>Output:</strong> {example.output}</p>
                      <p className="text-sm text-gray-600"><strong>Explanation:</strong> {example.explanation}</p>
                    </div>
                  ))}

                  <h3 className="text-lg font-semibold text-gray-900 mb-2 mt-6">Explanation</h3>
                  <div className="bg-purple-50 rounded-lg p-4 whitespace-pre-line text-sm">
                    {selectedQuestion.explanation}
                  </div>

                  <h3 className="text-lg font-semibold text-gray-900 mb-2 mt-6">Pseudocode</h3>
                  <pre className="bg-gray-900 text-gray-100 rounded-lg p-4 overflow-x-auto text-sm">
                    {selectedQuestion.pseudocode}
                  </pre>
                </div>
              </div>

          {/* Right Column - Code Editor */}
          <div className="bg-white rounded-xl shadow-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold text-gray-900">Code Editor</h3>
              <div className="flex items-center gap-2">
                <button
                  onClick={handleLanguageToggle}
                  className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors text-sm font-medium"
                >
                  {selectedLanguage === 'java' ? '‚òï Java' : 'üêç Python'}
                </button>
                {hasUnsavedChanges && (
                  <span className="text-sm text-orange-600">‚óè Unsaved</span>
                )}
              </div>
            </div>

            <textarea
              value={currentCode}
              onChange={handleCodeChange}
              className="w-full h-96 p-4 font-mono text-sm bg-gray-900 text-gray-100 rounded-lg focus:ring-2 focus:ring-purple-500 focus:outline-none resize-none"
              spellCheck="false"
              placeholder="Write your code here..."
            />

            <div className="flex gap-3 mt-4">
              <button
                onClick={runCode}
                disabled={isRunning}
                className="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 transition-colors font-medium"
              >
                {isRunning ? 'Running...' : '‚ñ∂ Run Code'}
              </button>
              <button
                onClick={showSolution}
                className="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors font-medium"
              >
                üí° Solution
              </button>
              <button
                onClick={resetCode}
                className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium"
              >
                ‚Ü∫ Reset
              </button>
              <button
                onClick={openDrawingModal}
                className={`px-4 py-2 text-white rounded-lg transition-colors font-medium ${
                  currentDrawing ? 'bg-purple-600 hover:bg-purple-700' : 'bg-indigo-600 hover:bg-indigo-700'
                }`}
              >
                {currentDrawing ? '‚úèÔ∏è Edit Drawing' : 'üé® Draw'}
              </button>
            </div>

            {/* Drawing Preview Section */}
            {currentDrawing && (
              <div className="mt-4">
                <div className="flex justify-between items-center mb-2">
                  <h4 className="text-sm font-semibold text-gray-900">üé® Your Drawing</h4>
                  <button
                    onClick={openDrawingModal}
                    className="px-3 py-1 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700 transition-colors"
                  >
                    ‚úèÔ∏è Edit
                  </button>
                </div>
                <div className="bg-gray-50 p-4 rounded-lg border-2 border-gray-200 text-center">
                  <img
                    src={currentDrawing}
                    alt="Your drawing"
                    className="max-w-full h-auto rounded"
                  />
                </div>
              </div>
            )}

            {/* Output Panel */}
            {output && (
              <div className="mt-4">
                <h4 className="text-sm font-semibold text-gray-900 mb-2">Output:</h4>
                <pre className="bg-gray-900 text-gray-100 rounded-lg p-4 overflow-x-auto text-sm whitespace-pre-wrap">
                  {output}
                </pre>
              </div>
            )}
          </div>
        </div>

        <KeyboardGuide />
      </>
    )}

      {/* Drawing Canvas Modal */}
      <DrawingCanvas
        isOpen={showDrawing}
        onClose={closeDrawingModal}
        problemId={selectedQuestion ? `FamousAlgorithms-${selectedQuestion.id}` : ''}
        existingDrawing={currentDrawing}
      />
      </div>
    </div>
  )
}

export default FamousAlgorithms
