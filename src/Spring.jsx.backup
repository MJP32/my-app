import { useState, useEffect, useRef } from 'react'

// Simple syntax highlighter for Java code
const SyntaxHighlighter = ({ code }) => {
  const highlightJava = (code) => {
    let highlighted = code
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')

    // Store protected content with placeholders
    const protectedContent = []
    let placeholder = 0

    // Protect comments first
    highlighted = highlighted.replace(/(\/\/.*$|\/\*[\s\S]*?\*\/)/gm, (match) => {
      const id = `___COMMENT_${placeholder++}___`
      protectedContent.push({ id, replacement: `<span style="color: #6a9955; font-style: italic;">${match}</span>` })
      return id
    })

    // Protect strings
    highlighted = highlighted.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, (match) => {
      const id = `___STRING_${placeholder++}___`
      protectedContent.push({ id, replacement: `<span style="color: #ce9178;">${match}</span>` })
      return id
    })

    // Apply syntax highlighting to remaining code
    highlighted = highlighted
      // Keywords - purple
      .replace(/\b(public|private|protected|static|final|class|interface|extends|implements|new|return|if|else|for|while|do|switch|case|break|continue|try|catch|finally|throw|throws|import|package|void|abstract|synchronized|volatile|transient|native|strictfp|super|this|null)\b/g, '<span style="color: #c586c0;">$1</span>')

      // Boolean and primitives - blue
      .replace(/\b(true|false|int|double|float|long|short|byte|char|boolean)\b/g, '<span style="color: #569cd6;">$1</span>')

      // Types and classes - light green
      .replace(/\b(String|List|ArrayList|LinkedList|HashMap|TreeMap|HashSet|TreeSet|Map|Set|Queue|Deque|Collection|Arrays|Collections|Thread|Runnable|Executor|ExecutorService|CompletableFuture|Stream|Optional|Path|Files|Pattern|Matcher|StringBuilder|StringBuffer|Integer|Double|Float|Long|Short|Byte|Character|Boolean|Object|System|Math|Scanner|BufferedReader|FileReader|FileWriter|PrintWriter|InputStream|OutputStream|Exception|RuntimeException|IOException|SQLException|WeakReference|SoftReference|PhantomReference|ReferenceQueue)\b/g, '<span style="color: #4ec9b0;">$1</span>')

      // Annotations - yellow
      .replace(/(@\w+)/g, '<span style="color: #dcdcaa;">$1</span>')

      // Numbers - light green
      .replace(/\b(\d+\.?\d*[fLdD]?)\b/g, '<span style="color: #b5cea8;">$1</span>')

      // Method calls - yellow
      .replace(/\b([a-z_]\w*)\s*\(/g, '<span style="color: #dcdcaa;">$1</span>(')

    // Restore protected content
    protectedContent.forEach(({ id, replacement }) => {
      highlighted = highlighted.replace(id, replacement)
    })

    return highlighted
  }

  return (
    <pre style={{
      margin: 0,
      fontFamily: '"Consolas", "Monaco", "Courier New", monospace',
      fontSize: '0.85rem',
      lineHeight: '1.6',
      color: '#d4d4d4',
      whiteSpace: 'pre',
      overflowX: 'auto',
      textAlign: 'left',
      padding: 0
    }}>
      <code dangerouslySetInnerHTML={{ __html: highlightJava(code) }} />
    </pre>
  )
}

        </g>

        {/* Component rectangles */}
        {components.map((component, index) => {
          const isFocused = focusedIndex === index
          const isHovered = hoveredComponent === component.id
          const isHighlighted = isFocused || isHovered

          return (
          <g key={component.id}>
            {/* Focused ring indicator */}
            {isFocused && (
              <rect
                x={component.x - 6}
                y={component.y - 6}
                width={component.width + 12}
                height={component.height + 12}
                rx="16"
                ry="16"
                fill="none"
                stroke="#fbbf24"
                strokeWidth="4"
                style={{
                  opacity: 0.9,
                  filter: 'drop-shadow(0 0 12px rgba(251, 191, 36, 0.6))'
                }}
              />
            )}
            <rect
              x={component.x}
              y={component.y}
              width={component.width}
              height={component.height}
              rx="12"
              ry="12"
              fill={`url(#${component.color}Gradient)`}
              stroke={isHighlighted ? '#1e293b' : '#64748b'}
              strokeWidth={isHighlighted ? '4' : '2'}
              style={{
                cursor: 'pointer',
                filter: isHighlighted ? 'drop-shadow(0 8px 16px rgba(0,0,0,0.2))' : 'drop-shadow(0 4px 8px rgba(0,0,0,0.1))',
                transform: isHighlighted ? 'scale(1.05)' : 'scale(1)',
                transformOrigin: `${component.x + component.width/2}px ${component.y + component.height/2}px`,
                transition: 'all 0.2s ease'
              }}
              onMouseEnter={() => setHoveredComponent(component.id)}
              onMouseLeave={() => setHoveredComponent(null)}
              onClick={() => onComponentClick && onComponentClick(component)}
            />

            {/* Icon */}
            <text
              x={component.x + component.width/2}
              y={component.y + 35}
              textAnchor="middle"
              fontSize="48"
              style={{ userSelect: 'none', pointerEvents: 'none' }}
            >
              {component.icon}
            </text>

            {/* Title */}
            <text
              x={component.x + component.width/2}
              y={component.y + 75}
              textAnchor="middle"
              fontSize="18"
              fontWeight="700"
              fill="white"
              style={{ userSelect: 'none', pointerEvents: 'none' }}
            >
              {component.title}
            </text>

            {/* Details */}
            {component.details && component.details.slice(0, 3).map((detail, idx) => (
              <text
                key={idx}
                x={component.x + component.width/2}
                y={component.y + 100 + (idx * 15)}
                textAnchor="middle"
                fontSize="10"
                fontWeight="500"
                fill="rgba(255,255,255,0.9)"
                style={{ userSelect: 'none', pointerEvents: 'none' }}
              >
                {detail.name.length > 18 ? detail.name.substring(0, 15) + '...' : detail.name}
              </text>
            ))}
            {component.details && component.details.length > 3 && (
              <text
                x={component.x + component.width/2}
                y={component.y + 145}
                textAnchor="middle"
                fontSize="10"
                fontWeight="500"
                fill="rgba(255,255,255,0.7)"
                style={{ userSelect: 'none', pointerEvents: 'none' }}
              >
                +{component.details.length - 3} more features...
              </text>
            )}
          </g>
        )})}
      </svg>
    </div>
  )
}

function Spring({ onBack }) {
  const [selectedComponent, setSelectedComponent] = useState(null)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [selectedConcept, setSelectedConcept] = useState(null)
  const [focusedComponentIndex, setFocusedComponentIndex] = useState(0)
  const [expandedSections, setExpandedSections] = useState({})

  const toggleSection = (sectionId) => {
    setExpandedSections(prev => ({
      ...prev,
      [sectionId]: !prev[sectionId]
    }))
  }

  // Parse code into sections
  const parseCodeSections = (code) => {
    const sections = []
    const lines = code.split('\n')
    let currentSection = null
    let currentCode = []

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]
      // Check for section headers (lines with ‚ïê and ‚ú¶)
      if (line.includes('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê') && lines[i + 1]?.includes('‚ú¶')) {
        // Save previous section
        if (currentSection) {
          sections.push({
            title: currentSection,
            code: currentCode.join('\n')
          })
        }
        // Start new section
        const titleLine = lines[i + 1]
        currentSection = titleLine.replace(/\/\/\s*‚ú¶\s*/g, '').trim()
        currentCode = []
        continue
      }

      // Skip separator lines
      if (line.includes('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')) {
        continue
      }

      // Add code to current section
      if (currentSection) {
        currentCode.push(line)
      }
    }

    // Add last section
    if (currentSection && currentCode.length > 0) {
      sections.push({
        title: currentSection,
        code: currentCode.join('\n')
      })
    }

    return sections
  }

  const components = [
    {
      id: 'spring-framework', x: 80, y: 80, width: 350, height: 140,
      icon: 'üå±', title: 'Spring Framework', color: 'blue',
      details: [
        {
          name: 'Core Container',
          explanation: 'Foundation of Spring providing IoC container and DI. BeanFactory for basic container functionality. ApplicationContext extends BeanFactory with enterprise features. Supports XML, Java, and annotation-based configuration. Central to all Spring applications.',
          codeExample: `// Basic Spring configuration
@Configuration
public class AppConfig {

  @Bean
  public UserService userService() {
    return new UserServiceImpl(userRepository());
  }

  @Bean
  public UserRepository userRepository() {
    return new JpaUserRepository();
  }
}

// Using ApplicationContext
public class Application {
  public static void main(String[] args) {
    ApplicationContext context =
      new AnnotationConfigApplicationContext(AppConfig.class);

    UserService userService = context.getBean(UserService.class);
    userService.processUser();
  }
}
// Output: Beans created and managed by Spring container`
        },
        {
          name: 'Dependency Injection',
          explanation: 'Core pattern of Spring Framework. Constructor, setter, and field injection. @Autowired for automatic dependency resolution. Constructor injection recommended for immutability. Reduces coupling and increases testability.',
          codeExample: `// Constructor injection (recommended)
@Service
public class OrderService {
  private final OrderRepository orderRepository;
  private final PaymentService paymentService;

  @Autowired
  public OrderService(OrderRepository orderRepository,
                      PaymentService paymentService) {
    this.orderRepository = orderRepository;
    this.paymentService = paymentService;
  }

  public void processOrder(Order order) {
    orderRepository.save(order);
    paymentService.processPayment(order);
  }
}

// Field injection (not recommended)
@Service
public class NotificationService {
  @Autowired
  private EmailSender emailSender;

  public void sendNotification(String email, String message) {
    emailSender.send(email, message);
  }
}

// Setter injection
@Service
public class ReportService {
  private DataSource dataSource;

  @Autowired
  public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
  }
}
// Output: Dependencies automatically injected by Spring`
        },
        {
          name: 'Bean Lifecycle',
          explanation: 'Spring manages complete bean lifecycle. Initialization with @PostConstruct and InitializingBean. Destruction with @PreDestroy and DisposableBean. Custom init-method and destroy-method. Awareness interfaces for container access.',
          codeExample: `@Component
public class DatabaseConnection {

  @PostConstruct
  public void init() {
    System.out.println("Initializing database connection");
    // Connect to database
  }

  @PreDestroy
  public void cleanup() {
    System.out.println("Closing database connection");
    // Close connection
  }
}

// Using interfaces
@Component
public class CacheManager implements InitializingBean, DisposableBean {

  @Override
  public void afterPropertiesSet() throws Exception {
    System.out.println("Cache warming up");
    // Initialize cache
  }

  @Override
  public void destroy() throws Exception {
    System.out.println("Clearing cache");
    // Clear cache
  }
}

// Custom lifecycle methods
@Configuration
public class LifecycleConfig {

  @Bean(initMethod = "start", destroyMethod = "stop")
  public ConnectionPool connectionPool() {
    return new HikariConnectionPool();
  }
}
// Output: Lifecycle callbacks executed at appropriate times`
        },
        {
          name: 'AOP Support',
          explanation: 'Aspect-Oriented Programming for cross-cutting concerns. Proxy-based AOP using JDK dynamic proxies or CGLIB. @Aspect for defining aspects. Before, After, Around advice. Transaction management and declarative security.',
          codeExample: `@Aspect
@Component
public class LoggingAspect {

  @Before("execution(* com.example.service.*.*(..))")
  public void logBefore(JoinPoint joinPoint) {
    System.out.println("Before: " + joinPoint.getSignature().getName());
  }

  @AfterReturning(
    pointcut = "execution(* com.example.service.*.*(..))",
    returning = "result")
  public void logAfterReturning(JoinPoint joinPoint, Object result) {
    System.out.println("After returning: " + result);
  }

  @Around("@annotation(Transactional)")
  public Object logExecutionTime(ProceedingJoinPoint joinPoint)
      throws Throwable {
    long start = System.currentTimeMillis();
    Object proceed = joinPoint.proceed();
    long executionTime = System.currentTimeMillis() - start;
    System.out.println(joinPoint.getSignature() +
                       " executed in " + executionTime + "ms");
    return proceed;
  }
}
// Output: Logging applied to all service methods automatically`
        },
        {
          name: 'Resource Management',
          explanation: 'Unified abstraction for resource access. Resource interface for files, classpath, URL resources. ResourceLoader for loading resources. @Value for property injection. Environment abstraction for profiles and properties.',
          codeExample: `@Component
public class ResourceReader {

  @Autowired
  private ResourceLoader resourceLoader;

  @Value("classpath:config/application.properties")
  private Resource configFile;

  public void readResource() throws IOException {
    Resource resource =
      resourceLoader.getResource("classpath:data/users.json");

    try (InputStream is = resource.getInputStream()) {
      String content = new String(is.readAllBytes());
      System.out.println(content);
    }
  }

  @Value("\${app.name}")
  private String appName;

  @Value("\${app.version:1.0.0}")
  private String version;

  public void printConfig() {
    System.out.println("App: " + appName + " v" + version);
  }
}
// Output: Resources loaded from various locations seamlessly`
        },
        {
          name: 'Transaction Management',
          explanation: 'Declarative transaction management with @Transactional. Programmatic transactions with TransactionTemplate. Propagation and isolation levels. Multiple transaction managers support. JTA for distributed transactions.',
          codeExample: `@Service
public class TransferService {

  @Autowired
  private AccountRepository accountRepository;

  @Transactional(propagation = Propagation.REQUIRED,
                 isolation = Isolation.READ_COMMITTED,
                 rollbackFor = Exception.class)
  public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    Account from = accountRepository.findById(fromId)
      .orElseThrow(() -> new AccountNotFoundException());
    Account to = accountRepository.findById(toId)
      .orElseThrow(() -> new AccountNotFoundException());

    from.withdraw(amount);
    to.deposit(amount);

    accountRepository.save(from);
    accountRepository.save(to);
  }
}

// Programmatic transaction
@Service
public class BatchProcessor {

  @Autowired
  private TransactionTemplate transactionTemplate;

  public void processBatch(List<Item> items) {
    transactionTemplate.execute(status -> {
      try {
        items.forEach(this::processItem);
        return null;
      } catch (Exception e) {
        status.setRollbackOnly();
        throw e;
      }
    });
  }
}
// Output: Automatic transaction management with rollback on exception`
        }
      ],
      description: 'Core Spring Framework providing IoC container, dependency injection, AOP, and resource management.'
    },
    {
      id: 'spring-boot', x: 80, y: 260, width: 350, height: 160,
      icon: 'üöÄ', title: 'Spring Boot', color: 'green',
      details: [
        {
          name: 'Auto-Configuration',
          explanation: 'Spring Boot automatically configures application based on dependencies in classpath. Reduces boilerplate configuration dramatically. Conditional bean creation based on presence of classes. Opinionated defaults with override capability. @SpringBootApplication combines @Configuration, @EnableAutoConfiguration, @ComponentScan.',
          codeExample: `import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan
@SpringBootApplication
public class MyApplication {
  public static void main(String[] args) {
    SpringApplication.run(MyApplication.class, args);
  }
}
// Output: Application started on port 8080

// Custom auto-configuration
@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)
public class DataSourceAutoConfiguration {

  @Bean
  public DataSource dataSource() {
    HikariDataSource dataSource = new HikariDataSource();
    dataSource.setJdbcUrl("jdbc:h2:mem:testdb");
    dataSource.setUsername("sa");
    dataSource.setPassword("");
    return dataSource;
  }
}
// Auto-configured only if DataSource class exists and no DataSource bean defined

// Conditional beans
@Configuration
public class MyConfiguration {

  @Bean
  @ConditionalOnProperty(name = "app.feature.enabled", havingValue = "true")
  public FeatureService featureService() {
    return new FeatureService();
  }

  @Bean
  @Profile("dev")
  public DataSource devDataSource() {
    return new H2DataSource();
  }

  @Bean
  @Profile("prod")
  public DataSource prodDataSource() {
    return new PostgresDataSource();
  }
}

// Excluding auto-configurations
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class CustomApplication {
  public static void main(String[] args) {
    SpringApplication.run(CustomApplication.class, args);
  }
}
// Output: Application started without DataSource auto-configuration`
        },
        {
          name: 'Starter Dependencies',
          explanation: 'Curated sets of dependencies for common use cases. spring-boot-starter-web includes Tomcat, Spring MVC, Jackson. spring-boot-starter-data-jpa includes Hibernate, Spring Data JPA. Eliminates version management complexity. Ensures compatible dependency versions.',
          codeExample: `// pom.xml - Maven starter dependencies
/*
<dependencies>
  <!-- Web starter: Tomcat, Spring MVC, Jackson, Validation -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>

  <!-- JPA starter: Hibernate, Spring Data JPA, JDBC -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
  </dependency>

  <!-- Security starter: Spring Security, OAuth2 -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
  </dependency>

  <!-- Test starter: JUnit, Mockito, AssertJ, Spring Test -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
  </dependency>
</dependencies>
*/

// REST Controller with web starter
@RestController
@RequestMapping("/api")
public class UserController {

  @Autowired
  private UserRepository userRepository;

  @GetMapping("/users")
  public List<User> getUsers() {
    return userRepository.findAll();
  }

  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
    return userRepository.save(user);
  }
}
// Output: GET /api/users returns JSON array

// JPA Entity with data-jpa starter
@Entity
@Table(name = "users")
public class User {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;
  private String email;

  // Getters and setters
}

// Repository interface - no implementation needed
public interface UserRepository extends JpaRepository<User, Long> {
  List<User> findByName(String name);
  Optional<User> findByEmail(String email);
}
// Output: Automatic CRUD operations + custom queries

// Testing with test starter
@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {

  @Autowired
  private MockMvc mockMvc;

  @Test
  void testGetUsers() throws Exception {
    mockMvc.perform(get("/api/users"))
      .andExpect(status().isOk())
      .andExpect(content().contentType(MediaType.APPLICATION_JSON));
  }
}
// Output: Test passed`
        },
        {
          name: 'Embedded Servers',
          explanation: 'Embedded Tomcat, Jetty, or Undertow. No need for separate application server deployment. Standalone executable JAR with java -jar command. Simplifies deployment and development. Easy containerization for Docker and Kubernetes.',
          codeExample: `// Default embedded Tomcat (included in spring-boot-starter-web)
@SpringBootApplication
public class EmbeddedServerApp {
  public static void main(String[] args) {
    SpringApplication.run(EmbeddedServerApp.class, args);
  }
}
// Output: Tomcat started on port 8080

// application.properties - Server configuration
/*
server.port=9090
server.servlet.context-path=/myapp
server.tomcat.max-threads=200
server.tomcat.max-connections=10000
server.compression.enabled=true
*/

// Programmatic server configuration
@Configuration
public class ServerConfig {

  @Bean
  public WebServerFactoryCustomizer<TomcatServletWebServerFactory>
      customizer() {
    return factory -> {
      factory.setPort(9090);
      factory.setContextPath("/myapp");
      factory.addConnectorCustomizers(connector -> {
        connector.setMaxThreads(200);
      });
    };
  }
}

// Switch to Jetty (exclude Tomcat, add Jetty)
/*
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
*/

// SSL/HTTPS configuration
/*
server.port=8443
server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=password
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=tomcat
*/

// Building executable JAR
// mvn clean package
// java -jar target/myapp.jar
// Output: Application running on embedded Tomcat at https://localhost:8443

// Docker deployment
/*
FROM openjdk:17-jdk-slim
COPY target/myapp.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]
*/
// docker build -t myapp:latest .
// docker run -p 8080:8080 myapp:latest
// Output: Containerized app running on port 8080`
        },
        {
          name: 'Actuator',
          explanation: 'Production-ready features for monitoring and management. Health checks, metrics, info endpoints. JMX and HTTP exposure. Integration with Prometheus, Grafana. Custom endpoints and metrics support. Essential for microservices observability.',
          codeExample: `// Add actuator dependency
/*
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
*/

// application.properties - Enable actuator endpoints
/*
management.endpoints.web.exposure.include=health,info,metrics,env,beans
management.endpoint.health.show-details=always
management.metrics.export.prometheus.enabled=true
*/

// Access health endpoint
// GET http://localhost:8080/actuator/health
/*
{
  "status": "UP",
  "components": {
    "db": {"status": "UP", "details": {"database": "H2"}},
    "diskSpace": {"status": "UP", "details": {"free": "100GB"}}
  }
}
*/

// Custom health indicator
@Component
public class CustomHealthIndicator implements HealthIndicator {

  @Override
  public Health health() {
    boolean healthy = checkExternalService();
    if (healthy) {
      return Health.up()
        .withDetail("service", "available")
        .build();
    }
    return Health.down()
      .withDetail("service", "unavailable")
      .withDetail("error", "Connection timeout")
      .build();
  }

  private boolean checkExternalService() {
    // Check external service health
    return true;
  }
}
// Output: /actuator/health includes custom indicator

// Custom metrics
@Service
public class OrderService {

  private final Counter orderCounter;
  private final Timer orderTimer;

  public OrderService(MeterRegistry registry) {
    this.orderCounter = Counter.builder("orders.created")
      .description("Total orders created")
      .tag("type", "online")
      .register(registry);

    this.orderTimer = Timer.builder("orders.processing.time")
      .description("Order processing time")
      .register(registry);
  }

  public Order createOrder(Order order) {
    return orderTimer.record(() -> {
      Order saved = orderRepository.save(order);
      orderCounter.increment();
      return saved;
    });
  }
}
// Output: /actuator/metrics/orders.created

// Custom actuator endpoint
@Component
@Endpoint(id = "custom")
public class CustomEndpoint {

  @ReadOperation
  public Map<String, Object> customInfo() {
    Map<String, Object> info = new HashMap<>();
    info.put("version", "1.0.0");
    info.put("environment", "production");
    info.put("uptime", getUptime());
    return info;
  }

  @WriteOperation
  public void resetCache() {
    // Reset application cache
    System.out.println("Cache reset");
  }
}
// Output: GET /actuator/custom returns custom info
// Output: POST /actuator/custom resets cache

// Prometheus metrics endpoint
// GET http://localhost:8080/actuator/prometheus
/*
# HELP orders_created_total Total orders created
# TYPE orders_created_total counter
orders_created_total{type="online"} 150.0

# HELP orders_processing_time_seconds Order processing time
# TYPE orders_processing_time_seconds summary
orders_processing_time_seconds_count 150
orders_processing_time_seconds_sum 45.5
*/`
        },
        {
          name: 'DevTools',
          explanation: 'Automatic application restart on code changes. LiveReload integration for browser refresh. Property defaults for development. Caching disabled in development. Faster development feedback loop.',
          codeExample: `// Add DevTools dependency (automatically disabled in production)
/*
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-devtools</artifactId>
  <optional>true</optional>
</dependency>
*/

// Automatic restart demonstration
@RestController
public class HelloController {

  @GetMapping("/hello")
  public String hello() {
    return "Hello, World!";
  }
}
// Modify return value to "Hello, Spring Boot!"
// Save file
// Output: Application automatically restarts
// Output: GET /hello returns "Hello, Spring Boot!"

// DevTools configuration
// application-dev.properties
/*
spring.devtools.restart.enabled=true
spring.devtools.restart.additional-paths=src/main/resources
spring.devtools.restart.exclude=static/**,public/**
spring.devtools.livereload.enabled=true
spring.devtools.livereload.port=35729
*/

// Restart vs Reload
// Restart: Full application context refresh (code changes)
// Reload: Static resources only (HTML, CSS, JS)

// Trigger restart programmatically
@Component
public class RestartService {

  @Autowired
  private RestartEndpoint restartEndpoint;

  public void triggerRestart() {
    restartEndpoint.restart();
    System.out.println("Application restarting...");
  }
}

// Remote DevTools (for cloud deployments)
/*
spring.devtools.remote.secret=mysecret
spring.devtools.remote.context-path=/devtools
*/
// java -jar spring-boot-devtools.jar http://localhost:8080

// Exclude from restart
@Component
public class StaticDataLoader {

  @PostConstruct
  public void loadData() {
    // This won't reload on restart
    System.out.println("Loading static data once");
  }
}

// Development property defaults
// DevTools automatically sets:
/*
spring.thymeleaf.cache=false
spring.freemarker.cache=false
spring.groovy.template.cache=false
spring.h2.console.enabled=true
server.error.include-message=always
server.error.include-binding-errors=always
*/

// Performance improvement
// Before DevTools: Code change -> Stop -> Compile -> Start (30-60 seconds)
// With DevTools: Code change -> Save -> Auto-restart (5-10 seconds)
// Output: 6x faster development cycle

// LiveReload browser extension integration
// Install LiveReload extension
// Make changes to HTML/CSS
// Output: Browser automatically refreshes`
        },
        {
          name: 'Configuration Properties',
          explanation: '@ConfigurationProperties for type-safe configuration. Externalized configuration via application.properties/yml. Profile-specific configurations. Environment variable overrides. Validation with JSR-303 annotations.',
          codeExample: `// application.yml
/*
app:
  name: MyApplication
  version: 1.0.0
  security:
    jwt-secret: secret-key
    token-expiration: 3600
  email:
    host: smtp.gmail.com
    port: 587
    username: user@example.com
    password: password
*/

// Type-safe configuration properties
@Component
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {

  @NotNull
  private String name;

  @NotNull
  private String version;

  private Security security = new Security();
  private Email email = new Email();

  // Getters and setters

  public static class Security {
    @NotBlank
    private String jwtSecret;

    @Min(60)
    @Max(86400)
    private int tokenExpiration;

    // Getters and setters
  }

  public static class Email {
    private String host;
    private int port;
    private String username;
    private String password;

    // Getters and setters
  }
}

// Enable configuration properties
@SpringBootApplication
@EnableConfigurationProperties(AppProperties.class)
public class Application {
  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}

// Using configuration properties
@Service
public class JwtService {

  @Autowired
  private AppProperties appProperties;

  public String generateToken(String username) {
    String secret = appProperties.getSecurity().getJwtSecret();
    int expiration = appProperties.getSecurity().getTokenExpiration();

    return Jwts.builder()
      .setSubject(username)
      .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
      .signWith(SignatureAlgorithm.HS512, secret)
      .compact();
  }
}
// Output: JWT token with configured secret and expiration

// Profile-specific configuration
// application-dev.yml
/*
app:
  security:
    jwt-secret: dev-secret
logging:
  level:
    root: DEBUG
*/

// application-prod.yml
/*
app:
  security:
    jwt-secret: prod-secret-from-vault
logging:
  level:
    root: WARN
*/

// Activate profile
// java -jar app.jar --spring.profiles.active=prod

// Environment variable override
// export APP_SECURITY_JWT_SECRET=env-secret
// export APP_SECURITY_TOKEN_EXPIRATION=7200
// java -jar app.jar
// Output: Environment variables override application.yml

// @Value annotation (for simple cases)
@Component
public class SimpleConfig {

  @Value("\${app.name}")
  private String appName;

  @Value("\${app.version:1.0.0}")  // Default value
  private String version;

  @Value("\${app.features:feature1,feature2}")
  private List<String> features;

  public void printConfig() {
    System.out.println("App: " + appName + " v" + version);
    System.out.println("Features: " + features);
  }
}
// Output: App: MyApplication v1.0.0
// Output: Features: [feature1, feature2]

// Validation
@ConfigurationProperties(prefix = "database")
@Validated
public class DatabaseProperties {

  @NotNull
  @Pattern(regexp = "jdbc:.*")
  private String url;

  @NotBlank
  private String username;

  @NotBlank
  private String password;

  @Min(1)
  @Max(100)
  private int maxConnections = 10;

  // Getters and setters
}
// Invalid configuration throws exception at startup`
        }
      ],
      description: 'Opinionated framework for building production-ready Spring applications with minimal configuration and embedded servers.'
    },
    {
      id: 'spring-core', x: 580, y: 140, width: 350, height: 160,
      icon: 'üíé', title: 'Spring Core (IoC/DI)', color: 'blue',
      details: [
        { name: 'Dependency Injection', explanation: 'Constructor, setter, and field injection patterns. @Autowired, @Inject annotations. Constructor injection recommended for immutability. Automatic dependency resolution by type. Qualifier annotations for disambiguation.' },
        { name: 'Bean Lifecycle', explanation: 'Container manages bean instantiation, initialization, and destruction. @PostConstruct and @PreDestroy lifecycle callbacks. InitializingBean and DisposableBean interfaces. Custom init-method and destroy-method. Full lifecycle control.' },
        { name: 'Component Scanning', explanation: '@Component, @Service, @Repository, @Controller stereotypes. Automatic bean discovery in specified packages. @ComponentScan configuration. Filtering and custom annotations. Reduces XML configuration to zero.' },
        { name: 'Bean Scopes', explanation: 'Singleton (default), Prototype, Request, Session, Application scopes. @Scope annotation for custom scopes. Singleton for stateless beans. Prototype for stateful or per-use beans. Web-aware scopes for MVC applications.' },
        { name: 'Profiles', explanation: '@Profile annotation for environment-specific beans. Activate profiles via properties or command line. Dev, test, prod configurations. Multiple active profiles simultaneously. Conditional bean registration based on environment.' },
        { name: 'SpEL (Expression Language)', explanation: 'Spring Expression Language for runtime bean wiring. #{...} syntax for expressions. Property resolution, method invocation, collection manipulation. Bean reference expressions. Dynamic configuration and conditional logic.' }
      ],
      description: 'Inversion of Control container providing dependency injection, bean lifecycle management, and component scanning.'
    },
    {
      id: 'spring-mvc', x: 580, y: 340, width: 350, height: 160,
      icon: 'üåê', title: 'Spring MVC / WebFlux', color: 'purple',
      details: [
        { name: 'MVC Controllers', explanation: '@RestController and @Controller for web endpoints. @RequestMapping, @GetMapping, @PostMapping annotations. Path variables and request parameters. Content negotiation and view resolution. RESTful API design with proper HTTP methods.' },
        { name: 'Request/Response Handling', explanation: '@RequestBody and @ResponseBody for JSON/XML. HttpEntity and ResponseEntity for full HTTP control. @PathVariable, @RequestParam, @RequestHeader annotations. Automatic type conversion and validation. Exception handling with @ExceptionHandler.' },
        { name: 'Validation', explanation: 'JSR-303/JSR-380 Bean Validation integration. @Valid and @Validated annotations. Custom validators and constraints. BindingResult for error handling. Field-level and class-level validation. Error message customization.' },
        { name: 'WebFlux Reactive', explanation: 'Non-blocking reactive web framework. Mono and Flux reactive types. Functional endpoint routing. Server-Sent Events and WebSocket support. Netty and Reactor integration. High-concurrency non-blocking I/O.' },
        { name: 'Interceptors', explanation: 'HandlerInterceptor for pre/post processing. WebMvcConfigurer for registration. Request logging, authentication, performance monitoring. Ordered execution chain. Access to ModelAndView for view manipulation.' },
        { name: 'Content Negotiation', explanation: 'Automatic content type handling based on Accept header. JSON, XML, HTML responses. @Produces and @Consumes annotations. Custom message converters. Multiple representation support for same endpoint.' }
      ],
      description: 'Web MVC framework for building RESTful APIs and web applications with reactive programming support via WebFlux.'
    },
    {
      id: 'spring-data', x: 80, y: 440, width: 350, height: 160,
      icon: 'üóÑÔ∏è', title: 'Spring Data', color: 'orange',
      details: [
        { name: 'JPA Repositories', explanation: 'JpaRepository interface with CRUD operations. No implementation code needed. Query derivation from method names: findByNameAndAge. @Query annotation for custom JPQL/SQL. Pagination and sorting built-in.' },
        { name: 'Query Methods', explanation: 'Derived query methods from method names. findBy, countBy, deleteBy conventions. Complex queries with And, Or, Between, LessThan, GreaterThan. Named parameters with @Param. Native queries for database-specific features.' },
        { name: 'Auditing', explanation: '@CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy annotations. Automatic timestamp and user tracking. AuditorAware for user resolution. Entity version tracking with @Version. Complete audit trail without code.' },
        { name: 'Specifications', explanation: 'JPA Criteria API abstraction for dynamic queries. Specification interface for reusable query fragments. Composable with and(), or(), not(). Type-safe query construction. Complex search functionality without string concatenation.' },
        { name: 'Projections', explanation: 'Interface-based and class-based projections. Select only needed fields for performance. DTO projections with constructor expressions. Dynamic projections with SpEL. Closed vs open projections for flexibility vs type safety.' },
        { name: 'Multi-Store Support', explanation: 'Unified API across JPA, MongoDB, Redis, Cassandra, Elasticsearch. Consistent repository pattern regardless of database. Mix different databases in single application. Cross-store support for polyglot persistence.' }
      ],
      description: 'Data access abstraction providing repository pattern, query derivation, and unified API across data stores.'
    },
    {
      id: 'spring-security', x: 580, y: 540, width: 350, height: 160,
      icon: 'üîí', title: 'Spring Security', color: 'red',
      details: [
        { name: 'Authentication', explanation: 'Username/password, OAuth2, JWT, LDAP, database authentication. AuthenticationManager and AuthenticationProvider. Multiple authentication mechanisms simultaneously. @PreAuthorize, @Secured annotations. Custom authentication logic integration.' },
        { name: 'Authorization', explanation: 'Role-based and permission-based access control. Method security with @Secured, @PreAuthorize, @PostAuthorize. URL pattern security configuration. Expression-based access control with SpEL. Hierarchical roles support.' },
        { name: 'OAuth2 & JWT', explanation: 'Resource server and authorization server support. JWT token validation and creation. OAuth2 client for social login. OIDC (OpenID Connect) integration. Spring Security OAuth2 Resource Server. Token introspection and validation.' },
        { name: 'CSRF Protection', explanation: 'Cross-Site Request Forgery protection enabled by default. Synchronizer token pattern. Cookie-based CSRF tokens. Configurable for REST APIs. Token repository customization.' },
        { name: 'Password Encoding', explanation: 'BCrypt, SCrypt, Pbkdf2, Argon2 password encoders. DelegatingPasswordEncoder for algorithm migration. Automatic salt generation. Strength configuration. Industry-standard password hashing.' },
        { name: 'Security Filters', explanation: 'Filter chain for request processing. Authentication, authorization, CSRF, CORS filters. Custom filter insertion. SecurityFilterChain configuration. OncePerRequestFilter for custom logic.' }
      ],
      description: 'Comprehensive security framework for authentication, authorization, OAuth2, JWT, and protection against common attacks.'
    },
    {
      id: 'spring-cloud', x: 1080, y: 240, width: 350, height: 160,
      icon: '‚òÅÔ∏è', title: 'Spring Cloud', color: 'teal',
      details: [
        { name: 'Service Discovery', explanation: 'Eureka, Consul, Zookeeper integration. @EnableEurekaClient and @EnableDiscoveryClient. Automatic service registration and discovery. Load balancing with Ribbon. Client-side service discovery pattern.' },
        { name: 'Config Server', explanation: 'Centralized external configuration. Git, SVN, file system backends. Environment-specific configurations. Automatic refresh without restart. Encryption and decryption support. @RefreshScope for dynamic updates.' },
        { name: 'API Gateway', explanation: 'Spring Cloud Gateway for routing and filtering. Rate limiting, circuit breakers, retry logic. Path rewriting and request/response modification. WebFlux-based for reactive non-blocking. LoadBalancerClient integration.' },
        { name: 'Circuit Breaker', explanation: 'Resilience4j integration (replaced Hystrix). @CircuitBreaker annotation. Fallback methods for failures. Bulkhead, RateLimiter, Retry, TimeLimiter patterns. Real-time metrics and health indicators.' },
        { name: 'Distributed Tracing', explanation: 'Spring Cloud Sleuth for trace IDs. Zipkin and Jaeger integration. Automatic propagation across services. Baggage for contextual information. Correlation IDs in logs. End-to-end request tracking.' },
        { name: 'Load Balancing', explanation: 'Client-side load balancing with LoadBalancer. Ribbon successor with reactive support. Round-robin, random, weighted strategies. Health-aware load balancing. Service instance selection customization.' }
      ],
      description: 'Microservices patterns including service discovery, config management, API gateway, and distributed tracing.'
    },
    {
      id: 'spring-aop', x: 1080, y: 440, width: 350, height: 160,
      icon: 'üéØ', title: 'Spring AOP', color: 'indigo',
      details: [
        { name: 'Aspect-Oriented Programming', explanation: 'Cross-cutting concerns separation. @Aspect annotation for aspect classes. Declarative approach to common concerns. Proxy-based AOP for Spring beans. AspectJ integration for compile-time weaving.' },
        { name: 'Advice Types', explanation: '@Before, @After, @AfterReturning, @AfterThrowing, @Around advices. Execution interception at various join points. Access to method arguments and return values. Exception handling in aspects. Around advice for complete control.' },
        { name: 'Pointcuts', explanation: 'Expression language for join point matching. Execution, within, target, args pointcut designators. Logical operators (&&, ||, !) for combination. Reusable @Pointcut declarations. Type-safe pointcut composition.' },
        { name: 'Common Use Cases', explanation: 'Logging, transaction management, security, caching, performance monitoring. Audit trails without business logic pollution. Consistent error handling. Metrics collection. Declarative retry logic.' },
        { name: 'Transaction Management', explanation: '@Transactional annotation for declarative transactions. Propagation and isolation levels. Rollback rules and read-only optimization. Multiple transaction managers. Programmatic transaction control with TransactionTemplate.' },
        { name: 'Caching', explanation: '@Cacheable, @CachePut, @CacheEvict annotations. Cache abstraction over EhCache, Caffeine, Redis. SpEL for dynamic cache keys. Conditional caching. Cache synchronization and TTL configuration.' }
      ],
      description: 'Aspect-Oriented Programming for cross-cutting concerns like logging, transactions, caching, and security.'
    },
    {
      id: 'spring-batch', x: 1080, y: 640, width: 350, height: 140,
      icon: '‚öôÔ∏è', title: 'Spring Batch & Integration', color: 'pink',
      details: [
        { name: 'Batch Processing', explanation: 'Job, Step, ItemReader, ItemProcessor, ItemWriter abstractions. Chunk-oriented and tasklet-based processing. Restart, skip, retry policies. Parallel and partitioned steps. Job parameters and scheduling. JobRepository for metadata.' },
        { name: 'Spring Integration', explanation: 'Enterprise Integration Patterns implementation. Message channels, endpoints, routers, transformers. File, HTTP, JMS, JDBC adapters. Asynchronous messaging. Polling and event-driven consumers. DSL for flow definition.' },
        { name: 'Scheduling', explanation: '@Scheduled annotation for periodic tasks. Cron, fixed-rate, fixed-delay expressions. @EnableScheduling configuration. TaskScheduler abstraction. Async task execution with @Async. Thread pool configuration.' },
        { name: 'Event Handling', explanation: '@EventListener for application events. Asynchronous event processing. Conditional event listening with SpEL. Custom event types. Order of event listeners. Transaction-bound events.' }
      ],
      description: 'Batch processing framework and enterprise integration patterns for large-scale data processing and system integration.'
    },
    {
      id: 'spring-data-jpa-advanced', x: 580, y: 760, width: 350, height: 160,
      icon: 'üíæ', title: 'Spring Data JPA Advanced', color: 'blue',
      details: [
        {
          name: 'Spring Data JPA Complete Guide',
          explanation: 'Comprehensive Spring Data JPA implementation covering repository patterns, query methods, specifications, pagination, projections, and entity relationships for enterprise applications.',
          codeExample: `// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 1. Entity Modeling with JPA Annotations
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Entity
@Table(name = "users", indexes = {
  @Index(name = "idx_email", columnList = "email"),
  @Index(name = "idx_username", columnList = "username")
})
@EntityListeners(AuditingEntityListener.class)
public class User {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false, unique = true, length = 100)
  private String username;

  @Column(nullable = false, unique = true)
  private String email;

  @Column(nullable = false)
  private String password;

  @Enumerated(EnumType.STRING)
  @Column(length = 20)
  private UserRole role;

  @CreatedDate
  @Column(nullable = false, updatable = false)
  private LocalDateTime createdAt;

  @LastModifiedDate
  private LocalDateTime updatedAt;

  @Version
  private Long version; // Optimistic locking

  @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<Order> orders = new ArrayList<>();

  @ManyToMany(fetch = FetchType.LAZY)
  @JoinTable(
    name = "user_roles",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @JoinColumn(name = "role_id")
  )
  private Set<Role> roles = new HashSet<>();

  // Getters, setters, equals, hashCode
}

@Entity
@Table(name = "orders")
public class Order {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false, unique = true)
  private String orderNumber;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id", nullable = false)
  private User user;

  @Enumerated(EnumType.STRING)
  private OrderStatus status;

  @Column(nullable = false, precision = 10, scale = 2)
  private BigDecimal totalAmount;

  @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<OrderItem> items = new ArrayList<>();

  private LocalDateTime orderDate;

  // Helper methods for bidirectional relationships
  public void addItem(OrderItem item) {
    items.add(item);
    item.setOrder(this);
  }

  public void removeItem(OrderItem item) {
    items.remove(item);
    item.setOrder(null);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 2. Repository Patterns and Query Methods
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

public interface UserRepository extends JpaRepository<User, Long>,
                                         JpaSpecificationExecutor<User> {

  // Derived query methods - Spring generates implementation automatically
  Optional<User> findByUsername(String username);

  Optional<User> findByEmail(String email);

  List<User> findByRoleAndCreatedAtAfter(UserRole role, LocalDateTime date);

  // Complex query with multiple conditions
  List<User> findByUsernameContainingAndEmailContainingIgnoreCase(
    String username, String email);

  // Count and exists methods
  long countByRole(UserRole role);

  boolean existsByUsername(String username);

  boolean existsByEmail(String email);

  // Delete methods
  void deleteByUsername(String username);

  // Top/First queries
  List<User> findTop10ByOrderByCreatedAtDesc();

  User findFirstByOrderByCreatedAtAsc();

  // Custom JPQL queries
  @Query("SELECT u FROM User u WHERE u.email LIKE %:domain")
  List<User> findByEmailDomain(@Param("domain") String domain);

  @Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
  Optional<User> findByIdWithOrders(@Param("id") Long id);

  @Query(value = "SELECT * FROM users WHERE created_at > :date",
         nativeQuery = true)
  List<User> findUsersCreatedAfter(@Param("date") LocalDateTime date);

  // Modifying queries
  @Modifying
  @Query("UPDATE User u SET u.email = :email WHERE u.username = :username")
  int updateEmailByUsername(@Param("username") String username,
                            @Param("email") String email);

  @Modifying
  @Query("DELETE FROM User u WHERE u.createdAt < :date")
  void deleteOldUsers(@Param("date") LocalDateTime date);

  // Projection queries
  @Query("SELECT u.username as username, u.email as email FROM User u")
  List<UserSummary> findAllUserSummaries();

  // Stream for large datasets
  @QueryHints(@QueryHint(name = "org.hibernate.fetchSize", value = "50"))
  Stream<User> streamAllByRole(UserRole role);
}

// Interface-based projection
public interface UserSummary {
  String getUsername();
  String getEmail();
  LocalDateTime getCreatedAt();
}

// Class-based projection (DTO)
public class UserDTO {
  private String username;
  private String email;

  public UserDTO(String username, String email) {
    this.username = username;
    this.email = email;
  }
  // Getters and setters
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 3. Specifications for Dynamic Queries
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

public class UserSpecifications {

  public static Specification<User> hasUsername(String username) {
    return (root, query, cb) ->
      username == null ? null : cb.equal(root.get("username"), username);
  }

  public static Specification<User> hasEmail(String email) {
    return (root, query, cb) ->
      email == null ? null : cb.equal(root.get("email"), email);
  }

  public static Specification<User> hasRole(UserRole role) {
    return (root, query, cb) ->
      role == null ? null : cb.equal(root.get("role"), role);
  }

  public static Specification<User> createdBetween(
      LocalDateTime start, LocalDateTime end) {
    return (root, query, cb) -> {
      if (start == null && end == null) return null;
      if (start == null) return cb.lessThanOrEqualTo(root.get("createdAt"), end);
      if (end == null) return cb.greaterThanOrEqualTo(root.get("createdAt"), start);
      return cb.between(root.get("createdAt"), start, end);
    };
  }

  public static Specification<User> emailContains(String emailPattern) {
    return (root, query, cb) ->
      emailPattern == null ? null :
      cb.like(cb.lower(root.get("email")),
              "%" + emailPattern.toLowerCase() + "%");
  }

  public static Specification<User> hasOrdersGreaterThan(int orderCount) {
    return (root, query, cb) -> {
      query.distinct(true);
      return cb.greaterThan(cb.size(root.get("orders")), orderCount);
    };
  }
}

@Service
public class UserSearchService {

  @Autowired
  private UserRepository userRepository;

  public List<User> searchUsers(UserSearchCriteria criteria) {
    // Build dynamic specification
    Specification<User> spec = Specification.where(null);

    if (criteria.getUsername() != null) {
      spec = spec.and(UserSpecifications.hasUsername(criteria.getUsername()));
    }

    if (criteria.getEmail() != null) {
      spec = spec.and(UserSpecifications.hasEmail(criteria.getEmail()));
    }

    if (criteria.getRole() != null) {
      spec = spec.and(UserSpecifications.hasRole(criteria.getRole()));
    }

    if (criteria.getStartDate() != null || criteria.getEndDate() != null) {
      spec = spec.and(UserSpecifications.createdBetween(
        criteria.getStartDate(), criteria.getEndDate()));
    }

    return userRepository.findAll(spec);
  }

  public Page<User> searchUsersWithPagination(
      UserSearchCriteria criteria, Pageable pageable) {
    Specification<User> spec = buildSpecification(criteria);
    return userRepository.findAll(spec, pageable);
  }

  private Specification<User> buildSpecification(UserSearchCriteria criteria) {
    return Specification.where(UserSpecifications.hasUsername(criteria.getUsername()))
      .and(UserSpecifications.hasEmail(criteria.getEmail()))
      .and(UserSpecifications.hasRole(criteria.getRole()))
      .and(UserSpecifications.createdBetween(
        criteria.getStartDate(), criteria.getEndDate()));
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 4. Pagination and Sorting
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@RestController
@RequestMapping("/api/users")
public class UserController {

  @Autowired
  private UserRepository userRepository;

  // Basic pagination
  @GetMapping
  public Page<User> getAllUsers(
      @RequestParam(defaultValue = "0") int page,
      @RequestParam(defaultValue = "10") int size) {

    Pageable pageable = PageRequest.of(page, size);
    return userRepository.findAll(pageable);
  }

  // Pagination with sorting
  @GetMapping("/sorted")
  public Page<User> getUsersSorted(
      @RequestParam(defaultValue = "0") int page,
      @RequestParam(defaultValue = "10") int size,
      @RequestParam(defaultValue = "id") String sortBy,
      @RequestParam(defaultValue = "ASC") String direction) {

    Sort.Direction sortDirection = Sort.Direction.fromString(direction);
    Pageable pageable = PageRequest.of(page, size,
                                       Sort.by(sortDirection, sortBy));
    return userRepository.findAll(pageable);
  }

  // Multiple sort fields
  @GetMapping("/multi-sort")
  public Page<User> getUsersMultiSort(
      @RequestParam(defaultValue = "0") int page,
      @RequestParam(defaultValue = "10") int size) {

    Sort sort = Sort.by(
      Sort.Order.desc("createdAt"),
      Sort.Order.asc("username")
    );
    Pageable pageable = PageRequest.of(page, size, sort);
    return userRepository.findAll(pageable);
  }

  // Custom pageable with search
  @GetMapping("/search")
  public Page<User> searchUsers(
      @RequestParam(required = false) String username,
      @RequestParam(required = false) String email,
      @RequestParam(required = false) UserRole role,
      Pageable pageable) {

    Specification<User> spec = Specification.where(null);

    if (username != null) {
      spec = spec.and(UserSpecifications.hasUsername(username));
    }
    if (email != null) {
      spec = spec.and(UserSpecifications.emailContains(email));
    }
    if (role != null) {
      spec = spec.and(UserSpecifications.hasRole(role));
    }

    return userRepository.findAll(spec, pageable);
  }
}

// Using in service layer
@Service
public class UserService {

  @Autowired
  private UserRepository userRepository;

  public PaginatedResponse<UserDTO> getAllUsersWithPagination(
      int page, int size, String sortBy) {

    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));
    Page<User> userPage = userRepository.findAll(pageable);

    List<UserDTO> userDTOs = userPage.getContent().stream()
      .map(this::convertToDTO)
      .collect(Collectors.toList());

    return new PaginatedResponse<>(
      userDTOs,
      userPage.getNumber(),
      userPage.getSize(),
      userPage.getTotalElements(),
      userPage.getTotalPages(),
      userPage.isFirst(),
      userPage.isLast()
    );
  }

  private UserDTO convertToDTO(User user) {
    return new UserDTO(user.getUsername(), user.getEmail());
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 5. Custom Repository Implementation
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Custom repository interface
public interface UserRepositoryCustom {
  List<User> findUsersWithCustomLogic(String criteria);
  void bulkUpdateUsers(List<Long> userIds, UserRole newRole);
}

// Implementation (must be named <InterfaceName>Impl)
@Repository
public class UserRepositoryImpl implements UserRepositoryCustom {

  @PersistenceContext
  private EntityManager entityManager;

  @Override
  public List<User> findUsersWithCustomLogic(String criteria) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> query = cb.createQuery(User.class);
    Root<User> root = query.from(User.class);

    // Complex criteria logic
    Predicate predicate = cb.or(
      cb.like(root.get("username"), "%" + criteria + "%"),
      cb.like(root.get("email"), "%" + criteria + "%")
    );

    query.where(predicate);
    query.orderBy(cb.desc(root.get("createdAt")));

    return entityManager.createQuery(query)
      .setMaxResults(100)
      .getResultList();
  }

  @Override
  @Transactional
  public void bulkUpdateUsers(List<Long> userIds, UserRole newRole) {
    String jpql = "UPDATE User u SET u.role = :role WHERE u.id IN :ids";
    entityManager.createQuery(jpql)
      .setParameter("role", newRole)
      .setParameter("ids", userIds)
      .executeUpdate();
  }
}

// Extended repository interface
public interface UserRepository extends JpaRepository<User, Long>,
                                         JpaSpecificationExecutor<User>,
                                         UserRepositoryCustom {
  // Standard repository methods + custom methods
}`
        }
      ],
      description: 'Advanced Spring Data JPA patterns including repositories, specifications, pagination, and custom implementations.'
    },
    {
      id: 'spring-mvc-advanced', x: 1080, y: 80, width: 350, height: 160,
      icon: 'üé®', title: 'Spring MVC Advanced', color: 'green',
      details: [
        {
          name: 'Spring MVC Complete Guide',
          explanation: 'Comprehensive Spring MVC implementation covering controllers, request mapping, validation, exception handling, interceptors, and RESTful API design patterns.',
          codeExample: `// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 1. Advanced Controller Patterns with Request Mapping
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@RestController
@RequestMapping("/api/v1/products")
@CrossOrigin(origins = "http://localhost:3000")
@Validated
public class ProductController {

  @Autowired
  private ProductService productService;

  // Basic GET with path variable
  @GetMapping("/{id}")
  public ResponseEntity<ProductDTO> getProduct(@PathVariable Long id) {
    ProductDTO product = productService.findById(id);
    return ResponseEntity.ok(product);
  }

  // GET with multiple request parameters
  @GetMapping
  public ResponseEntity<Page<ProductDTO>> getAllProducts(
      @RequestParam(required = false) String category,
      @RequestParam(required = false) String search,
      @RequestParam(defaultValue = "0") int page,
      @RequestParam(defaultValue = "20") int size,
      @RequestParam(defaultValue = "id,asc") String[] sort) {

    Pageable pageable = PageRequest.of(page, size,
                                       Sort.by(parseSortParams(sort)));
    Page<ProductDTO> products = productService.findAll(
      category, search, pageable);
    return ResponseEntity.ok(products);
  }

  // POST with request body validation
  @PostMapping
  @ResponseStatus(HttpStatus.CREATED)
  public ResponseEntity<ProductDTO> createProduct(
      @Valid @RequestBody CreateProductRequest request,
      BindingResult bindingResult) {

    if (bindingResult.hasErrors()) {
      throw new ValidationException(bindingResult);
    }

    ProductDTO created = productService.create(request);
    URI location = ServletUriComponentsBuilder
      .fromCurrentRequest()
      .path("/{id}")
      .buildAndExpand(created.getId())
      .toUri();

    return ResponseEntity.created(location).body(created);
  }

  // PUT for full update
  @PutMapping("/{id}")
  public ResponseEntity<ProductDTO> updateProduct(
      @PathVariable Long id,
      @Valid @RequestBody UpdateProductRequest request) {

    ProductDTO updated = productService.update(id, request);
    return ResponseEntity.ok(updated);
  }

  // PATCH for partial update
  @PatchMapping("/{id}")
  public ResponseEntity<ProductDTO> partialUpdateProduct(
      @PathVariable Long id,
      @RequestBody Map<String, Object> updates) {

    ProductDTO updated = productService.partialUpdate(id, updates);
    return ResponseEntity.ok(updated);
  }

  // DELETE
  @DeleteMapping("/{id}")
  @ResponseStatus(HttpStatus.NO_CONTENT)
  public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
    productService.delete(id);
    return ResponseEntity.noContent().build();
  }

  // Custom action endpoint
  @PostMapping("/{id}/publish")
  public ResponseEntity<ProductDTO> publishProduct(
      @PathVariable Long id,
      @RequestHeader("X-User-Id") Long userId) {

    ProductDTO published = productService.publish(id, userId);
    return ResponseEntity.ok(published);
  }

  // File upload
  @PostMapping("/{id}/image")
  public ResponseEntity<String> uploadProductImage(
      @PathVariable Long id,
      @RequestParam("file") MultipartFile file) {

    if (file.isEmpty()) {
      return ResponseEntity.badRequest()
        .body("Please select a file to upload");
    }

    String imageUrl = productService.uploadImage(id, file);
    return ResponseEntity.ok(imageUrl);
  }

  // Content negotiation - XML and JSON
  @GetMapping(value = "/{id}", produces = {
    MediaType.APPLICATION_JSON_VALUE,
    MediaType.APPLICATION_XML_VALUE
  })
  public ResponseEntity<ProductDTO> getProductWithContentNegotiation(
      @PathVariable Long id) {
    return ResponseEntity.ok(productService.findById(id));
  }

  private Sort.Order[] parseSortParams(String[] sort) {
    return Arrays.stream(sort)
      .map(s -> {
        String[] parts = s.split(",");
        return Sort.Order.by(parts[0])
          .with(Sort.Direction.fromString(parts.length > 1 ? parts[1] : "asc"));
      })
      .toArray(Sort.Order[]::new);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 2. Request/Response DTOs with Validation
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateProductRequest {

  @NotBlank(message = "Product name is required")
  @Size(min = 3, max = 100, message = "Name must be between 3 and 100 characters")
  private String name;

  @NotBlank(message = "Description is required")
  @Size(max = 500)
  private String description;

  @NotNull(message = "Price is required")
  @DecimalMin(value = "0.01", message = "Price must be greater than 0")
  @Digits(integer = 10, fraction = 2)
  private BigDecimal price;

  @NotNull
  @Min(0)
  private Integer stockQuantity;

  @NotBlank
  @Pattern(regexp = "^[A-Z]{3,10}$", message = "Invalid category code")
  private String categoryCode;

  @Email(message = "Invalid email format")
  private String contactEmail;

  @Valid
  @NotEmpty(message = "At least one specification is required")
  private List<ProductSpecification> specifications;
}

@Data
public class ProductSpecification {

  @NotBlank
  private String key;

  @NotBlank
  private String value;
}

// Custom validator annotation
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PriceRangeValidator.class)
public @interface ValidPriceRange {
  String message() default "Price is out of valid range";
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
  double min() default 0.0;
  double max() default Double.MAX_VALUE;
}

public class PriceRangeValidator
    implements ConstraintValidator<ValidPriceRange, BigDecimal> {

  private double min;
  private double max;

  @Override
  public void initialize(ValidPriceRange constraint) {
    this.min = constraint.min();
    this.max = constraint.max();
  }

  @Override
  public boolean isValid(BigDecimal value,
                         ConstraintValidatorContext context) {
    if (value == null) return true;
    double doubleValue = value.doubleValue();
    return doubleValue >= min && doubleValue <= max;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 3. Global Exception Handling
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@RestControllerAdvice
@Order(Ordered.HIGHEST_PRECEDENCE)
public class GlobalExceptionHandler {

  @ExceptionHandler(ResourceNotFoundException.class)
  @ResponseStatus(HttpStatus.NOT_FOUND)
  public ErrorResponse handleResourceNotFound(
      ResourceNotFoundException ex, WebRequest request) {

    return ErrorResponse.builder()
      .timestamp(LocalDateTime.now())
      .status(HttpStatus.NOT_FOUND.value())
      .error("Not Found")
      .message(ex.getMessage())
      .path(request.getDescription(false).replace("uri=", ""))
      .build();
  }

  @ExceptionHandler(MethodArgumentNotValidException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ValidationErrorResponse handleValidationExceptions(
      MethodArgumentNotValidException ex) {

    Map<String, String> errors = new HashMap<>();
    ex.getBindingResult().getAllErrors().forEach(error -> {
      String fieldName = ((FieldError) error).getField();
      String errorMessage = error.getDefaultMessage();
      errors.put(fieldName, errorMessage);
    });

    return ValidationErrorResponse.builder()
      .timestamp(LocalDateTime.now())
      .status(HttpStatus.BAD_REQUEST.value())
      .error("Validation Failed")
      .validationErrors(errors)
      .build();
  }

  @ExceptionHandler(ConstraintViolationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ValidationErrorResponse handleConstraintViolation(
      ConstraintViolationException ex) {

    Map<String, String> errors = new HashMap<>();
    ex.getConstraintViolations().forEach(violation -> {
      String propertyPath = violation.getPropertyPath().toString();
      String message = violation.getMessage();
      errors.put(propertyPath, message);
    });

    return ValidationErrorResponse.builder()
      .timestamp(LocalDateTime.now())
      .status(HttpStatus.BAD_REQUEST.value())
      .error("Constraint Violation")
      .validationErrors(errors)
      .build();
  }

  @ExceptionHandler(DataIntegrityViolationException.class)
  @ResponseStatus(HttpStatus.CONFLICT)
  public ErrorResponse handleDataIntegrityViolation(
      DataIntegrityViolationException ex) {

    return ErrorResponse.builder()
      .timestamp(LocalDateTime.now())
      .status(HttpStatus.CONFLICT.value())
      .error("Data Integrity Violation")
      .message("Database constraint violation occurred")
      .build();
  }

  @ExceptionHandler(AccessDeniedException.class)
  @ResponseStatus(HttpStatus.FORBIDDEN)
  public ErrorResponse handleAccessDenied(AccessDeniedException ex) {
    return ErrorResponse.builder()
      .timestamp(LocalDateTime.now())
      .status(HttpStatus.FORBIDDEN.value())
      .error("Access Denied")
      .message("You don't have permission to access this resource")
      .build();
  }

  @ExceptionHandler(Exception.class)
  @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
  public ErrorResponse handleGlobalException(
      Exception ex, WebRequest request) {

    log.error("Unexpected error occurred", ex);

    return ErrorResponse.builder()
      .timestamp(LocalDateTime.now())
      .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
      .error("Internal Server Error")
      .message("An unexpected error occurred")
      .path(request.getDescription(false).replace("uri=", ""))
      .build();
  }
}

@Data
@Builder
public class ErrorResponse {
  private LocalDateTime timestamp;
  private int status;
  private String error;
  private String message;
  private String path;
}

@Data
@Builder
public class ValidationErrorResponse {
  private LocalDateTime timestamp;
  private int status;
  private String error;
  private Map<String, String> validationErrors;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 4. Interceptors and Filters
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Component
public class RequestLoggingInterceptor implements HandlerInterceptor {

  private static final Logger log =
    LoggerFactory.getLogger(RequestLoggingInterceptor.class);

  @Override
  public boolean preHandle(HttpServletRequest request,
                          HttpServletResponse response,
                          Object handler) throws Exception {

    long startTime = System.currentTimeMillis();
    request.setAttribute("startTime", startTime);

    log.info("Request URL: {} {}", request.getMethod(), request.getRequestURI());
    log.info("Client IP: {}", request.getRemoteAddr());

    return true;
  }

  @Override
  public void postHandle(HttpServletRequest request,
                        HttpServletResponse response,
                        Object handler,
                        ModelAndView modelAndView) throws Exception {

    long startTime = (Long) request.getAttribute("startTime");
    long endTime = System.currentTimeMillis();
    long executeTime = endTime - startTime;

    log.info("Request completed in {}ms", executeTime);
  }

  @Override
  public void afterCompletion(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler,
                             Exception ex) throws Exception {

    if (ex != null) {
      log.error("Request failed with exception", ex);
    }
  }
}

@Component
@Order(1)
public class AuthenticationFilter extends OncePerRequestFilter {

  @Autowired
  private JwtTokenProvider tokenProvider;

  @Override
  protected void doFilterInternal(HttpServletRequest request,
                                 HttpServletResponse response,
                                 FilterChain filterChain)
      throws ServletException, IOException {

    String jwt = extractJwtFromRequest(request);

    if (jwt != null && tokenProvider.validateToken(jwt)) {
      String userId = tokenProvider.getUserIdFromToken(jwt);

      UsernamePasswordAuthenticationToken authentication =
        new UsernamePasswordAuthenticationToken(userId, null, null);

      SecurityContextHolder.getContext()
        .setAuthentication(authentication);
    }

    filterChain.doFilter(request, response);
  }

  private String extractJwtFromRequest(HttpServletRequest request) {
    String bearerToken = request.getHeader("Authorization");
    if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
      return bearerToken.substring(7);
    }
    return null;
  }
}

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

  @Autowired
  private RequestLoggingInterceptor loggingInterceptor;

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(loggingInterceptor)
      .addPathPatterns("/api/**")
      .excludePathPatterns("/api/auth/**", "/api/public/**");
  }

  @Override
  public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/api/**")
      .allowedOrigins("http://localhost:3000", "https://example.com")
      .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
      .allowedHeaders("*")
      .allowCredentials(true)
      .maxAge(3600);
  }

  @Override
  public void configureMessageConverters(
      List<HttpMessageConverter<?>> converters) {
    // Custom JSON converter with Jackson
    MappingJackson2HttpMessageConverter jsonConverter =
      new MappingJackson2HttpMessageConverter();
    jsonConverter.setObjectMapper(objectMapper());
    converters.add(jsonConverter);
  }

  @Bean
  public ObjectMapper objectMapper() {
    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
    return mapper;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 5. Async Request Processing and SSE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@RestController
@RequestMapping("/api/async")
public class AsyncController {

  @Autowired
  private AsyncService asyncService;

  // Async request processing with CompletableFuture
  @GetMapping("/process/{id}")
  public CompletableFuture<ResponseEntity<ProcessResult>> processAsync(
      @PathVariable Long id) {

    return asyncService.processData(id)
      .thenApply(result -> ResponseEntity.ok(result))
      .exceptionally(ex -> {
        log.error("Async processing failed", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
          .build();
      });
  }

  // Server-Sent Events (SSE)
  @GetMapping(value = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
  public SseEmitter streamEvents() {
    SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);

    CompletableFuture.runAsync(() -> {
      try {
        for (int i = 0; i < 10; i++) {
          SseEmitter.SseEventBuilder event = SseEmitter.event()
            .data("Event " + i)
            .id(String.valueOf(i))
            .name("message");

          emitter.send(event);
          Thread.sleep(1000);
        }
        emitter.complete();
      } catch (Exception e) {
        emitter.completeWithError(e);
      }
    });

    return emitter;
  }

  // DeferredResult for long polling
  @GetMapping("/long-poll/{id}")
  public DeferredResult<ResponseEntity<String>> longPoll(
      @PathVariable String id) {

    DeferredResult<ResponseEntity<String>> deferredResult =
      new DeferredResult<>(30000L);

    deferredResult.onTimeout(() ->
      deferredResult.setResult(
        ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
          .body("Request timeout")));

    asyncService.processlongPollingRequest(id, deferredResult);

    return deferredResult;
  }
}

@Service
public class AsyncService {

  @Async("taskExecutor")
  public CompletableFuture<ProcessResult> processData(Long id) {
    // Simulate long-running task
    try {
      Thread.sleep(5000);
      ProcessResult result = new ProcessResult(id, "Completed");
      return CompletableFuture.completedFuture(result);
    } catch (InterruptedException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  public void processlongPollingRequest(
      String id, DeferredResult<ResponseEntity<String>> deferredResult) {

    CompletableFuture.runAsync(() -> {
      try {
        Thread.sleep(2000);
        deferredResult.setResult(
          ResponseEntity.ok("Data for " + id));
      } catch (InterruptedException e) {
        deferredResult.setErrorResult(e);
      }
    });
  }
}

@Configuration
@EnableAsync
public class AsyncConfig {

  @Bean(name = "taskExecutor")
  public Executor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(5);
    executor.setMaxPoolSize(10);
    executor.setQueueCapacity(100);
    executor.setThreadNamePrefix("async-");
    executor.initialize();
    return executor;
  }
}`
        }
      ],
      description: 'Advanced Spring MVC patterns including controllers, validation, exception handling, interceptors, and async processing.'
    },
    {
      id: 'spring-security-advanced', x: 80, y: 440, width: 350, height: 160,
      icon: 'üîí', title: 'Spring Security Advanced', color: '#ef4444',
      details: [
        {
          name: 'Spring Security Complete Guide',
          explanation: 'Comprehensive Spring Security implementation covering authentication, authorization, JWT tokens, OAuth2, password encoding, and method-level security for enterprise applications.',
          codeExample: `// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 1. Basic Authentication & Authorization Configuration
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

  @Autowired
  private UserDetailsService userDetailsService;

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
      .csrf(csrf -> csrf.disable()) // Disable for REST APIs
      .authorizeHttpRequests(auth -> auth
        .requestMatchers("/api/public/**").permitAll()
        .requestMatchers("/api/admin/**").hasRole("ADMIN")
        .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
        .anyRequest().authenticated()
      )
      .httpBasic(Customizer.withDefaults())
      .sessionManagement(session -> session
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      );

    return http.build();
  }

  @Bean
  public AuthenticationManager authenticationManager(
      AuthenticationConfiguration authConfig) throws Exception {
    return authConfig.getAuthenticationManager();
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12); // Strength 12
  }
}

// Custom UserDetailsService implementation
@Service
public class CustomUserDetailsService implements UserDetailsService {

  @Autowired
  private UserRepository userRepository;

  @Override
  public UserDetails loadUserByUsername(String username)
      throws UsernameNotFoundException {
    User user = userRepository.findByUsername(username)
      .orElseThrow(() -> new UsernameNotFoundException(
        "User not found: " + username));

    return org.springframework.security.core.userdetails.User
      .withUsername(user.getUsername())
      .password(user.getPassword())
      .roles(user.getRole().name())
      .accountExpired(false)
      .accountLocked(false)
      .credentialsExpired(false)
      .disabled(false)
      .build();
  }
}
// Output: Basic auth with username/password, role-based access control

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 2. JWT Token Generation & Validation
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Service
public class JwtService {

  @Value("\${jwt.secret}")
  private String secret;

  @Value("\${jwt.expiration}")
  private Long expiration; // milliseconds

  public String generateToken(UserDetails userDetails) {
    Map<String, Object> claims = new HashMap<>();
    claims.put("roles", userDetails.getAuthorities().stream()
      .map(GrantedAuthority::getAuthority)
      .collect(Collectors.toList()));

    return Jwts.builder()
      .setClaims(claims)
      .setSubject(userDetails.getUsername())
      .setIssuedAt(new Date())
      .setExpiration(new Date(System.currentTimeMillis() + expiration))
      .signWith(getSigningKey(), SignatureAlgorithm.HS256)
      .compact();
  }

  public String extractUsername(String token) {
    return extractClaim(token, Claims::getSubject);
  }

  public Date extractExpiration(String token) {
    return extractClaim(token, Claims::getExpiration);
  }

  public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
    final Claims claims = extractAllClaims(token);
    return claimsResolver.apply(claims);
  }

  private Claims extractAllClaims(String token) {
    return Jwts.parserBuilder()
      .setSigningKey(getSigningKey())
      .build()
      .parseClaimsJws(token)
      .getBody();
  }

  private Key getSigningKey() {
    byte[] keyBytes = Decoders.BASE64.decode(secret);
    return Keys.hmacShaKeyFor(keyBytes);
  }

  public Boolean isTokenValid(String token, UserDetails userDetails) {
    final String username = extractUsername(token);
    return (username.equals(userDetails.getUsername())
        && !isTokenExpired(token));
  }

  private Boolean isTokenExpired(String token) {
    return extractExpiration(token).before(new Date());
  }
}

// JWT Authentication Filter
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

  @Autowired
  private JwtService jwtService;

  @Autowired
  private UserDetailsService userDetailsService;

  @Override
  protected void doFilterInternal(
      HttpServletRequest request,
      HttpServletResponse response,
      FilterChain filterChain) throws ServletException, IOException {

    final String authHeader = request.getHeader("Authorization");

    if (authHeader == null || !authHeader.startsWith("Bearer ")) {
      filterChain.doFilter(request, response);
      return;
    }

    final String jwt = authHeader.substring(7);
    final String username = jwtService.extractUsername(jwt);

    if (username != null && SecurityContextHolder.getContext()
        .getAuthentication() == null) {
      UserDetails userDetails = userDetailsService.loadUserByUsername(username);

      if (jwtService.isTokenValid(jwt, userDetails)) {
        UsernamePasswordAuthenticationToken authToken =
          new UsernamePasswordAuthenticationToken(
            userDetails, null, userDetails.getAuthorities());
        authToken.setDetails(new WebAuthenticationDetailsSource()
          .buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authToken);
      }
    }

    filterChain.doFilter(request, response);
  }
}
// Output: JWT-based stateless authentication with token validation

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 3. Method-Level Security with @PreAuthorize
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@RestController
@RequestMapping("/api/products")
public class ProductController {

  @Autowired
  private ProductService productService;

  // Role-based authorization
  @GetMapping
  @PreAuthorize("hasRole('USER')")
  public List<Product> getAllProducts() {
    return productService.findAll();
  }

  // Multiple roles
  @PostMapping
  @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
  public Product createProduct(@RequestBody Product product) {
    return productService.save(product);
  }

  // Custom SpEL expression
  @PutMapping("/{id}")
  @PreAuthorize("hasRole('ADMIN') or @productSecurity.isOwner(#id)")
  public Product updateProduct(@PathVariable Long id,
                                @RequestBody Product product) {
    return productService.update(id, product);
  }

  // Method parameter security
  @DeleteMapping("/{id}")
  @PreAuthorize("hasRole('ADMIN')")
  public void deleteProduct(@PathVariable Long id) {
    productService.delete(id);
  }

  // Post-authorization check
  @GetMapping("/{id}")
  @PostAuthorize("returnObject.ownerId == authentication.principal.id or hasRole('ADMIN')")
  public Product getProduct(@PathVariable Long id) {
    return productService.findById(id);
  }

  // Method-level filtering
  @GetMapping("/my-products")
  @PostFilter("filterObject.ownerId == authentication.principal.id")
  public List<Product> getMyProducts() {
    return productService.findAll();
  }
}

// Custom security service
@Service
public class ProductSecurity {

  @Autowired
  private ProductRepository productRepository;

  public boolean isOwner(Long productId) {
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    String username = auth.getName();

    return productRepository.findById(productId)
      .map(product -> product.getOwner().getUsername().equals(username))
      .orElse(false);
  }
}
// Output: Fine-grained method-level authorization with SpEL expressions

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 4. OAuth2 Resource Server Configuration
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// application.yml
/*
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://auth.example.com/realms/myapp
          jwk-set-uri: https://auth.example.com/realms/myapp/protocol/openid-connect/certs
*/

@Configuration
@EnableWebSecurity
public class OAuth2ResourceServerConfig {

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
      .authorizeHttpRequests(auth -> auth
        .requestMatchers("/api/public/**").permitAll()
        .anyRequest().authenticated()
      )
      .oauth2ResourceServer(oauth2 -> oauth2
        .jwt(jwt -> jwt
          .jwtAuthenticationConverter(jwtAuthenticationConverter())
        )
      );

    return http.build();
  }

  @Bean
  public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter =
      new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthoritiesClaimName("roles");
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");

    JwtAuthenticationConverter jwtAuthenticationConverter =
      new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(
      grantedAuthoritiesConverter);

    return jwtAuthenticationConverter;
  }
}

// OAuth2 Client Configuration
@Configuration
@EnableWebSecurity
public class OAuth2ClientConfig {

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
      .authorizeHttpRequests(auth -> auth
        .anyRequest().authenticated()
      )
      .oauth2Login(oauth2 -> oauth2
        .loginPage("/login")
        .defaultSuccessUrl("/dashboard")
        .failureUrl("/login?error")
        .userInfoEndpoint(userInfo -> userInfo
          .userService(oauth2UserService())
        )
      );

    return http.build();
  }

  @Bean
  public OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() {
    DefaultOAuth2UserService delegate = new DefaultOAuth2UserService();

    return userRequest -> {
      OAuth2User oauth2User = delegate.loadUser(userRequest);

      // Custom user processing
      String email = oauth2User.getAttribute("email");
      String name = oauth2User.getAttribute("name");

      // Save or update user in database
      // Return custom OAuth2User implementation

      return oauth2User;
    };
  }
}
// Output: OAuth2 resource server with JWT validation and client support

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 5. Password Encoding & User Details Service
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Service
public class UserService {

  @Autowired
  private UserRepository userRepository;

  @Autowired
  private PasswordEncoder passwordEncoder;

  // User registration with password encoding
  public User registerUser(UserRegistrationDto dto) {
    if (userRepository.existsByUsername(dto.getUsername())) {
      throw new DuplicateUserException("Username already exists");
    }

    User user = new User();
    user.setUsername(dto.getUsername());
    user.setEmail(dto.getEmail());
    user.setPassword(passwordEncoder.encode(dto.getPassword()));
    user.setRole(UserRole.USER);
    user.setEnabled(true);

    return userRepository.save(user);
  }

  // Password change with validation
  public void changePassword(String username, String oldPassword,
                             String newPassword) {
    User user = userRepository.findByUsername(username)
      .orElseThrow(() -> new UsernameNotFoundException("User not found"));

    if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
      throw new BadCredentialsException("Invalid old password");
    }

    user.setPassword(passwordEncoder.encode(newPassword));
    userRepository.save(user);
  }

  // Password reset with token
  public void resetPassword(String token, String newPassword) {
    PasswordResetToken resetToken = tokenRepository.findByToken(token)
      .orElseThrow(() -> new InvalidTokenException("Invalid reset token"));

    if (resetToken.isExpired()) {
      throw new InvalidTokenException("Token expired");
    }

    User user = resetToken.getUser();
    user.setPassword(passwordEncoder.encode(newPassword));
    userRepository.save(user);

    tokenRepository.delete(resetToken);
  }
}

// Advanced password encoder configuration
@Configuration
public class PasswordEncoderConfig {

  @Bean
  public PasswordEncoder passwordEncoder() {
    // Delegating encoder for algorithm migration
    String idForEncode = "bcrypt";
    Map<String, PasswordEncoder> encoders = new HashMap<>();

    encoders.put("bcrypt", new BCryptPasswordEncoder(12));
    encoders.put("scrypt", SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8());
    encoders.put("argon2", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8());
    encoders.put("pbkdf2", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8());

    return new DelegatingPasswordEncoder(idForEncode, encoders);
  }
}

// Custom authentication provider
@Component
public class CustomAuthenticationProvider implements AuthenticationProvider {

  @Autowired
  private UserDetailsService userDetailsService;

  @Autowired
  private PasswordEncoder passwordEncoder;

  @Override
  public Authentication authenticate(Authentication authentication)
      throws AuthenticationException {
    String username = authentication.getName();
    String password = authentication.getCredentials().toString();

    UserDetails userDetails = userDetailsService.loadUserByUsername(username);

    if (!passwordEncoder.matches(password, userDetails.getPassword())) {
      throw new BadCredentialsException("Invalid credentials");
    }

    // Additional checks (account locked, expired, etc.)
    if (!userDetails.isAccountNonLocked()) {
      throw new LockedException("Account is locked");
    }

    return new UsernamePasswordAuthenticationToken(
      userDetails, password, userDetails.getAuthorities());
  }

  @Override
  public boolean supports(Class<?> authentication) {
    return UsernamePasswordAuthenticationToken.class
      .isAssignableFrom(authentication);
  }
}

// User entity with security fields
@Entity
@Table(name = "users")
public class User implements UserDetails {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(unique = true, nullable = false)
  private String username;

  @Column(nullable = false)
  private String password;

  @Column(unique = true, nullable = false)
  private String email;

  @Enumerated(EnumType.STRING)
  private UserRole role;

  private boolean enabled = true;
  private boolean accountNonExpired = true;
  private boolean accountNonLocked = true;
  private boolean credentialsNonExpired = true;

  @Column(name = "failed_login_attempts")
  private int failedLoginAttempts = 0;

  @Column(name = "locked_until")
  private LocalDateTime lockedUntil;

  @Override
  public Collection<? extends GrantedAuthority> getAuthorities() {
    return Collections.singletonList(
      new SimpleGrantedAuthority("ROLE_" + role.name()));
  }

  // Getters and setters
}
// Output: Secure password encoding with multiple algorithms and account management`
        }
      ],
      description: 'Comprehensive Spring Security implementation with authentication, JWT, OAuth2, and method-level security.'
    },
    {
      id: 'spring-cloud-advanced', x: 530, y: 440, width: 350, height: 160,
      icon: '‚òÅÔ∏è', title: 'Spring Cloud Advanced', color: '#06b6d4',
      details: [
        {
          name: 'Spring Cloud Complete Guide',
          explanation: 'Comprehensive Spring Cloud implementation covering service discovery with Eureka, centralized configuration, API gateway routing, circuit breakers, and load balancing for microservices.',
          codeExample: `// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 1. Eureka Service Discovery (Client & Server)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Eureka Server Configuration
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(EurekaServerApplication.class, args);
  }
}

// application.yml for Eureka Server
/*
server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://\${eureka.instance.hostname}:\${server.port}/eureka/
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 4000
*/

// pom.xml dependency
/*
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
*/

// Eureka Client Configuration
@SpringBootApplication
@EnableDiscoveryClient
public class ProductServiceApplication {
  public static void main(String[] args) {
    SpringApplication.run(ProductServiceApplication.class, args);
  }
}

// application.yml for Eureka Client
/*
server:
  port: 8081

spring:
  application:
    name: product-service

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
    register-with-eureka: true
    fetch-registry: true
  instance:
    instance-id: \${spring.application.name}:\${spring.application.instance_id:\${random.value}}
    prefer-ip-address: true
    lease-renewal-interval-in-seconds: 30
    lease-expiration-duration-in-seconds: 90
*/

// Service communication using service name
@RestController
@RequestMapping("/api/products")
public class ProductController {

  @Autowired
  private RestTemplate restTemplate;

  @Autowired
  private DiscoveryClient discoveryClient;

  @GetMapping("/{id}/orders")
  public List<Order> getProductOrders(@PathVariable Long id) {
    // Using service name instead of hardcoded URL
    String url = "http://order-service/api/orders/product/" + id;
    return restTemplate.exchange(
      url,
      HttpMethod.GET,
      null,
      new ParameterizedTypeReference<List<Order>>() {}
    ).getBody();
  }

  @GetMapping("/services")
  public List<String> getRegisteredServices() {
    return discoveryClient.getServices();
  }

  @GetMapping("/instances/{serviceName}")
  public List<ServiceInstance> getServiceInstances(
      @PathVariable String serviceName) {
    return discoveryClient.getInstances(serviceName);
  }
}

// RestTemplate with Load Balancing
@Configuration
public class RestTemplateConfig {

  @Bean
  @LoadBalanced
  public RestTemplate restTemplate() {
    return new RestTemplate();
  }
}
// Output: Service discovery with automatic registration and health monitoring

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 2. Config Server & Client Configuration
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Config Server Setup
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServerApplication.class, args);
  }
}

// application.yml for Config Server
/*
server:
  port: 8888

spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/config-repo
          clone-on-start: true
          default-label: main
          search-paths: '{application}'
        # Or use native file system
        native:
          search-locations: classpath:/config,file:///\${user.home}/config-repo
  profiles:
    active: native # or 'git'

encrypt:
  key: mySecretEncryptionKey123
*/

// Config Client Setup
@SpringBootApplication
@RefreshScope
public class UserServiceApplication {
  public static void main(String[] args) {
    SpringApplication.run(UserServiceApplication.class, args);
  }
}

// bootstrap.yml (loads before application.yml)
/*
spring:
  application:
    name: user-service
  cloud:
    config:
      uri: http://localhost:8888
      fail-fast: true
      retry:
        initial-interval: 1000
        max-attempts: 6
        max-interval: 2000
        multiplier: 1.1
  profiles:
    active: dev
*/

// Using configuration properties
@RestController
@RefreshScope
public class ConfigController {

  @Value("\${app.message:Default Message}")
  private String message;

  @Value("\${app.feature.enabled:false}")
  private boolean featureEnabled;

  @Autowired
  private Environment env;

  @GetMapping("/config")
  public Map<String, Object> getConfig() {
    Map<String, Object> config = new HashMap<>();
    config.put("message", message);
    config.put("featureEnabled", featureEnabled);
    config.put("profile", env.getActiveProfiles());
    return config;
  }
}

// Encrypted properties in config repo
/*
# application-prod.yml in Git repo
spring:
  datasource:
    url: jdbc:postgresql://prod-db:5432/myapp
    username: admin
    password: '{cipher}AQBxxx...' # Encrypted value

app:
  api:
    key: '{cipher}AQCyyy...' # Encrypted API key
*/

// Refresh configuration without restart
@RestController
public class RefreshController {

  @Autowired
  private ApplicationContext context;

  @PostMapping("/actuator/refresh")
  public Set<String> refresh() {
    RefreshScope refreshScope = context.getBean(RefreshScope.class);
    refreshScope.refreshAll();
    return Set.of("Configuration refreshed");
  }
}

// Enable actuator for refresh endpoint
/*
management:
  endpoints:
    web:
      exposure:
        include: refresh,health,info
*/
// Output: Centralized configuration with Git backend and automatic refresh

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 3. Resilience4j Circuit Breaker
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// pom.xml dependencies
/*
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
*/

// application.yml configuration
/*
resilience4j:
  circuitbreaker:
    instances:
      orderService:
        register-health-indicator: true
        sliding-window-size: 10
        minimum-number-of-calls: 5
        permitted-number-of-calls-in-half-open-state: 3
        wait-duration-in-open-state: 10s
        failure-rate-threshold: 50
        slow-call-rate-threshold: 100
        slow-call-duration-threshold: 2s
        automatic-transition-from-open-to-half-open-enabled: true
  retry:
    instances:
      orderService:
        max-attempts: 3
        wait-duration: 1s
        enable-exponential-backoff: true
        exponential-backoff-multiplier: 2
  bulkhead:
    instances:
      orderService:
        max-concurrent-calls: 10
        max-wait-duration: 0
  ratelimiter:
    instances:
      orderService:
        limit-for-period: 100
        limit-refresh-period: 1s
        timeout-duration: 0
*/

// Circuit Breaker implementation
@Service
public class OrderService {

  @Autowired
  private RestTemplate restTemplate;

  @CircuitBreaker(name = "orderService", fallbackMethod = "getOrdersFallback")
  @Retry(name = "orderService")
  @RateLimiter(name = "orderService")
  @Bulkhead(name = "orderService")
  public List<Order> getOrders(Long userId) {
    String url = "http://order-service/api/orders/user/" + userId;
    ResponseEntity<List<Order>> response = restTemplate.exchange(
      url,
      HttpMethod.GET,
      null,
      new ParameterizedTypeReference<List<Order>>() {}
    );
    return response.getBody();
  }

  // Fallback method with same signature + Throwable
  public List<Order> getOrdersFallback(Long userId, Throwable throwable) {
    // Log the error
    System.err.println("Fallback triggered: " + throwable.getMessage());

    // Return cached data or default response
    return Collections.emptyList();
  }

  // Alternative fallback with custom logic
  public List<Order> getOrdersFallback(Long userId, Exception exception) {
    // Check cache
    List<Order> cachedOrders = getCachedOrders(userId);
    if (cachedOrders != null) {
      return cachedOrders;
    }

    // Return empty list with error indicator
    return new ArrayList<>();
  }

  private List<Order> getCachedOrders(Long userId) {
    // Implement caching logic
    return null;
  }
}

// Circuit Breaker events monitoring
@Component
public class CircuitBreakerEventListener {

  @EventListener
  public void onCircuitBreakerEvent(CircuitBreakerOnStateTransitionEvent event) {
    System.out.println("Circuit Breaker State Transition: "
      + event.getStateTransition());
  }

  @EventListener
  public void onCircuitBreakerError(CircuitBreakerOnErrorEvent event) {
    System.out.println("Circuit Breaker Error: "
      + event.getThrowable().getMessage());
  }
}

// Circuit Breaker health endpoint
@RestController
@RequestMapping("/api/health")
public class HealthController {

  @Autowired
  private CircuitBreakerRegistry circuitBreakerRegistry;

  @GetMapping("/circuit-breakers")
  public Map<String, String> getCircuitBreakersStatus() {
    return circuitBreakerRegistry.getAllCircuitBreakers().stream()
      .collect(Collectors.toMap(
        CircuitBreaker::getName,
        cb -> cb.getState().toString()
      ));
  }

  @GetMapping("/circuit-breaker/{name}/metrics")
  public CircuitBreaker.Metrics getMetrics(@PathVariable String name) {
    return circuitBreakerRegistry.circuitBreaker(name).getMetrics();
  }
}
// Output: Resilient microservices with circuit breaker, retry, and rate limiting

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 4. Spring Cloud Gateway with Routing
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Gateway Application
@SpringBootApplication
public class ApiGatewayApplication {
  public static void main(String[] args) {
    SpringApplication.run(ApiGatewayApplication.class, args);
  }
}

// application.yml for Gateway
/*
server:
  port: 8080

spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - StripPrefix=1
            - name: CircuitBreaker
              args:
                name: userService
                fallbackUri: forward:/fallback/users
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenishRate: 10
                  burstCapacity: 20

        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - RewritePath=/api/orders/(?<segment>.*), /\${segment}
            - AddRequestHeader=X-Request-Source, Gateway
            - AddResponseHeader=X-Response-Time, \${responseTime}

        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
            - Method=GET,POST
            - Header=X-Request-Id, \\d+
          filters:
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,GATEWAY_TIMEOUT
                methods: GET,POST
                backoff:
                  firstBackoff: 50ms
                  maxBackoff: 500ms
                  factor: 2

      default-filters:
        - name: GlobalFilter
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
*/

// Custom Global Filter
@Component
public class LoggingGlobalFilter implements GlobalFilter, Ordered {

  @Override
  public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    ServerHttpRequest request = exchange.getRequest();
    System.out.println("Request Path: " + request.getPath());
    System.out.println("Request Method: " + request.getMethod());
    System.out.println("Request Headers: " + request.getHeaders());

    long startTime = System.currentTimeMillis();

    return chain.filter(exchange).then(Mono.fromRunnable(() -> {
      long endTime = System.currentTimeMillis();
      System.out.println("Response Status: "
        + exchange.getResponse().getStatusCode());
      System.out.println("Execution Time: " + (endTime - startTime) + "ms");
    }));
  }

  @Override
  public int getOrder() {
    return -1; // Highest priority
  }
}

// Custom Gateway Filter Factory
@Component
public class CustomHeaderGatewayFilterFactory
    extends AbstractGatewayFilterFactory<CustomHeaderGatewayFilterFactory.Config> {

  public CustomHeaderGatewayFilterFactory() {
    super(Config.class);
  }

  @Override
  public GatewayFilter apply(Config config) {
    return (exchange, chain) -> {
      ServerHttpRequest request = exchange.getRequest().mutate()
        .header(config.getHeaderName(), config.getHeaderValue())
        .build();

      return chain.filter(exchange.mutate().request(request).build());
    };
  }

  public static class Config {
    private String headerName;
    private String headerValue;

    // Getters and setters
    public String getHeaderName() { return headerName; }
    public void setHeaderName(String headerName) { this.headerName = headerName; }
    public String getHeaderValue() { return headerValue; }
    public void setHeaderValue(String headerValue) { this.headerValue = headerValue; }
  }
}

// Fallback controller
@RestController
@RequestMapping("/fallback")
public class FallbackController {

  @GetMapping("/users")
  public ResponseEntity<Map<String, String>> usersFallback() {
    return ResponseEntity.ok(Map.of(
      "message", "User service is temporarily unavailable",
      "status", "fallback"
    ));
  }

  @GetMapping("/orders")
  public ResponseEntity<Map<String, String>> ordersFallback() {
    return ResponseEntity.ok(Map.of(
      "message", "Order service is temporarily unavailable",
      "status", "fallback"
    ));
  }
}
// Output: API Gateway with routing, filtering, rate limiting, and circuit breakers

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 5. Load Balancing with LoadBalancer
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// pom.xml dependency
/*
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
*/

// Load Balanced RestTemplate
@Configuration
public class LoadBalancerConfig {

  @Bean
  @LoadBalanced
  public RestTemplate restTemplate() {
    return new RestTemplate();
  }

  // WebClient with Load Balancing
  @Bean
  @LoadBalanced
  public WebClient.Builder webClientBuilder() {
    return WebClient.builder();
  }
}

// Using Load Balanced RestTemplate
@Service
public class UserService {

  @Autowired
  private RestTemplate restTemplate;

  public User getUserById(Long id) {
    // Service name resolves to actual instance via load balancer
    String url = "http://user-service/api/users/" + id;
    return restTemplate.getForObject(url, User.class);
  }
}

// Using Load Balanced WebClient
@Service
public class OrderService {

  private final WebClient webClient;

  public OrderService(@LoadBalanced WebClient.Builder webClientBuilder) {
    this.webClient = webClientBuilder.build();
  }

  public Mono<Order> getOrderById(Long id) {
    return webClient.get()
      .uri("http://order-service/api/orders/{id}", id)
      .retrieve()
      .bodyToMono(Order.class);
  }

  public Flux<Order> getUserOrders(Long userId) {
    return webClient.get()
      .uri("http://order-service/api/orders/user/{userId}", userId)
      .retrieve()
      .bodyToFlux(Order.class);
  }
}

// Custom Load Balancer Configuration
@Configuration
@LoadBalancerClient(name = "user-service", configuration = UserServiceLoadBalancerConfig.class)
public class LoadBalancerConfiguration {
}

@Configuration
public class UserServiceLoadBalancerConfig {

  @Bean
  public ServiceInstanceListSupplier serviceInstanceListSupplier(
      ConfigurableApplicationContext context) {
    return ServiceInstanceListSupplier.builder()
      .withDiscoveryClient()
      .withHealthChecks()
      .withCaching()
      .build(context);
  }

  // Custom load balancing strategy
  @Bean
  public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
      Environment environment,
      LoadBalancerClientFactory loadBalancerClientFactory) {
    String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
    return new RandomLoadBalancer(
      loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
      name
    );
  }
}

// Health-aware load balancing
@Configuration
public class HealthCheckLoadBalancerConfig {

  @Bean
  public ServiceInstanceListSupplier healthCheckServiceInstanceListSupplier(
      ConfigurableApplicationContext context) {
    return ServiceInstanceListSupplier.builder()
      .withBlockingDiscoveryClient()
      .withHealthChecks(healthCheckClient())
      .build(context);
  }

  @Bean
  public HealthCheckServiceInstanceListSupplier.HealthCheckClient healthCheckClient() {
    return serviceInstance -> {
      // Custom health check logic
      try {
        RestTemplate restTemplate = new RestTemplate();
        String healthUrl = "http://" + serviceInstance.getHost()
          + ":" + serviceInstance.getPort() + "/actuator/health";
        ResponseEntity<String> response = restTemplate.getForEntity(
          healthUrl, String.class);
        return response.getStatusCode().is2xxSuccessful();
      } catch (Exception e) {
        return false;
      }
    };
  }
}

// Weighted load balancing
@Configuration
public class WeightedLoadBalancerConfig {

  @Bean
  public ServiceInstanceListSupplier weightedServiceInstanceListSupplier(
      ConfigurableApplicationContext context) {
    return ServiceInstanceListSupplier.builder()
      .withDiscoveryClient()
      .withWeighted()
      .build(context);
  }
}

// Service instance metadata for weights
/*
eureka:
  instance:
    metadata-map:
      weight: 5  # Higher weight = more traffic
*/

// Manual load balancer usage
@Service
public class ManualLoadBalancerService {

  @Autowired
  private LoadBalancerClient loadBalancerClient;

  public String callService() {
    ServiceInstance instance = loadBalancerClient.choose("user-service");
    if (instance == null) {
      throw new ServiceUnavailableException("No instances available");
    }

    String baseUrl = "http://" + instance.getHost() + ":" + instance.getPort();
    RestTemplate restTemplate = new RestTemplate();
    return restTemplate.getForObject(baseUrl + "/api/users", String.class);
  }
}
// Output: Client-side load balancing with health checks and custom strategies`
        }
      ],
      description: 'Comprehensive Spring Cloud implementation with Eureka, Config Server, Gateway, and load balancing.'
    },
    {
      id: 'spring-aop-advanced', x: 980, y: 440, width: 350, height: 160,
      icon: 'üéØ', title: 'Spring AOP Advanced', color: '#8b5cf6',
      details: [
        {
          name: 'Spring AOP Complete Guide',
          explanation: 'Comprehensive Spring AOP implementation covering aspect definitions, pointcut expressions, advice types, transaction management, and logging aspects for cross-cutting concerns.',
          codeExample: `// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 1. Aspect Definition with Pointcut Expressions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Enable AspectJ Auto Proxy
@Configuration
@EnableAspectJAutoProxy
public class AopConfig {
}

// Basic Aspect with Pointcut
@Aspect
@Component
public class LoggingAspect {

  private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

  // Pointcut for all methods in service package
  @Pointcut("execution(* com.example.service..*.*(..))")
  public void serviceLayer() {}

  // Pointcut for all repository methods
  @Pointcut("execution(* com.example.repository..*.*(..))")
  public void repositoryLayer() {}

  // Pointcut for all controller methods
  @Pointcut("execution(* com.example.controller..*.*(..))")
  public void controllerLayer() {}

  // Pointcut combining multiple expressions
  @Pointcut("serviceLayer() || repositoryLayer()")
  public void dataAccessLayer() {}

  // Pointcut with annotations
  @Pointcut("@annotation(com.example.annotation.Loggable)")
  public void loggableMethods() {}

  // Pointcut with specific method signature
  @Pointcut("execution(public * save*(..)) && args(entity)")
  public void saveMethods(Object entity) {}

  // Pointcut for methods with specific return type
  @Pointcut("execution(com.example.dto.UserDTO *.*(..))")
  public void userDtoReturningMethods() {}

  // Pointcut with bean name pattern
  @Pointcut("bean(*Service)")
  public void serviceBean() {}

  // Pointcut within specific class
  @Pointcut("within(com.example.service.UserService)")
  public void withinUserService() {}

  // Pointcut with this and target
  @Pointcut("this(com.example.service.BaseService)")
  public void proxyImplementsBaseService() {}

  @Pointcut("target(com.example.service.BaseService)")
  public void targetImplementsBaseService() {}
}

// Advanced Pointcut Expressions
@Aspect
@Component
public class AdvancedPointcutAspect {

  // Method with specific annotation and parameters
  @Pointcut("@annotation(org.springframework.web.bind.annotation.PostMapping) && args(request,..)")
  public void postMappingWithRequest(Object request) {}

  // Method with @Transactional annotation
  @Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
  public void transactionalMethods() {}

  // Methods in classes annotated with @Service
  @Pointcut("@within(org.springframework.stereotype.Service)")
  public void serviceAnnotatedClasses() {}

  // Methods with @Cacheable annotation
  @Pointcut("@annotation(org.springframework.cache.annotation.Cacheable)")
  public void cacheableMethods() {}

  // Exclude specific methods
  @Pointcut("execution(* com.example..*.*(..)) && !execution(* com.example.config..*.*(..))")
  public void allExceptConfig() {}

  // Methods with specific parameter types
  @Pointcut("execution(* *..*.*(Long, String)) && args(id, name)")
  public void methodsWithLongAndString(Long id, String name) {}
}
// Output: Flexible pointcut expressions for precise aspect targeting

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 2. Before, After, Around Advice Types
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Aspect
@Component
@Order(1) // Aspect execution order
public class AdviceTypesAspect {

  private static final Logger logger = LoggerFactory.getLogger(AdviceTypesAspect.class);

  // Before Advice - executes before method
  @Before("execution(* com.example.service.*.*(..))")
  public void beforeAdvice(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String className = joinPoint.getTarget().getClass().getSimpleName();
    Object[] args = joinPoint.getArgs();

    logger.info("Before executing: {}.{}() with args: {}",
      className, methodName, Arrays.toString(args));
  }

  // Before Advice with annotation
  @Before("@annotation(loggable)")
  public void beforeLoggable(JoinPoint joinPoint, Loggable loggable) {
    logger.info("Loggable method called: {} with level: {}",
      joinPoint.getSignature().getName(), loggable.level());
  }

  // After Advice - executes after method (finally)
  @After("execution(* com.example.service.*.*(..))")
  public void afterAdvice(JoinPoint joinPoint) {
    logger.info("After executing: {}", joinPoint.getSignature().getName());
  }

  // Around Advice - wraps method execution
  @Around("execution(* com.example.service.*.*(..))")
  public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
    String methodName = joinPoint.getSignature().getName();

    logger.info("Around Before: {}", methodName);
    long startTime = System.currentTimeMillis();

    Object result = null;
    try {
      // Proceed with method execution
      result = joinPoint.proceed();
      logger.info("Around After: {} returned {}", methodName, result);
    } catch (Exception e) {
      logger.error("Around Exception: {} threw {}", methodName, e.getMessage());
      throw e;
    } finally {
      long endTime = System.currentTimeMillis();
      logger.info("Around Finally: {} took {}ms", methodName, (endTime - startTime));
    }

    return result;
  }

  // Around Advice with modified arguments
  @Around("execution(* com.example.service.UserService.updateUser(..)) && args(user)")
  public Object aroundUpdateUser(ProceedingJoinPoint joinPoint, User user) throws Throwable {
    // Modify arguments before proceeding
    user.setUpdatedAt(LocalDateTime.now());
    logger.info("Modified user before update: {}", user);

    // Proceed with modified arguments
    Object result = joinPoint.proceed(new Object[]{user});

    // Modify result if needed
    return result;
  }

  // Around Advice with conditional execution
  @Around("@annotation(cacheable)")
  public Object aroundCacheable(ProceedingJoinPoint joinPoint, Cacheable cacheable)
      throws Throwable {
    String cacheKey = generateCacheKey(joinPoint);

    // Check cache
    Object cachedValue = getFromCache(cacheKey);
    if (cachedValue != null) {
      logger.info("Returning cached value for key: {}", cacheKey);
      return cachedValue;
    }

    // Execute method
    Object result = joinPoint.proceed();

    // Store in cache
    putInCache(cacheKey, result);
    return result;
  }

  private String generateCacheKey(ProceedingJoinPoint joinPoint) {
    return joinPoint.getSignature().toString() + Arrays.toString(joinPoint.getArgs());
  }

  private Object getFromCache(String key) {
    // Cache lookup logic
    return null;
  }

  private void putInCache(String key, Object value) {
    // Cache storage logic
  }
}
// Output: Flexible advice types for different interception points

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 3. @AfterReturning & @AfterThrowing Advice
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Aspect
@Component
public class AfterAdviceAspect {

  private static final Logger logger = LoggerFactory.getLogger(AfterAdviceAspect.class);

  // AfterReturning - executes after successful return
  @AfterReturning(
    pointcut = "execution(* com.example.service.*.*(..))",
    returning = "result"
  )
  public void afterReturningAdvice(JoinPoint joinPoint, Object result) {
    logger.info("Method {} returned: {}",
      joinPoint.getSignature().getName(), result);

    // Post-process the result
    if (result instanceof List) {
      logger.info("Returned list size: {}", ((List<?>) result).size());
    }
  }

  // AfterReturning with specific return type
  @AfterReturning(
    pointcut = "execution(com.example.dto.UserDTO com.example.service.*.*(..))",
    returning = "userDto"
  )
  public void afterReturningUserDto(JoinPoint joinPoint, UserDTO userDto) {
    logger.info("UserDTO returned: id={}, username={}",
      userDto.getId(), userDto.getUsername());

    // Audit logging
    auditLog("USER_RETRIEVED", userDto.getId());
  }

  // AfterReturning for save operations
  @AfterReturning(
    pointcut = "execution(* com.example.service.*.save*(..)) && args(entity)",
    returning = "savedEntity"
  )
  public void afterSaveEntity(JoinPoint joinPoint, Object entity, Object savedEntity) {
    logger.info("Entity saved: {} -> {}", entity, savedEntity);

    // Send notification
    sendNotification("ENTITY_SAVED", savedEntity);
  }

  // AfterThrowing - executes when exception thrown
  @AfterThrowing(
    pointcut = "execution(* com.example.service.*.*(..))",
    throwing = "exception"
  )
  public void afterThrowingAdvice(JoinPoint joinPoint, Throwable exception) {
    logger.error("Method {} threw exception: {}",
      joinPoint.getSignature().getName(), exception.getMessage());

    // Error notification
    notifyError(joinPoint, exception);
  }

  // AfterThrowing with specific exception type
  @AfterThrowing(
    pointcut = "execution(* com.example.service.*.*(..))",
    throwing = "exception"
  )
  public void afterThrowingDataException(JoinPoint joinPoint,
                                          DataAccessException exception) {
    logger.error("Data access error in {}: {}",
      joinPoint.getSignature().getName(), exception.getMessage());

    // Database error handling
    handleDatabaseError(exception);
  }

  // AfterThrowing with error recovery
  @AfterThrowing(
    pointcut = "@annotation(com.example.annotation.ErrorRecoverable)",
    throwing = "exception"
  )
  public void afterThrowingRecoverable(JoinPoint joinPoint, Exception exception) {
    logger.warn("Recoverable error in {}: {}",
      joinPoint.getSignature().getName(), exception.getMessage());

    // Attempt recovery
    attemptRecovery(joinPoint, exception);
  }

  private void auditLog(String action, Object entityId) {
    // Audit logging implementation
  }

  private void sendNotification(String event, Object data) {
    // Notification implementation
  }

  private void notifyError(JoinPoint joinPoint, Throwable exception) {
    // Error notification implementation
  }

  private void handleDatabaseError(DataAccessException exception) {
    // Database error handling
  }

  private void attemptRecovery(JoinPoint joinPoint, Exception exception) {
    // Error recovery logic
  }
}

// Custom annotation for loggable methods
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {
  String level() default "INFO";
}

// Custom annotation for error recoverable methods
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ErrorRecoverable {
  int maxRetries() default 3;
}
// Output: Sophisticated return and exception handling with AOP

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 4. Transaction Management with @Transactional
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Enable transaction management
@Configuration
@EnableTransactionManagement
public class TransactionConfig {

  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
    return new JpaTransactionManager(emf);
  }
}

// Aspect for transaction monitoring
@Aspect
@Component
public class TransactionMonitoringAspect {

  private static final Logger logger = LoggerFactory.getLogger(TransactionMonitoringAspect.class);

  @Around("@annotation(transactional)")
  public Object monitorTransaction(ProceedingJoinPoint joinPoint,
                                    Transactional transactional) throws Throwable {
    String methodName = joinPoint.getSignature().getName();
    logger.info("Starting transaction for: {}", methodName);
    logger.info("Transaction propagation: {}", transactional.propagation());
    logger.info("Transaction isolation: {}", transactional.isolation());

    long startTime = System.currentTimeMillis();
    Object result = null;

    try {
      result = joinPoint.proceed();
      long duration = System.currentTimeMillis() - startTime;
      logger.info("Transaction committed for: {} in {}ms", methodName, duration);
    } catch (Exception e) {
      logger.error("Transaction rolled back for: {} - {}", methodName, e.getMessage());
      throw e;
    }

    return result;
  }
}

// Service with various transaction configurations
@Service
public class TransactionalService {

  @Autowired
  private UserRepository userRepository;

  @Autowired
  private OrderRepository orderRepository;

  // Basic transaction
  @Transactional
  public User createUser(User user) {
    return userRepository.save(user);
  }

  // Read-only transaction (performance optimization)
  @Transactional(readOnly = true)
  public List<User> getAllUsers() {
    return userRepository.findAll();
  }

  // Transaction with custom propagation
  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public Order createOrder(Order order) {
    // Always creates new transaction, suspending current if exists
    return orderRepository.save(order);
  }

  // Transaction with custom isolation level
  @Transactional(isolation = Isolation.SERIALIZABLE)
  public void updateInventory(Long productId, int quantity) {
    // Highest isolation level to prevent concurrent modifications
    Product product = productRepository.findById(productId)
      .orElseThrow(() -> new NotFoundException("Product not found"));
    product.setQuantity(product.getQuantity() - quantity);
    productRepository.save(product);
  }

  // Transaction with rollback rules
  @Transactional(rollbackFor = {Exception.class},
                 noRollbackFor = {BusinessException.class})
  public void processPayment(Payment payment) throws Exception {
    // Rolls back for all exceptions except BusinessException
    paymentRepository.save(payment);
    // ... payment processing logic
  }

  // Transaction with timeout
  @Transactional(timeout = 30) // 30 seconds
  public void longRunningOperation() {
    // Transaction will rollback if exceeds 30 seconds
    // ... long operation
  }

  // Nested transactions
  @Transactional
  public void createUserWithOrders(User user, List<Order> orders) {
    User savedUser = userRepository.save(user);

    orders.forEach(order -> {
      order.setUser(savedUser);
      createOrderInNewTransaction(order); // New transaction
    });
  }

  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public Order createOrderInNewTransaction(Order order) {
    return orderRepository.save(order);
  }

  // Programmatic transaction management
  @Autowired
  private PlatformTransactionManager transactionManager;

  public void programmaticTransaction() {
    TransactionDefinition def = new DefaultTransactionDefinition();
    TransactionStatus status = transactionManager.getTransaction(def);

    try {
      // Transactional operations
      User user = new User();
      userRepository.save(user);

      // Commit transaction
      transactionManager.commit(status);
    } catch (Exception e) {
      // Rollback on error
      transactionManager.rollback(status);
      throw e;
    }
  }

  // TransactionTemplate for programmatic control
  @Autowired
  private TransactionTemplate transactionTemplate;

  public User createUserWithTemplate(User user) {
    return transactionTemplate.execute(status -> {
      try {
        return userRepository.save(user);
      } catch (Exception e) {
        status.setRollbackOnly();
        throw e;
      }
    });
  }
}
// Output: Comprehensive transaction management with declarative and programmatic approaches

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 5. Logging Aspect for Performance Monitoring
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@Aspect
@Component
@Order(0) // Execute before other aspects
public class PerformanceMonitoringAspect {

  private static final Logger logger = LoggerFactory.getLogger(PerformanceMonitoringAspect.class);

  @Autowired
  private MetricsService metricsService;

  // Performance monitoring for all service methods
  @Around("execution(* com.example.service..*.*(..))")
  public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
    String className = joinPoint.getSignature().getDeclaringTypeName();
    String methodName = joinPoint.getSignature().getName();
    String fullMethodName = className + "." + methodName;

    // Start timing
    long startTime = System.currentTimeMillis();
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();

    Object result = null;
    boolean success = true;

    try {
      result = joinPoint.proceed();
      return result;
    } catch (Throwable e) {
      success = false;
      throw e;
    } finally {
      stopWatch.stop();
      long executionTime = stopWatch.getTotalTimeMillis();

      // Log performance metrics
      if (executionTime > 1000) {
        logger.warn("Slow execution: {} took {}ms", fullMethodName, executionTime);
      } else {
        logger.info("Performance: {} took {}ms", fullMethodName, executionTime);
      }

      // Record metrics
      metricsService.recordExecutionTime(fullMethodName, executionTime, success);
    }
  }

  // Detailed performance monitoring with arguments
  @Around("@annotation(com.example.annotation.MonitorPerformance)")
  public Object detailedPerformanceMonitoring(ProceedingJoinPoint joinPoint)
      throws Throwable {
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    String methodName = signature.getName();
    Object[] args = joinPoint.getArgs();

    // Log method entry
    logger.info("Entering: {} with args: {}", methodName, Arrays.toString(args));

    long startTime = System.currentTimeMillis();
    long startMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();

    Object result = null;
    Exception caughtException = null;

    try {
      result = joinPoint.proceed();
    } catch (Exception e) {
      caughtException = e;
      throw e;
    } finally {
      long endTime = System.currentTimeMillis();
      long endMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      long executionTime = endTime - startTime;
      long memoryUsed = endMemory - startMemory;

      // Create performance report
      PerformanceReport report = PerformanceReport.builder()
        .methodName(methodName)
        .executionTime(executionTime)
        .memoryUsed(memoryUsed)
        .arguments(args)
        .result(result)
        .exception(caughtException)
        .timestamp(LocalDateTime.now())
        .build();

      // Log detailed report
      logger.info("Performance Report: {}", report);

      // Store metrics
      metricsService.storePerformanceReport(report);
    }

    return result;
  }

  // Database query performance monitoring
  @Around("execution(* com.example.repository..*.*(..))")
  public Object monitorDatabaseQueries(ProceedingJoinPoint joinPoint) throws Throwable {
    String repositoryName = joinPoint.getSignature().getDeclaringTypeName();
    String methodName = joinPoint.getSignature().getName();

    long startTime = System.currentTimeMillis();
    Object result = joinPoint.proceed();
    long executionTime = System.currentTimeMillis() - startTime;

    // Log slow queries
    if (executionTime > 500) {
      logger.warn("Slow database query: {}.{} took {}ms",
        repositoryName, methodName, executionTime);
    }

    // Record query metrics
    metricsService.recordDatabaseQuery(repositoryName, methodName, executionTime);

    return result;
  }
}

// Custom annotation for performance monitoring
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MonitorPerformance {
  String description() default "";
  boolean logArguments() default true;
  boolean logResult() default true;
}

// Performance report model
@Data
@Builder
public class PerformanceReport {
  private String methodName;
  private long executionTime;
  private long memoryUsed;
  private Object[] arguments;
  private Object result;
  private Exception exception;
  private LocalDateTime timestamp;
}

// Metrics service
@Service
public class MetricsService {

  private final Map<String, List<Long>> executionTimes = new ConcurrentHashMap<>();

  public void recordExecutionTime(String methodName, long executionTime, boolean success) {
    executionTimes.computeIfAbsent(methodName, k -> new ArrayList<>()).add(executionTime);
    // Send to monitoring system (e.g., Micrometer, Prometheus)
  }

  public void storePerformanceReport(PerformanceReport report) {
    // Store report in database or send to analytics
  }

  public void recordDatabaseQuery(String repository, String method, long executionTime) {
    // Record database query metrics
  }

  public Map<String, Double> getAverageExecutionTimes() {
    return executionTimes.entrySet().stream()
      .collect(Collectors.toMap(
        Map.Entry::getKey,
        e -> e.getValue().stream().mapToLong(Long::longValue).average().orElse(0.0)
      ));
  }
}
// Output: Comprehensive performance monitoring with detailed metrics and reporting`
        }
      ],
      description: 'Comprehensive Spring AOP implementation with aspects, pointcuts, advice types, and performance monitoring.'
    },
    {
      id: 'spring-batch-advanced', x: 1430, y: 440, width: 350, height: 160,
      icon: '‚öôÔ∏è', title: 'Spring Batch Advanced', color: '#f59e0b',
      details: [
        {
          name: 'Spring Batch Complete Guide',
          explanation: 'Comprehensive Spring Batch implementation covering job configuration, step execution, chunk-oriented processing, readers/processors/writers, and error handling for batch operations.',
          codeExample: `// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 1. Job & Step Configuration
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Enable Spring Batch
@Configuration
@EnableBatchProcessing
public class BatchConfig {

  @Autowired
  private JobBuilderFactory jobBuilderFactory;

  @Autowired
  private StepBuilderFactory stepBuilderFactory;

  @Autowired
  private DataSource dataSource;

  // Simple Job with Single Step
  @Bean
  public Job importUserJob(Step importUserStep) {
    return jobBuilderFactory.get("importUserJob")
      .incrementer(new RunIdIncrementer())
      .listener(jobExecutionListener())
      .start(importUserStep)
      .build();
  }

  @Bean
  public Step importUserStep(ItemReader<UserDTO> reader,
                             ItemProcessor<UserDTO, User> processor,
                             ItemWriter<User> writer) {
    return stepBuilderFactory.get("importUserStep")
      .<UserDTO, User>chunk(100) // Process 100 items per chunk
      .reader(reader)
      .processor(processor)
      .writer(writer)
      .faultTolerant()
      .skipLimit(10)
      .skip(Exception.class)
      .retryLimit(3)
      .retry(Exception.class)
      .listener(stepExecutionListener())
      .build();
  }

  // Multi-Step Job with Flow
  @Bean
  public Job complexJob() {
    return jobBuilderFactory.get("complexJob")
      .incrementer(new RunIdIncrementer())
      .start(step1())
      .next(step2())
      .next(step3())
      .build();
  }

  // Conditional Flow - Decision-based execution
  @Bean
  public Job conditionalJob() {
    return jobBuilderFactory.get("conditionalJob")
      .start(step1())
      .on("COMPLETED").to(step2())
      .from(step1()).on("FAILED").to(errorStep())
      .from(step2()).on("COMPLETED").to(step3())
      .end()
      .build();
  }

  // Parallel Steps
  @Bean
  public Job parallelJob() {
    Flow flow1 = new FlowBuilder<Flow>("flow1")
      .start(step1())
      .build();

    Flow flow2 = new FlowBuilder<Flow>("flow2")
      .start(step2())
      .build();

    Flow parallelFlow = new FlowBuilder<Flow>("parallelFlow")
      .split(new SimpleAsyncTaskExecutor())
      .add(flow1, flow2)
      .build();

    return jobBuilderFactory.get("parallelJob")
      .start(parallelFlow)
      .end()
      .build();
  }

  // Partitioned Step - Process data in parallel partitions
  @Bean
  public Job partitionedJob(Step masterStep) {
    return jobBuilderFactory.get("partitionedJob")
      .start(masterStep)
      .build();
  }

  @Bean
  public Step masterStep(Partitioner partitioner, Step slaveStep) {
    return stepBuilderFactory.get("masterStep")
      .partitioner("slaveStep", partitioner)
      .step(slaveStep)
      .gridSize(4) // Number of partitions
      .taskExecutor(taskExecutor())
      .build();
  }

  @Bean
  public TaskExecutor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(4);
    executor.setMaxPoolSize(8);
    executor.setQueueCapacity(25);
    executor.setThreadNamePrefix("batch-");
    executor.initialize();
    return executor;
  }

  // Job and Step Listeners
  @Bean
  public JobExecutionListener jobExecutionListener() {
    return new JobExecutionListener() {
      @Override
      public void beforeJob(JobExecution jobExecution) {
        System.out.println("Job Starting: " + jobExecution.getJobInstance().getJobName());
      }

      @Override
      public void afterJob(JobExecution jobExecution) {
        System.out.println("Job Completed: " + jobExecution.getStatus());
        System.out.println("Duration: " +
          (jobExecution.getEndTime().getTime() - jobExecution.getStartTime().getTime()) + "ms");
      }
    };
  }

  @Bean
  public StepExecutionListener stepExecutionListener() {
    return new StepExecutionListener() {
      @Override
      public void beforeStep(StepExecution stepExecution) {
        System.out.println("Step Starting: " + stepExecution.getStepName());
      }

      @Override
      public ExitStatus afterStep(StepExecution stepExecution) {
        System.out.println("Step Completed. Read: " + stepExecution.getReadCount() +
          " Written: " + stepExecution.getWriteCount());
        return stepExecution.getExitStatus();
      }
    };
  }
}
// Output: Flexible job orchestration with steps, flows, and parallel processing

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 2. ItemReader, ItemProcessor, ItemWriter
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// CSV File Reader
@Bean
public FlatFileItemReader<UserDTO> csvReader() {
  return new FlatFileItemReaderBuilder<UserDTO>()
    .name("csvReader")
    .resource(new ClassPathResource("users.csv"))
    .delimited()
    .names("id", "firstName", "lastName", "email", "age")
    .linesToSkip(1) // Skip header
    .fieldSetMapper(new BeanWrapperFieldSetMapper<>() {{
      setTargetType(UserDTO.class);
    }})
    .build();
}

// Database Reader with Pagination
@Bean
public JdbcPagingItemReader<User> databaseReader(DataSource dataSource) {
  return new JdbcPagingItemReaderBuilder<User>()
    .name("databaseReader")
    .dataSource(dataSource)
    .queryProvider(queryProvider(dataSource))
    .pageSize(100)
    .rowMapper(new BeanPropertyRowMapper<>(User.class))
    .build();
}

@Bean
public PagingQueryProvider queryProvider(DataSource dataSource) {
  SqlPagingQueryProviderFactoryBean factory = new SqlPagingQueryProviderFactoryBean();
  factory.setDataSource(dataSource);
  factory.setSelectClause("SELECT id, username, email, created_at");
  factory.setFromClause("FROM users");
  factory.setWhereClause("WHERE active = true");
  factory.setSortKey("id");

  try {
    return factory.getObject();
  } catch (Exception e) {
    throw new RuntimeException(e);
  }
}

// JPA Repository Reader
@Bean
public RepositoryItemReader<Order> repositoryReader(OrderRepository orderRepository) {
  return new RepositoryItemReaderBuilder<Order>()
    .name("repositoryReader")
    .repository(orderRepository)
    .methodName("findByStatus")
    .arguments(Arrays.asList(OrderStatus.PENDING))
    .pageSize(50)
    .sorts(Collections.singletonMap("id", Sort.Direction.ASC))
    .build();
}

// JSON File Reader
@Bean
public JsonItemReader<Product> jsonReader() {
  return new JsonItemReaderBuilder<Product>()
    .jsonObjectReader(new JacksonJsonObjectReader<>(Product.class))
    .resource(new ClassPathResource("products.json"))
    .name("jsonReader")
    .build();
}

// Custom Item Reader
public class CustomItemReader implements ItemReader<CustomData> {

  private Iterator<CustomData> dataIterator;
  private List<CustomData> data;

  public CustomItemReader(List<CustomData> data) {
    this.data = data;
    this.dataIterator = data.iterator();
  }

  @Override
  public CustomData read() {
    if (dataIterator.hasNext()) {
      return dataIterator.next();
    }
    return null; // Return null to signal end of data
  }
}

// Item Processor - Transform and Validate
@Component
public class UserItemProcessor implements ItemProcessor<UserDTO, User> {

  @Autowired
  private UserValidator validator;

  @Override
  public User process(UserDTO dto) throws Exception {
    // Validation
    if (!validator.isValid(dto)) {
      return null; // Skip invalid items
    }

    // Transformation
    User user = new User();
    user.setUsername(dto.getFirstName() + "." + dto.getLastName());
    user.setEmail(dto.getEmail().toLowerCase());
    user.setAge(dto.getAge());
    user.setCreatedAt(LocalDateTime.now());
    user.setActive(true);

    // Additional processing
    user.setPasswordHash(generateRandomPassword());

    return user;
  }

  private String generateRandomPassword() {
    return UUID.randomUUID().toString();
  }
}

// Composite Item Processor - Chain multiple processors
@Bean
public CompositeItemProcessor<UserDTO, User> compositeProcessor() {
  CompositeItemProcessor<UserDTO, User> processor = new CompositeItemProcessor<>();
  processor.setDelegates(Arrays.asList(
    validationProcessor(),
    transformationProcessor(),
    enrichmentProcessor()
  ));
  return processor;
}

// Database Writer
@Bean
public JdbcBatchItemWriter<User> databaseWriter(DataSource dataSource) {
  return new JdbcBatchItemWriterBuilder<User>()
    .dataSource(dataSource)
    .sql("INSERT INTO users (username, email, age, created_at, active) " +
         "VALUES (:username, :email, :age, :createdAt, :active)")
    .beanMapped()
    .build();
}

// JPA Repository Writer
@Bean
public RepositoryItemWriter<User> repositoryWriter(UserRepository userRepository) {
  RepositoryItemWriter<User> writer = new RepositoryItemWriter<>();
  writer.setRepository(userRepository);
  writer.setMethodName("save");
  return writer;
}

// File Writer
@Bean
public FlatFileItemWriter<User> fileWriter() {
  return new FlatFileItemWriterBuilder<User>()
    .name("fileWriter")
    .resource(new FileSystemResource("output/users.csv"))
    .delimited()
    .delimiter(",")
    .names("id", "username", "email", "age")
    .headerCallback(writer -> writer.write("ID,Username,Email,Age"))
    .build();
}

// Custom Item Writer
public class CustomItemWriter implements ItemWriter<User> {

  @Autowired
  private UserService userService;

  @Override
  public void write(List<? extends User> users) throws Exception {
    for (User user : users) {
      userService.processUser(user);
      // Additional custom logic
    }
  }
}
// Output: Flexible data reading, processing, and writing with various sources

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 3. Chunk-Oriented Processing
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Chunk-based Step Configuration
@Bean
public Step chunkStep() {
  return stepBuilderFactory.get("chunkStep")
    .<UserDTO, User>chunk(100) // Chunk size: 100 items
    .reader(csvReader())
    .processor(userProcessor())
    .writer(databaseWriter())
    .listener(chunkListener())
    .listener(itemReadListener())
    .listener(itemProcessListener())
    .listener(itemWriteListener())
    .build();
}

// Chunk Listener
@Component
public class CustomChunkListener implements ChunkListener {

  private static final Logger logger = LoggerFactory.getLogger(CustomChunkListener.class);

  @Override
  public void beforeChunk(ChunkContext context) {
    logger.info("Starting chunk processing");
  }

  @Override
  public void afterChunk(ChunkContext context) {
    StepExecution stepExecution = context.getStepContext().getStepExecution();
    logger.info("Chunk completed. Items processed: {}",
      stepExecution.getReadCount());
  }

  @Override
  public void afterChunkError(ChunkContext context) {
    logger.error("Chunk processing failed");
  }
}

// Item Read Listener
@Component
public class ItemReadListenerImpl implements ItemReadListener<UserDTO> {

  private static final Logger logger = LoggerFactory.getLogger(ItemReadListenerImpl.class);

  @Override
  public void beforeRead() {
    // Called before each item read
  }

  @Override
  public void afterRead(UserDTO item) {
    logger.debug("Read item: {}", item);
  }

  @Override
  public void onReadError(Exception ex) {
    logger.error("Error reading item: {}", ex.getMessage());
  }
}

// Item Process Listener
@Component
public class ItemProcessListenerImpl implements ItemProcessListener<UserDTO, User> {

  private static final Logger logger = LoggerFactory.getLogger(ItemProcessListenerImpl.class);

  @Override
  public void beforeProcess(UserDTO item) {
    logger.debug("Processing item: {}", item);
  }

  @Override
  public void afterProcess(UserDTO item, User result) {
    if (result == null) {
      logger.warn("Item filtered out: {}", item);
    } else {
      logger.debug("Processed: {} -> {}", item, result);
    }
  }

  @Override
  public void onProcessError(UserDTO item, Exception e) {
    logger.error("Error processing item {}: {}", item, e.getMessage());
  }
}

// Item Write Listener
@Component
public class ItemWriteListenerImpl implements ItemWriteListener<User> {

  private static final Logger logger = LoggerFactory.getLogger(ItemWriteListenerImpl.class);

  @Override
  public void beforeWrite(List<? extends User> items) {
    logger.info("Writing {} items", items.size());
  }

  @Override
  public void afterWrite(List<? extends User> items) {
    logger.info("Successfully wrote {} items", items.size());
  }

  @Override
  public void onWriteError(Exception exception, List<? extends User> items) {
    logger.error("Error writing {} items: {}", items.size(), exception.getMessage());
  }
}

// Tasklet-based Step (Alternative to chunk processing)
@Bean
public Step taskletStep() {
  return stepBuilderFactory.get("taskletStep")
    .tasklet((contribution, chunkContext) -> {
      // Custom logic
      System.out.println("Executing tasklet");

      // Perform operation
      performCleanup();

      return RepeatStatus.FINISHED;
    })
    .build();
}

// Custom Tasklet
@Component
public class CleanupTasklet implements Tasklet {

  @Autowired
  private FileService fileService;

  @Override
  public RepeatStatus execute(StepContribution contribution,
                               ChunkContext chunkContext) throws Exception {
    // Cleanup old files
    int deletedFiles = fileService.deleteOldFiles();

    // Update execution context
    chunkContext.getStepContext()
      .getStepExecution()
      .getExecutionContext()
      .putInt("deletedFiles", deletedFiles);

    return RepeatStatus.FINISHED;
  }
}

// Chunk Completion Policy - Custom chunk size logic
@Bean
public CompletionPolicy customCompletionPolicy() {
  return new SimpleCompletionPolicy(100) {
    @Override
    public boolean isComplete(RepeatContext context, RepeatStatus result) {
      // Custom completion logic
      return super.isComplete(context, result);
    }
  };
}
// Output: Efficient chunk-oriented processing with listeners and tasklets

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 4. Job Parameters & Job Launcher
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Job Launcher Configuration
@Service
public class BatchJobLauncher {

  @Autowired
  private JobLauncher jobLauncher;

  @Autowired
  private Job importUserJob;

  @Autowired
  private JobExplorer jobExplorer;

  @Autowired
  private JobRegistry jobRegistry;

  // Launch job with parameters
  public JobExecution runJob(String inputFile, LocalDate processDate)
      throws Exception {
    JobParameters jobParameters = new JobParametersBuilder()
      .addString("inputFile", inputFile)
      .addDate("processDate", Date.from(processDate.atStartOfDay()
        .atZone(ZoneId.systemDefault()).toInstant()))
      .addLong("timestamp", System.currentTimeMillis())
      .toJobParameters();

    return jobLauncher.run(importUserJob, jobParameters);
  }

  // Launch job asynchronously
  public void runJobAsync(String inputFile) throws Exception {
    JobParameters jobParameters = new JobParametersBuilder()
      .addString("inputFile", inputFile)
      .addLong("timestamp", System.currentTimeMillis())
      .toJobParameters();

    // Async execution
    CompletableFuture.runAsync(() -> {
      try {
        jobLauncher.run(importUserJob, jobParameters);
      } catch (Exception e) {
        e.printStackTrace();
      }
    });
  }

  // Get job status
  public JobExecution getJobExecution(Long jobExecutionId) {
    return jobExplorer.getJobExecution(jobExecutionId);
  }

  // Get all job instances
  public List<JobInstance> getJobInstances(String jobName, int start, int count) {
    return jobExplorer.getJobInstances(jobName, start, count);
  }

  // Restart failed job
  public JobExecution restartJob(Long jobExecutionId) throws Exception {
    JobExecution failedExecution = jobExplorer.getJobExecution(jobExecutionId);
    JobInstance jobInstance = failedExecution.getJobInstance();
    Job job = jobRegistry.getJob(jobInstance.getJobName());

    JobParameters parameters = failedExecution.getJobParameters();
    return jobLauncher.run(job, parameters);
  }

  // Stop running job
  public void stopJob(Long jobExecutionId) throws Exception {
    JobExecution execution = jobExplorer.getJobExecution(jobExecutionId);
    execution.setStatus(BatchStatus.STOPPING);
  }
}

// Accessing Job Parameters in Components
@Component
@StepScope
public class ParameterizedReader implements ItemReader<String> {

  @Value("#{jobParameters['inputFile']}")
  private String inputFile;

  @Value("#{jobParameters['processDate']}")
  private Date processDate;

  @Override
  public String read() throws Exception {
    System.out.println("Reading from: " + inputFile);
    System.out.println("Process date: " + processDate);
    return null;
  }
}

// Job Parameter Validator
public class JobParameterValidator implements JobParametersValidator {

  @Override
  public void validate(JobParameters parameters) throws JobParametersInvalidException {
    String inputFile = parameters.getString("inputFile");
    if (inputFile == null || inputFile.isEmpty()) {
      throw new JobParametersInvalidException("Input file parameter is required");
    }

    File file = new File(inputFile);
    if (!file.exists()) {
      throw new JobParametersInvalidException("Input file does not exist: " + inputFile);
    }
  }
}

// REST Controller for Job Management
@RestController
@RequestMapping("/api/batch")
public class BatchController {

  @Autowired
  private BatchJobLauncher batchJobLauncher;

  @PostMapping("/jobs/{jobName}/start")
  public ResponseEntity<Map<String, Object>> startJob(
      @PathVariable String jobName,
      @RequestBody Map<String, String> parameters) throws Exception {

    JobExecution execution = batchJobLauncher.runJob(
      parameters.get("inputFile"),
      LocalDate.parse(parameters.get("processDate"))
    );

    Map<String, Object> response = new HashMap<>();
    response.put("jobExecutionId", execution.getId());
    response.put("status", execution.getStatus().toString());
    response.put("startTime", execution.getStartTime());

    return ResponseEntity.ok(response);
  }

  @GetMapping("/jobs/executions/{id}")
  public ResponseEntity<JobExecutionDTO> getJobExecution(@PathVariable Long id) {
    JobExecution execution = batchJobLauncher.getJobExecution(id);

    JobExecutionDTO dto = new JobExecutionDTO();
    dto.setId(execution.getId());
    dto.setStatus(execution.getStatus().toString());
    dto.setStartTime(execution.getStartTime());
    dto.setEndTime(execution.getEndTime());
    dto.setExitStatus(execution.getExitStatus().getExitCode());

    return ResponseEntity.ok(dto);
  }

  @PostMapping("/jobs/executions/{id}/restart")
  public ResponseEntity<Map<String, String>> restartJob(@PathVariable Long id)
      throws Exception {
    JobExecution execution = batchJobLauncher.restartJob(id);
    return ResponseEntity.ok(Map.of(
      "message", "Job restarted",
      "jobExecutionId", execution.getId().toString()
    ));
  }

  @PostMapping("/jobs/executions/{id}/stop")
  public ResponseEntity<Map<String, String>> stopJob(@PathVariable Long id)
      throws Exception {
    batchJobLauncher.stopJob(id);
    return ResponseEntity.ok(Map.of("message", "Job stop requested"));
  }
}
// Output: Complete job lifecycle management with parameters and REST API

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ú¶ 5. Skip & Retry Policies with Error Handling
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Fault-Tolerant Step Configuration
@Bean
public Step faultTolerantStep() {
  return stepBuilderFactory.get("faultTolerantStep")
    .<UserDTO, User>chunk(100)
    .reader(csvReader())
    .processor(userProcessor())
    .writer(databaseWriter())
    .faultTolerant()
    // Skip Configuration
    .skipLimit(50) // Maximum 50 skips
    .skip(ValidationException.class)
    .skip(FlatFileParseException.class)
    .noSkip(NullPointerException.class)
    // Retry Configuration
    .retryLimit(3) // Retry up to 3 times
    .retry(DeadlockLoserDataAccessException.class)
    .retry(TransientDataAccessException.class)
    .noRetry(NonTransientDataAccessException.class)
    // Backoff Policy
    .retryPolicy(retryPolicy())
    .backOffPolicy(backOffPolicy())
    // Listeners
    .listener(skipListener())
    .listener(retryListener())
    .build();
}

// Custom Retry Policy
@Bean
public RetryPolicy retryPolicy() {
  SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
  retryPolicy.setMaxAttempts(3);
  return retryPolicy;
}

// Exponential Backoff Policy
@Bean
public BackOffPolicy backOffPolicy() {
  ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
  backOffPolicy.setInitialInterval(1000); // 1 second
  backOffPolicy.setMaxInterval(10000);    // 10 seconds
  backOffPolicy.setMultiplier(2.0);       // Double each time
  return backOffPolicy;
}

// Skip Listener
@Component
public class CustomSkipListener implements SkipListener<UserDTO, User> {

  private static final Logger logger = LoggerFactory.getLogger(CustomSkipListener.class);

  @Override
  public void onSkipInRead(Throwable t) {
    logger.warn("Skipped during read: {}", t.getMessage());
  }

  @Override
  public void onSkipInProcess(UserDTO item, Throwable t) {
    logger.warn("Skipped during process. Item: {}, Error: {}",
      item, t.getMessage());
    // Log to error table
    logSkippedItem(item, t);
  }

  @Override
  public void onSkipInWrite(User item, Throwable t) {
    logger.warn("Skipped during write. Item: {}, Error: {}",
      item, t.getMessage());
    // Handle write failures
    handleWriteFailure(item, t);
  }

  private void logSkippedItem(UserDTO item, Throwable t) {
    // Save to error log table
  }

  private void handleWriteFailure(User item, Throwable t) {
    // Dead letter queue or retry mechanism
  }
}

// Retry Listener
@Component
public class CustomRetryListener implements RetryListener {

  private static final Logger logger = LoggerFactory.getLogger(CustomRetryListener.class);

  @Override
  public <T, E extends Throwable> boolean open(RetryContext context,
                                                RetryCallback<T, E> callback) {
    logger.info("Retry starting");
    return true;
  }

  @Override
  public <T, E extends Throwable> void close(RetryContext context,
                                              RetryCallback<T, E> callback,
                                              Throwable throwable) {
    if (throwable != null) {
      logger.error("Retry exhausted after {} attempts",
        context.getRetryCount());
    } else {
      logger.info("Retry succeeded after {} attempts",
        context.getRetryCount());
    }
  }

  @Override
  public <T, E extends Throwable> void onError(RetryContext context,
                                                RetryCallback<T, E> callback,
                                                Throwable throwable) {
    logger.warn("Retry attempt {} failed: {}",
      context.getRetryCount(), throwable.getMessage());
  }
}

// Custom Exception Handler
@Component
public class BatchExceptionHandler implements StepExecutionListener {

  @Override
  public void beforeStep(StepExecution stepExecution) {
    // Setup
  }

  @Override
  public ExitStatus afterStep(StepExecution stepExecution) {
    List<Throwable> exceptions = stepExecution.getFailureExceptions();

    if (!exceptions.isEmpty()) {
      // Analyze exceptions
      long validationErrors = exceptions.stream()
        .filter(e -> e instanceof ValidationException)
        .count();

      long databaseErrors = exceptions.stream()
        .filter(e -> e instanceof DataAccessException)
        .count();

      System.out.println("Validation errors: " + validationErrors);
      System.out.println("Database errors: " + databaseErrors);

      // Decide exit status based on errors
      if (databaseErrors > 10) {
        return new ExitStatus("FAILED_WITH_DATABASE_ERRORS");
      }
    }

    return stepExecution.getExitStatus();
  }
}

// Dead Letter Queue for Failed Items
@Component
public class DeadLetterQueueWriter implements ItemWriter<User> {

  @Autowired
  private ErrorLogRepository errorLogRepository;

  @Override
  public void write(List<? extends User> items) throws Exception {
    for (User user : items) {
      ErrorLog errorLog = new ErrorLog();
      errorLog.setItemData(user.toString());
      errorLog.setErrorTime(LocalDateTime.now());
      errorLog.setProcessed(false);
      errorLogRepository.save(errorLog);
    }
  }
}

// Scheduled Job for Retry Failed Items
@Component
public class RetryFailedItemsJob {

  @Autowired
  private ErrorLogRepository errorLogRepository;

  @Autowired
  private UserService userService;

  @Scheduled(cron = "0 0 2 * * ?") // Run at 2 AM daily
  public void retryFailedItems() {
    List<ErrorLog> failedItems = errorLogRepository
      .findByProcessedFalse();

    for (ErrorLog errorLog : failedItems) {
      try {
        // Retry processing
        userService.processErrorLog(errorLog);
        errorLog.setProcessed(true);
        errorLog.setRetryTime(LocalDateTime.now());
        errorLogRepository.save(errorLog);
      } catch (Exception e) {
        errorLog.setRetryCount(errorLog.getRetryCount() + 1);
        errorLogRepository.save(errorLog);
      }
    }
  }
}
// Output: Robust error handling with skip, retry, and dead letter queue mechanisms`
        }
      ],
      description: 'Comprehensive Spring Batch implementation with jobs, steps, chunk processing, and error handling.'
    }
  ]

  const handleComponentClick = (component) => {
    setSelectedComponent(component)
    setIsModalOpen(true)
  }

  const closeModal = () => {
    setIsModalOpen(false)
    setSelectedComponent(null)
    setSelectedConcept(null)


  }

  // Use refs to access current modal state in event handler
  const selectedConceptRef = useRef(selectedConcept)
  useEffect(() => {
    selectedConceptRef.current = selectedConcept
  }, [selectedConcept])


  // Set initial focus on mount
  useEffect(() => {
    setFocusedComponentIndex(0)
  }, [])

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e) => {
      const currentSelectedConcept = selectedConceptRef.current
      // Handle Escape to close modal or go back to menu
      if (e.key === 'Escape') {
        if (currentSelectedConcept) {
          e.preventDefault()
          e.stopImmediatePropagation()
          setSelectedConcept(null)
          return
        }
        return
      }

      if (currentSelectedConcept) {
        // Modal is open, don't handle other keys
        return
      }

      // Navigation when modal is closed
      const componentCount = components.length

      switch(e.key) {
        case 'ArrowRight':
        case 'ArrowDown':
          e.preventDefault()
          setFocusedComponentIndex((prev) => (prev + 1) % componentCount)
          break
        case 'ArrowLeft':
        case 'ArrowUp':
          e.preventDefault()
          setFocusedComponentIndex((prev) => (prev - 1 + componentCount) % componentCount)
          break
        case 'Enter':
        case ' ':
          e.preventDefault()
          if (components[focusedComponentIndex]) {
            handleComponentClick(components[focusedComponentIndex])
          }
          break
        default:
          break
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [focusedComponentIndex])

  const handleConceptClick = (concept) => {
    setSelectedConcept(concept)
  }

  return (
    <div style={{
      padding: '2rem',
      maxWidth: '95%',
      margin: '120px auto 0',
      backgroundColor: 'white',
      borderRadius: '16px',
      boxShadow: '0 20px 40px -10px rgba(0, 0, 0, 0.15)',
      border: '3px solid rgba(16, 185, 129, 0.4)'
    }}>
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '2rem'
      }}>
        <button
          onClick={onBack}
          style={{
            padding: '0.75rem 1.5rem',
            fontSize: '1rem',
            fontWeight: '600',
            backgroundColor: '#6b7280',
            color: 'white',
            border: 'none',
            borderRadius: '8px',
            cursor: 'pointer',
            transition: 'all 0.2s ease'
          }}
        >
          ‚Üê Back to Menu
        </button>
        <h1 style={{
          fontSize: '2.5rem',
          fontWeight: '800',
          color: '#1f2937',
          margin: 0,
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        }}>
          üå± Spring Framework Ecosystem
        </h1>
        <div style={{ width: '120px' }}></div>
      </div>

      <div style={{
        backgroundColor: 'rgba(16, 185, 129, 0.05)',
        padding: '2.5rem 10rem',
        borderRadius: '16px',
        border: '3px solid rgba(16, 185, 129, 0.3)',
        marginBottom: '2rem'
      }}>
        <p style={{
          fontSize: '1.3rem',
          color: '#374151',
          fontWeight: '500',
          margin: 0,
          lineHeight: '1.8',
          textAlign: 'center'
        }}>
          Comprehensive Spring ecosystem covering Spring Boot for rapid development, Spring Core for dependency injection,
          Spring MVC/WebFlux for web applications, Spring Data for data access, Spring Security for authentication,
          Spring Cloud for microservices, and Spring AOP for cross-cutting concerns.
        </p>
      </div>

      <ModernDiagram
        components={components}
        onComponentClick={handleComponentClick}
        title="Spring Framework Architecture"
        width={1400}
        height={800}
        containerWidth={1800}
      
        focusedIndex={focusedComponentIndex}
      />

      {/* Modal */}
      {isModalOpen && selectedComponent && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.7)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 99999
        }}>
          <div style={{
            backgroundColor: 'white',
            padding: '2.5rem',
            borderRadius: '16px',
            maxWidth: '1400px',
            width: '95%',
            maxHeight: '85vh',
            overflowY: 'auto',
            boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
            border: '3px solid rgba(16, 185, 129, 0.4)'
          }}>
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '2rem'
            }}>
              <h2 style={{
                fontSize: '2rem',
                fontWeight: '800',
                color: '#1f2937',
                margin: 0,
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
              }}>
                {selectedComponent.icon} {selectedComponent.title}
              </h2>
              <button
                onClick={closeModal}
                style={{
                  padding: '0.5rem 1rem',
                  fontSize: '1.25rem',
                  fontWeight: '600',
                  backgroundColor: '#ef4444',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease'
                }}
              >
                ‚úï
              </button>
            </div>

            <div style={{
              backgroundColor: 'rgba(16, 185, 129, 0.05)',
              padding: '1.5rem',
              borderRadius: '12px',
              border: '2px solid rgba(16, 185, 129, 0.2)',
              marginBottom: '2rem'
            }}>
              <p style={{
                fontSize: '1.1rem',
                color: '#374151',
                fontWeight: '500',
                margin: 0,
                lineHeight: '1.6'
              }}>
                {selectedComponent.description}
              </p>
            </div>

            <div style={{
              display: 'grid',
              gridTemplateColumns: selectedConcept ? '1fr 1fr' : '1fr',
              gap: '2rem'
            }}>
              <div>
                <h3 style={{
                  fontSize: '1.25rem',
                  fontWeight: '700',
                  color: '#1f2937',
                  marginBottom: '1rem'
                }}>
                  Key Features
                </h3>
                <div style={{
                  display: 'grid',
                  gap: '0.75rem'
                }}>
                  {selectedComponent.details.map((detail, idx) => (
                    <div
                      key={idx}
                      onClick={() => handleConceptClick(detail)}
                      style={{
                        backgroundColor: selectedConcept?.name === detail.name
                          ? 'rgba(16, 185, 129, 0.15)'
                          : 'white',
                        padding: '0.75rem',
                        borderRadius: '8px',
                        border: selectedConcept?.name === detail.name
                          ? '2px solid rgba(16, 185, 129, 0.4)'
                          : '2px solid rgba(16, 185, 129, 0.2)',
                        fontSize: '0.95rem',
                        fontWeight: '500',
                        color: selectedConcept?.name === detail.name
                          ? '#059669'
                          : '#047857',
                        cursor: 'pointer',
                        transition: 'all 0.2s ease',
                        transform: 'scale(1)'
                      }}
                      onMouseEnter={(e) => {
                        if (selectedConcept?.name !== detail.name) {
                          e.target.style.backgroundColor = 'rgba(16, 185, 129, 0.15)'
                          e.target.style.transform = 'scale(1.02)'
                          e.target.style.borderColor = 'rgba(16, 185, 129, 0.4)'
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (selectedConcept?.name !== detail.name) {
                          e.target.style.backgroundColor = 'white'
                          e.target.style.transform = 'scale(1)'
                          e.target.style.borderColor = 'rgba(16, 185, 129, 0.2)'
                        }
                      }}
                    >
                      ‚Ä¢ {detail.name}
                      {selectedConcept?.name === detail.name && (
                        <span style={{
                          fontSize: '0.8rem',
                          opacity: 0.8,
                          marginLeft: '0.5rem',
                          fontWeight: '600'
                        }}>
                          ‚Üê Selected
                        </span>
                      )}
                    </div>
                  ))}
                </div>
              </div>

              {selectedConcept && (
                <div>
                  <h3 style={{
                    fontSize: '1.25rem',
                    fontWeight: '700',
                    color: '#1f2937',
                    marginBottom: '1rem'
                  }}>
                    {selectedConcept.name}
                  </h3>

                  <div style={{
                    backgroundColor: 'rgba(16, 185, 129, 0.05)',
                    padding: '1.5rem',
                    borderRadius: '12px',
                    border: '2px solid rgba(16, 185, 129, 0.2)',
                    marginBottom: '1.5rem'
                  }}>
                    <p style={{
                      fontSize: '1rem',
                      color: '#374151',
                      fontWeight: '500',
                      margin: 0,
                      lineHeight: '1.7',
                      textAlign: 'justify'
                    }}>
                      {selectedConcept.explanation}
                    </p>
                  </div>

                  {selectedConcept.codeExample && (() => {
                    const sections = parseCodeSections(selectedConcept.codeExample)

                    if (sections.length === 0) {
                      // No sections found, display as single code block
                      return (
                        <div style={{
                          backgroundColor: '#1e293b',
                          padding: '1.5rem',
                          borderRadius: '12px',
                          border: '2px solid #334155',
                          marginBottom: '1.5rem'
                        }}>
                          <h4 style={{
                            fontSize: '1rem',
                            fontWeight: '700',
                            color: '#60a5fa',
                            margin: '0 0 1rem 0'
                          }}>
                            üíª Code Example
                          </h4>
                          <SyntaxHighlighter code={selectedConcept.codeExample} />
                        </div>
                      )
                    }

                    // Render sections with dropdowns
                    return (
                      <div style={{ marginBottom: '1.5rem' }}>
                        <h4 style={{
                          fontSize: '1rem',
                          fontWeight: '700',
                          color: '#1e293b',
                          margin: '0 0 1rem 0'
                        }}>
                          üíª Code Examples ({sections.length} sections)
                        </h4>
                        {sections.map((section, idx) => {
                          const sectionId = `${selectedConcept.name}-section-${idx}`
                          const isExpanded = expandedSections[sectionId]

                          return (
                            <div key={idx} style={{ marginBottom: '0.75rem' }}>
                              <button
                                onClick={() => toggleSection(sectionId)}
                                style={{
                                  width: '100%',
                                  padding: '1rem',
                                  backgroundColor: isExpanded ? '#10b981' : '#059669',
                                  color: 'white',
                                  border: 'none',
                                  borderRadius: '8px',
                                  cursor: 'pointer',
                                  fontSize: '0.95rem',
                                  fontWeight: '600',
                                  textAlign: 'left',
                                  display: 'flex',
                                  justifyContent: 'space-between',
                                  alignItems: 'center',
                                  transition: 'all 0.2s ease'
                                }}
                              >
                                <span>{section.title}</span>
                                <span style={{
                                  fontSize: '1.2rem',
                                  transition: 'transform 0.2s ease',
                                  transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)'
                                }}>
                                  ‚ñº
                                </span>
                              </button>

                              {isExpanded && (
                                <div style={{
                                  backgroundColor: '#1e293b',
                                  padding: '1.5rem',
                                  borderRadius: '0 0 8px 8px',
                                  border: '2px solid #334155',
                                  borderTop: 'none',
                                  marginTop: '-4px'
                                }}>
                                  <SyntaxHighlighter code={section.code} />
                                </div>
                              )}
                            </div>
                          )
                        })}
                      </div>
                    )
                  })()}

                  <div style={{
                    backgroundColor: 'rgba(59, 130, 246, 0.05)',
                    padding: '1.25rem',
                    borderRadius: '12px',
                    border: '2px solid rgba(59, 130, 246, 0.2)'
                  }}>
                    <h4 style={{
                      fontSize: '1rem',
                      fontWeight: '700',
                      color: '#1e40af',
                      margin: '0 0 0.75rem 0'
                    }}>
                      üí° Key Takeaway
                    </h4>
                    <p style={{
                      fontSize: '0.9rem',
                      color: '#1e40af',
                      fontWeight: '500',
                      margin: 0,
                      lineHeight: '1.5',
                      fontStyle: 'italic'
                    }}>
                      {selectedConcept.name} is a powerful Spring feature that enables enterprise-grade Java applications with robust, scalable, and maintainable architecture patterns.
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

    </div>
  )
}

export default Spring
